[{"content":" シナリオ # サーバー復旧後、IRチームは継続するトラフィック、隠された通信、および終了措置を回避する執拗なプロセスの迷宮を発見しました。ンシデントの範囲はサーバーとクライアントへの最初の侵害を超えていることが明らかです。フォレンジック調査の専門家として、これらの秘密裏の活動を隠す影を照らし出すことはできますか？\nセットアップ # このSherlockチャレンジでは以下を使用します：\nVolatility2 IDA さらにこのチートシートを参照します：\nhttps://downloads.volatilityfoundation.org/releases/2.4/CheatSheet_v2.4.pdf Volatilityプロファイル # まずPython 2とVolatility2をインストールし、必要なプロファイルを追加します。\nVolatilityプロファイルは、ターゲットOSの構造情報を含むファイルです。特定のシステムのメモリ内でデータがどのように構成されているかをVolatilityが理解するための「地図」のようなものです。\nこのプロファイルは主に次の2種類の情報を含みます：\nカーネルデータ構造の定義 カーネルシンボル（関数や変数のアドレス） インストール：\nsudo apt install -y python2 python2-dev build-essential libdistorm3-dev libssl-dev libffi-dev zlib1g-dev curl -sS https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py sudo python2 get-pip.py sudo python2 -m pip install --upgrade pip setuptools wheel sudo python2 -m pip install distorm3 pycrypto openpyxl pillow yara-python git clone https://github.com/volatilityfoundation/volatility.git cd volatility python2 vol.py -h プロファイル設定：\ncp Ubuntu_5.3.0-70-generic_profile.zip ~/Documents/volatility/volatility/plugins/overlays/linux/ python2 vol.py --info | grep Linux 質問1 # 攻撃者がリバースシェルに使用したIPとポートは何ですか？\nメモリキャプチャ時点のすべてのネットワーク接続をダンプするためにlinux_netstatプラグインを使用します。出力をファイルにリダイレクトし、検索を容易にします。\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_netstat \u0026gt; netstat.txt Linuxでは、乱雑なBashリバースシェルである可能性が高く、実際に：\n回答：10.0.2.6:443\n質問2 # 悪意あるリバースシェル接続のPPIDは何ですか？\nまずは linux_pstree を試してみます：\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_pstree | grep -C 5 3633 PPIDがありません。なぜでしょう？\nlinux_pstree プラグインは、単一の情報源――システムのアクティブタスクリスト（task_struct）――に基づいてプロセスツリーを再構築します。\nhttps://makelinux.github.io/kernel/map/\nそこで、隠れプロセス検出に特化した linux_psxview プラグインを使用します。複数のアーティファクトを集約してプロセスを識別します：\ntask_struct リスト: linux_pstree と同じアクティブタスクリスト pid ハッシュテーブル: カーネルのPID高速検索用ハッシュテーブル pslist: 別のメモリ構造から抽出したプロセスリスト kmem_cache: 隠れタスクを参照している可能性があるカーネルオブジェクトキャッシュ d_path: procfsからのファイルシステムパスでプロセスディレクトリを露出検出 thread_info: 非リンクプロセスを浮かび上がらせるスレッドメタデータ linux_psxview はこれらの情報源を相互比較し、不整合を検出します。例えば、あるソースには存在するが別のソースにはないPIDなどです。\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_psxview \u0026gt; psxview.txt 期待どおり、親プロセスは直前のPIDです。\nでは、なぜ隠されていたのでしょうか？ シナリオの内容から、ルートキットによる操作であることが明らかです。おそらく、ルートキットはタスクリスト（task_struct リスト）を改ざんし、自身のリバースシェルプロセスをリンクリストから“unlink”しました。具体的には、next と prev ポインタを操作し、リスト走査時にプロセスが無視されるようにしています。\nしかし、ルートキットは存在の痕跡を完全には消し切れていません。他の構造体のうち複数のいずれかを linux_psxview が監視する中で、変更を怠っている箇所が残っていました。\n結果として、linux_pstree はタスクリストだけを参照するため悪意あるプロセスを見逃しますが、linux_psxview は複数の情報源をチェックすることで、ルートキットが見落とした構造体経由で検出できる、というわけです。\n回答 : 3632\n質問3 # 悪意あるカーネルモジュールの名前を答えよ。\nこのために linux_check_modules プラグインを使用します。ただ、その前にコンテキストを整理しましょう。そもそもカーネルモジュールとは何か、またそれはルートキットとどのように関係するのでしょうか？\nカーネルモジュールとは、実行中のOSカーネルに動的にロード／アンロードできるコードの断片です。これにより、再起動やカーネルの再コンパイルなしで新しいハードウェアサポートやファイルシステム機能を追加できます。\nルートキットは独自のLoadable Kernel Modules（LKM）を使ってLinuxカーネルレベルで動作します。これらの悪意あるモジュールは：\nシステムコールをフックしてファイル、プロセス、ネットワーク接続を隠蔽 システムに永続的なバックドアを確立 カーネルのセキュリティ機能を無効化 標準ツールから自身の存在を隠蔽\n…などを行います。 Volatilityの linux_check_modules プラグインは、複数のカーネル情報ソースを突き合わせることで隠れたLKMを検出します。\n1. 公式モジュールリスト\nまず、カーネルが管理する公式モジュールリスト（modules.list）を調査します。この循環連結リストには正規にロードされたすべてのモジュールが含まれ、lsmod コマンドで同じ情報が得られます。\n2. カーネルシンボルテーブル\n次に、/proc/kallsyms を解析し、モジュールが追加したものも含めたすべての関数・変数のアドレスを取得します。\n3. .ko メモリセクション\nさらに、.ko モジュールがロードされる典型的なメモリ領域をスキャンし、他の場所で参照されていなくてもモジュールコードの特徴的なシグネチャを探索します。\n4. 隠しモジュール検出テクニック\n公式リストとシンボル／メモリスキャン結果を比較し、一方に存在して他方にないモジュールを疑います。 syscallテーブルをチェックし、オリジナルのカーネル関数がフックまたは置換されていないかを確認します。 モジュール関数のアドレスが通常とは異なるメモリ領域を指していないか検証し、コードインジェクションの可能性を探ります。 モジュールのメタデータ（タイムスタンプ、名前、作者など）に矛盾や異常がないか分析します。 なるほど、でもルートキットはどのように隠れるの？\n主な手法には以下があります：\nDKOM (Direct Kernel Object Manipulation)\nメモリ上のカーネルデータ構造を直接操作し、modules.list から自モジュールをunlinkしつつ機能を維持。 システムコールフック\n正規のカーネル関数を置き換え、自作のバージョンで結果をフィルタリングまたは偽装（例：特定ファイルを表示しないreadのパッチ）。 無名モジュール\n空文字列や特殊文字名でモジュールをロードし、発見を困難にします。 さて、本題に戻ります。\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_check_modules モジュール名 \u0026ldquo;nfentlink\u0026rdquo; は、正規の \u0026ldquo;nfnetlink\u0026rdquo; モジュールを装うことで悪意あるLKMをカモフラージュしようとしたものです。nfnetlink はネットワークおよびファイアウォール機能のためにカーネル空間とユーザー空間間の通信を行う正規モジュールです。\n回答: nfentlink\n質問4 # モジュールがロードされたのは何時ですか？\n当初、私が試したアプローチには誤りがありました。その思考過程を示します：\nlinux_dmesg で dmesg からモジュールのロードタイムスタンプを取得 linux_pslist でシステム起動のタイムスタンプを取得 それらの差分を計算 もしモジュールが初回ロードであればこの方法で問題ありませんでした。しかし、既に過去にロードされていたため、この方法は根本的に誤っており、インシデントレスポンスの現場では誤誘導を招きかねません。\n最終的に私は考えをリセットし、「複数回の再起動にまたがる過去のアクションに紐づくタイムスタンプはどこにあるか？」と自問しました。\nもちろん、システムログです。特に /var/log/kern.log や /var/log/syslog.log が該当します。\nこれらのファイルを抽出するため、まずメモリキャプチャ内でファイルを列挙します：\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_enumerate_files \u0026gt; files.txt 実際には次のように見つかりました：\n次に /var/log/kern.log を抽出します：\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea5a732fa8 -O kern.log 回答：2024-05-01 20:42:57\n質問5 # 悪意あるカーネルモジュールファイルのフルパスと名前は何ですか？\n同様に、列挙したファイルを確認します。まず、特定したモジュール “nfentlink” を検索します。\ncat files.txt |grep nfentlink 特に有益な情報は見つかりませんでした。\nそこで、実際の名前でモジュールを探します：\n2つ目のファイルについては後ほど戻ります。\n回答：/lib/modules/5.3.0-70-generic/kernel/drivers/net/nfnetlink.ko\n質問6 # 悪意あるカーネルモジュールファイルのMD5ハッシュは何ですか？\nファイルを抽出してハッシュを計算します：\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea266b5a68 -O nfnetlink.ko md5sum nfnetlink.ko 回答：35bd8e64b021b862a0e650b13e0a57f7\n質問7 # 正規のカーネルモジュールファイルのフルパスと名前は何ですか？\n質問5のスクリーンショットに戻りましょう。\n回答：/lib/modules/5.3.0-70-generic/kernel/net/netfilter/nfnetlink.ko\n質問8 # 正規モジュールと悪意あるモジュールの author 値の一文字の違いは何ですか？\nまず、特定のカーネルモジュールに関する詳細情報を表示する modinfo で正規モジュールを確認します。\nmodinfo /lib/modules/6.11.2-amd64/kernel/net/netfilter/nfnetlink.ko.xz 次に、メモリキャプチャから抽出したモジュールを調査します。\nmodinfo malicious-nfnetlink.ko はっきりと “i” が欠落しているのが分かります。\n回答：i\n質問9 # 悪意あるカーネルモジュールの初期化関数の名前は何ですか？\nこの質問に答えるためにIDAを使います。オーバーキルかもしれませんが、gdb（gef\u0026gt;gdb）やradare2などでも十分です。\nでは、関数を見てみましょう：\n初期化関数が nfnetlink_init であると同時に init_module でもあることがはっきり分かります。gefで見るとさらに明確です：\ngef は両方のシンボルがまったく同じメモリアドレスを指していることを示しています。これは、ルートキットがカーネルレベルで自身を偽装するための意図的な手法です。\n悪意あるモジュールは、Linux カーネルモジュールの 必須 エントリポイントである標準の init_module 関数を利用しつつ、正規モジュールを模倣するために意図的に関数名を nfnetlink_init に変更しています。\ninit_module のようなエクスポートシンボルはカーネルがモジュールをロードするのに不可欠ですが、攻撃者はコンパイル時のトリックを使い、同一関数に二つの異なる名前（ロード用とカモフラージュ用）を持たせています。\n回答: nfnetlink_init\n質問10 # システムコールをフックする関数があります。テーブルの最後のシステムコールは何ですか？\nnfnetlink_init 関数内で _sys_call_table = kallsyms_lookup_name(\u0026quot;sys_call_table\u0026quot;); が確認できます:\n_sys_call_table = kallsyms_lookup_name(\u0026#34;sys_call_table\u0026#34;); この行は kallsyms_lookup_name を使用して、カーネルメモリ上の sys_call_table のアドレスを取得しています。\nsys_call_table はカーネルのシステムコールハンドラ関数へのポインタを格納した配列です。このテーブルを書き換えることで、攻撃者はシステムコールをマルウェアルーチンへリダイレクトできます。\n次に、.rodata セクション（読み取り専用データおよび文字列が配置される領域）のデータテーブルを調査します。\nこのテーブルには、悪意あるモジュールが各種操作のために使用またはフックしようとするシンボルへの参照が含まれています。\naX64SysGetdents db \u0026#39;_x64_sys_getdents64\u0026#39;,0 aX64SysGetdents db \u0026#39;_x64_sys_getdents\u0026#39;,0 aX64SysKill db \u0026#39;_x64_sys_kill\u0026#39;,0 これらの文字列は、モジュールがフックまたはオーバーライドしようとしているシステムコール関数シンボルに対応しています。\nこれらの関数は Linux カーネルのシステムコール API の一部であり、この場合はインターセプトまたはリダイレクトされています。\n回答: __x64_sys_kill\n質問11 # 実行中のプロセスID (PID) を隠すために、プロセスに送信する際に使用されるシグナル番号は何ですか？\nでは、hook_kill 関数を見てみましょう:\nまず目を引くのは:\ncmp dword ptr [rdi+68h], 64 および hide_pid の呼び出しです。\n続いて、IDAで生成された擬似コードを見てみます:\nif ( (*(DWORD *)(a1 + 104)) != 64 ) return ((__int64 (*) (void))orig_kill()); a1 + 104: これは kill() 呼び出しで送信されたシグナルを参照します。アドレス a1 + 104 のフィールドがシグナルの値に対応します。 (*(DWORD *)(a1 + 104)) != 64: この条件はシグナルが 64 でないかをチェックしています。 シグナルが 64 でない場合、元のシステムコール orig_kill を呼び出して通常通りカーネル実行を継続します。 シグナルが 64 の場合は hide_pid を呼び出します: sprintf(hide_pid, \u0026#34;%d\u0026#34;, *((QWORD *)(a1 + 112))); sprintf(hide_pid, \u0026quot;%d\u0026quot;, ...): ここで sprintf を使用して PID を文字列に変換し、hide_pid に渡しています。これは、モジュールがこのPIDを元に、/proc やシステムディレクトリ、その他のカーネルデータ構造からプロセスを隠蔽していることを示しています。 hide_pid: プロセスを隠蔽し、可視性を阻止する関数です。 %d: 整数（PID）を出力するためのフォーマット指定子です。 回答: 64\nラボ完了！\n","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/posts/aptnightmare2/","section":"Posts","summary":"シナリオ # サーバー復旧後、IRチームは継続するトラフィック、隠された通信、および終了措置を回避する執拗なプロセスの迷宮を発見しました。ンシデントの範囲はサーバーとクライアントへの最初の侵害を超えていることが明らかです。フォレンジック調査の専門家として、これらの秘密裏の活動を隠す影を照らし出すことはできますか？","title":"APTNightmare-2","type":"posts"},{"content":"","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/hackthebox/","section":"Tags","summary":"","title":"HackTheBox","type":"tags"},{"content":"","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/","section":"Jaybird1291","summary":"","title":"Jaybird1291","type":"page"},{"content":"","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":"","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/sherlock/","section":"Tags","summary":"","title":"Sherlock","type":"tags"},{"content":"","date":"20 4月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" シナリオ # 6月28日、顧客の環境にてPAM (Privileged Access Management) を経由しない不正なRDPセッションが検出されました。攻撃者は別サーバへの横展開（ラテラルムーブメント）のために踏み台として使ったと思われるサーバで証拠を収集しました。攻撃者はイベントログ（event logs）を削除していますが、残されたわずかなアーティファクトでも攻撃の流れを再現し、攻撃者の行動を追跡するには十分だと考えています。\nSetup # このSherlockチャレンジで使用するツール：\nZimmerman Tools (EvtxECmd, Registry Explorer, Timeline Explorer, PECmd, WxTCmd\u0026hellip;) Impacket (secretsdump.py) NirSoft DataProtectionDecryptor ANSSI BMC-tools BSI-Bund RdpCacheStitcher また、次のチートシートも参考にします：\nhttps://13cubed.s3.amazonaws.com/downloads/windows_registry_cheat_sheet.pdf\n質問 1 # emman.tユーザによる最後のログオン失敗はいつ発生したか？（UTC）\nまず、シナリオ通り本当にイベントログ（event logs）が削除されたのか確認するために、Zimmerman ToolsのEvtxECmd と Timeline Explorer を使って調査します。\nEvtxECmd.exe -d \u0026#34;C:/C___NONAME [NTFS]\\[root]\\Windows\\System32\\winevt\\Logs\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; Event ID 4625 (Account failed to log on) を探しましたが、関連するものは何も見つかりませんでした。\nそして、実際に、ログがクリアされているのが確認できます：\nもし VSS (Volume Shadow Copy) があれば、ログの復元のチャンスはあります。\nVolume Shadow Copy Service (VSS) は、特定の時点でのディスクの状態をスナップショットとして作成する Windows の機能です。VSS のスナップショットが存在すれば、削除または変更されたファイル（イベントログを含む）の以前のバージョンを復元できる可能性があります。つまり、攻撃者がライブシステム上でログをクリアしても、VSS のスナップショットから復元できるかもしれません。\nしかし、調査した結果、VSS は存在しなかったため、レジストリに頼る必要があります。\nそのため、別の Zimmerman ツールである Registry Explorer を使用します。\nSAM レジストリハイブ、具体的には SAM\\Domains\\Account\\Users を調査します。ここでは以下のようなアーティファクトが見つかります：\nlast login time last incorrect password last password change login counts group membership account creation time など そこで、C___NONAME [NTFS]\\[root]\\Windows\\System32\\config\\SAM ファイルを Registry Explorer にロードします：\nそして、確かに \u0026ldquo;Last Incorrect Password\u0026rdquo; エントリが確認できます。\nAnswer: 2024-06-26 07:24:35\n質問 2 # What are the first 3 IP addresses that emman.t connected to using Remote Desktop (RDP)?\nこれに答えるために、NTUSER.dat を調べます。これはユーザーのプロファイルフォルダにあるレジストリハイブで、個人設定やデスクトップ環境のプリファレンスが含まれています。\nユーザーがログオンする際、Windows はこのハイブを読み込み、各ユーザー固有の設定（アプリケーションの設定、アクティビティ履歴など）を適用します。\n特に注目すべきは HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client です。ここには、RDP パラメータや、ユーザーが RDP 経由で接続したサーバーのリストが保存されています。\nそこで、ユーザーの NTUSER.dat を Registry Explorer にロードし、該当のパスに移動します：\nAnswer: 192.168.86.250,192.168.25.128,192.168.25.131\n質問 3 # What is the destination username used to remote desktop to for the first time on 2024-06-20 16:01:05 UTC?\n質問 2 のスクリーンショットから既に確認できます。\nAnswer: tommyxiaomi\n質問 4 # What is the destination IP address of the last Remote Desktop (RDP) session?\n同様です。\nAnswer: 192.168.70.133\n質問 5 # emman.t is very careless in always saving RDP credentials to connect to other hosts, so we believe that attacker somehow leaked them. Please confirm credentials of the server with ip 192.168.70.133 that was leaked?\nこの質問は、非常に興味深いチャレンジです。\nまず、要点に入ります：RDP 資格情報はどこに保存されているのか？\nMicrosoft の組み込み RDP クライアントを使用して接続すると、アプリは資格情報を保存するオプションを提供します：\nWindows はこれらの資格情報を Credential Manager に保存し、「安全に」保管します。ユーザーが RDP 接続中に「資格情報を記憶する」を選択すると、資格情報はユーザーのフォルダ内に保存されます。具体的には：\nC:\\Users\\emman.t\\AppData\\Local\\Microsoft\\Credentials\nCredential Manager は DPAPI (Data Protection API) に依存して、認証データを暗号化します。この API は非常にシンプルです。\nDPAPI_IMP BOOL CryptProtectData( [in] DATA_BLOB *pDataIn, [in, optional] LPCWSTR szDataDescr, [in, optional] DATA_BLOB *pOptionalEntropy, [in] PVOID pvReserved, [in, optional] CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, [in] DWORD dwFlags, [out] DATA_BLOB *pDataOut ); DPAPI は、Microsoft や Chrome、Edge などの他のアプリケーションがパスワードや各種シークレットを保存するために広く使用されています。\nDPAPI は masterkeys を使用して、DPAPI によって保護されたデータを暗号化します。各 masterkey 自体は、ユーザーのパスワードの派生値 もしくは DPAPI システムキー を使用して暗号化されています。\nこれらの masterkeys は以下に保存されます：\nユーザー用:\nC:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming\\Microsoft\\Protect\\\u0026lt;SID\u0026gt; システム用:\nC:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18 これらは：\nユーザーパスワードの変更時や、3 ヶ月ごとに自動的に更新されます。 LSASS プロセス内にキャッシュ（一時的に平文で保存）されます（メモリフォレンジクスやペンテストに役立ちます）。 DPAPI のメカニズムは以下のように動作します：\n中央にあるのが masterkey で、これは DPAPI によるシークレットの暗号化/復号に使用される主要な鍵です。\nこの Masterkey 自体も暗号化され保護されています。状況に応じて、以下の異なる鍵で復号可能です：\nドメインユーザーアカウントパスワードの NT hash ローカルユーザーアカウントパスワードの SHA1 hash Active Directory 環境における Domain Backup Key と呼ばれるマシンキー（適切な権限があれば、ユーザーのパスワードがなくても masterkeys の復号が可能） Masterkey がこれらの鍵のいずれかで復号されると、Session Key が導出されます。これが実際に DPAPI によって保存されたデータの暗号化/復号を行います。\nDPAPI で保護されたデータを復号するために、以下のような多数のツールが使用できます：\nライブシステム上で： LaZagne pypykatz (dpapi module) mimikatz SharpDPAPI オフライン（必要なファイルを取得後）： pypykatz (dpapi module) dpapi.py (impacket) mimikatz SharpDPAPI dpapilab-ng diana DPAPI についてさらに掘り下げたい場合は、Synacktiv の以下の投稿をご覧ください（上記の説明はこれに基づいています）：Windows secrets extraction – a summary\nさて、理論が分かったところで、今回のケースにどう適用するかを考えます。私は以下のツールを使用することにしました：\nImpacket (secretsdump.py) NirSoft DataProtectionDecryptor secretsdump.py スクリプトを使用すると、ユーザーのパスワードを取得して、DPAPI シークレットを復号することができます：\nsecretsdump.py -sam \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SAM\u0026#34; --security \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SECURITY\u0026#34; --system \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SYSTEM\u0026#34; LOCAL ユーザーのパスワードハッシュを取得できたので、ブルートフォース攻撃を試みます：\nパスワードが判明すれば、DataProtectionDecryptor を使用して資格情報を復号できます：\nさらに、偶然にもユーザーのパスワードを発見する別の方法もあります：\nPowerShell のコマンド履歴を調べると、チャレンジ作成者がこれらのユーザーアカウントをセットアップした痕跡が見つかります：\nAnswer: Administrator:C@mv@0s3rv3r\n質問 6 # リモートデスクトップ接続アプリケーションが最後に実行されたのはいつですか？ (UTC)\nこれに答えるため、Prefetch のアーティファクトを調査します。\nPrefetch は、頻繁に使用されるアプリケーションの起動を高速化するため、過去の実行からの特定のデータをキャッシュする仕組みです。Windows はこれらの詳細を .pf ファイルとして、C:\\Windows\\Prefetch\\ に保存します。\n各 .pf ファイルには以下が含まれます：\n実行可能ファイルの名前 アプリケーションが起動された回数 最後の実行時刻 プロセス起動時に読み込まれた関連ファイルやライブラリのパス RDP 接続の場合、実行可能ファイルは通常 MSTSC.EXE です。対応する Prefetch ファイル（MSTSC.EXE-XXXXXX.pf）を解析することで、このマシンから RDP 接続が開始されたかどうかや、正確な起動時刻を確認できます。\nこれらを Timeline Explorer に読み込むため、まず PECmd を使用して解析する必要があります：\nPECmd.exe -d \u0026#34;C:\\___NONAME [NTFS]\\[root]\\Windows\\Prefetch\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; そして実際に、MSTSC.exe の起動データが確認できます：\n回答: 2024-06-28 13:56:48\n質問 7 # リモートデスクトップ接続アプリケーションが最後に終了されたのはいつですか？ (UTC)\nまず、NTUSER.dat レジストリハイブ内の NTUSER.DAT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\ にある UserAssist を調査します。\nこのキーは、ユーザーのアプリケーション活動を記録しており、以下が含まれます：\nプログラムが起動された回数 アプリケーションが最後に実行された正確な時刻 アプリケーションが終了（プロセス終了）した正確な時刻 これらの詳細は ROT13 でエンコードされたサブキーに保存されていますが、Registry Explorer が便利にデコードしてくれます：\nすぐに目立つのは、UserAssist の「Last Executed」値と Prefetch の「Last Run」データとの不一致です。\nなぜ Prefetch と UserAssist で違いがあるのでしょうか？\nPrefetch (.pf): プロセスレベル（mstsc.exe）での実行を記録します。 プロセスがメモリに読み込まれるたびに、その回数を増加させます（起動方法に関係なく）。 UserAssist (registry): アイコンのクリック、スタートメニューの使用、検索入力、ショートカット利用など、直接的なユーザー操作による実行のみを記録します。 間接的な実行（コマンドライン、オートスタート、スクリプトなど）は必ずしもカウントしません。 したがって、この文脈では、UserAssist 単体では正確な最終終了時刻を示しません。\n次に、アプリケーションのライフタイムを明示的に追跡する BAM キー（HKLM\\SYSTEM\\CurrentControlSet\\Services\\bam\\UserSettings\\）に注目しました。\nBAM は各実行可能ファイルについて、以下の正確な記録を保持します：\nアプリが最後に実行された時刻（プロセス開始） 終了した正確な時刻（プロセス終了） RDP アーティファクトの詳細については、以下もご参照ください：\nhttps://www.thedfirspot.com/post/lateral-movement-remote-desktop-protocol-rdp-artifacts\n回答: 2024-06-28 14:01:26\n質問 8 # 最後から2番目の RDP セッションの持続時間はどれくらいでしたか？\nActivitiesCache.db を確認しました：\nTimeline Explorer に読み込んだ後、様々な RDP セッションの持続時間がはっきりと確認できます：\n何らかの理由で、答えは -1 秒ずれています。\n回答: 00:11:42\n質問 9 # 攻撃者が最後のリモートデスクトップ (RDP) セッションを切断したのはいつですか？ (UTC)\nこれについては、ユーザーの ...\\Documents\\ ディレクトリにある \u0026ldquo;Default.rdp\u0026rdquo; ファイルを調査します。Windows は MSTSC 経由で接続するたびにこのファイルを自動生成します。\nこのファイルには以下が含まれる場合があります：\n最後の RDP 接続の IP アドレスまたはホスト名 接続に使用されたユーザー名 グラフィック設定（解像度、色深度など） ローカルリソース共有オプション（クリップボード、ローカルドライブ、プリンタなど） パフォーマンス設定（画質、圧縮など） また、ファイルの最終更新時刻も示されています：\n回答: 2024-06-28 13:51:03\n質問 10 # 設定されているリモートデスクトップのサイズは何ですか？\nDefault.rdp を再度確認すると、以下が見つかります：\n回答: 1920:1080\n質問 11 # 攻撃者は 192.168.70.133 への横展開後、ネットワークを発見するためにどのツールを使用したのでしょうか？\nこれを解明するため、RDP bitmap cache を調査する必要があります。\nWindows Remote Desktop Protocol (RDP) を使用したセッションを調査する際、RDP bitmap cache は見落とされがちですが、非常に有用なアーティファクトです。\nこのキャッシュは、画面の一部をローカルに保存することで RDP のパフォーマンスを向上させます。画面の一部が変更されていなければ、システムは再度取得するのではなくローカルキャッシュから読み出すため、ユーザー体験が高速化されます。\nフォレンジックの観点から、bitmap cache はユーザーの画面上の活動、つまりどのウィンドウが開かれていたか、表示されたコンテンツ、セッション中に行われた操作など、重要な手がかりを明らかにします。\n詳細については、以下もご参照ください：\nhttps://www.cyberengage.org/post/analyzing-and-extracting-bitmap-cache-files-from-rdp-sessions\nこれらのファイルは C:\\Users\\user\\AppData\\Local\\Microsoft\\Terminal Server Client\\Cache\\ にあります。\nキャッシュを解析およびエクスポートするために、ANSSI の \u0026ldquo;BMC-Tools\u0026rdquo; を使用し、その後 BSI Bund の \u0026ldquo;RdpCacheStitcher\u0026rdquo; を用いて解析しました：\nキャッシュされた画像を再構築することで、攻撃者がネットワークスキャンに \u0026ldquo;NetBScanner\u0026rdquo; を使用したことが確認できます。\n回答: NetBScanner\n質問 12 # 攻撃者によってイベントログが削除されたのはいつですか？ (UTC)\n質問 1 で発見した内容に戻ります：\n回答: 2024-06-28 14:03:25\n質問 13 # 攻撃者が 192.168.70.129 へのセッションを切断した時刻は？ (UTC)\nイベントログがクリアされた直後に、\u0026ldquo;An account was logged off\u0026rdquo; エントリが見られます：\n回答: 2024-06-28 14:03:53\nLab 完了！\n","date":"10 3月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/posts/latus/","section":"Posts","summary":"シナリオ # 6月28日、顧客の環境にてPAM (Privileged Access Management) を経由しない不正なRDPセッションが検出されました。攻撃者は別サーバへの横展開（ラテラルムーブメント）のために踏み台として使ったと思われるサーバで証拠を収集しました。攻撃者はイベントログ（event logs）を削除していますが、残されたわずかなアーティファクトでも攻撃の流れを再現し、攻撃者の行動を追跡するには十分だと考えています。","title":"Latus","type":"posts"},{"content":"","date":"10 3月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":"","date":"2 3月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/cyberdefenders/","section":"Tags","summary":"","title":"Cyberdefenders","type":"tags"},{"content":" シナリオ # InfiniTech Solutions の IT 従業員が、自身のメールアカウントに関連する異常なアクティビティを報告しました。調査の結果、その従業員の業務用認証情報が、最近のデータ漏洩により流出していたことが判明しました。\n従業員は、業務用メールアドレスを使ってサードパーティのプラットフォームに登録したため、認証情報が露出してしまいました。攻撃者はこの認証情報を悪用し、従業員のメールアカウントにアクセス、社内の他の従業員へフィッシングメールを送信しました。\nあなたのタスクは、ログを解析し、攻撃の範囲を把握し、ユーザーがフィッシングメールとどのように関わったのかを特定し、フィッシングキャンペーンがネットワークに与えた影響を明らかにすることです。\nセットアップ # この調査シナリオでは、主に Splunk Search を使ってログを解析します。また、xml.onlineviewer、Cyberchef、VirusTotal といった他のツールも併用します。\n注意事項 # Splunk は、システム、アプリケーション、ネットワーク機器などが生成するデータを収集、インデックス化、検索するための解析プラットフォームです。エンドポイントにインストールされたエージェント、ログファイルの取り込み、あるいは API を通じてログを取得します。\n取得したデータはインデックス化され、整理されることで検索プロセスが容易になります。Splunk は、このデータを問い合わせるために SPL（Search Processing Language）を使用します。\n初期アクセス # 質問 1 # どのメールアカウントが侵害され、攻撃の発信に使われたのか？\nまず、システム上で利用可能な \u0026ldquo;sourcetypes\u0026rdquo; を確認してみましょう:\nindex=\u0026#34;main\u0026#34; | stats count by sourcetype Splunk の sourcetype は、収集されたイベントのデータタイプや発信元を示すラベルです。\nこの質問に答えるため、まず \u0026ldquo;syslog\u0026rdquo; に注目します。syslog は、様々なデバイスから生成されるログを集約し、システムやセキュリティの詳細な情報を含むことが多いです。\n情報が溢れ出すのを防ぐため、正規表現を用いてメールアドレスのみを表示するように検索します:\n* sourcetype=syslog | regex _raw=\u0026#34;[\\w\\.-]+@[\\w\\.-]+\\.\\w+\u0026#34; 大量のログが表示されるので、各メールアドレスの出現回数をカウントし、テーブル形式で結果を表示します:\n* sourcetype=syslog | rex field=_raw \u0026#34;(?\u0026lt;email\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | stats count by email | sort -count | head 10 | rename count AS \u0026#34;Number of occurrences\u0026#34;, email AS \u0026#34;Email address\u0026#34; これをグラフで可視化することも可能です:\n回答: twhite@infinitechsolutions.xyz\n質問 2 # 侵害されたアカウントを特定した後、攻撃者は社内の他の従業員にフィッシングメールを送信しました。時系列順に、カンマ区切りでこれらの従業員の名前を教えてください。\nメール送信ログのフォーマットは以下の通りです:\nUser [sender_email] [IP_address]; Message [message_ID] for [recipient_email] 検索には以下のクエリを実行します:\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | rex field=_raw \u0026#34;Message \u0026lt;[^\u0026gt;]+\u0026gt; for (?\u0026lt;recipient\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | table _time recipient | sort _time | stats list(recipient) as recipients | eval recipients=mvjoin(recipients, \u0026#34;, \u0026#34;) このクエリにより、受信者が時系列順に抽出され、一覧表示されます。\n具体的には、侵害されたアカウントのユーザーを選択し、正規表現で受信者のメールアドレスを抽出して変数に格納しています。その後、結果を時系列で並べ替え、読みやすい形式に整えています。\n回答: rnichols,llopez,gbaker,ahall\n質問 3 # 侵害されたアカウントから送信された悪意のある添付ファイルの名前は何ですか？\nこの質問は、予想以上に手間取りました。最初は、以下のように検索しました:\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | regex _raw=\u0026#34;for (rnichols|llopez|gbaker|ahall)@infinitechsolutions\\.xyz\u0026#34; しかし、添付ファイルの痕跡は一切見つかりませんでした。そこで、「ふむ、正しい sourcetype にいないのか、他のものも検索してみよう」と思い、次のクエリで検索しました:\nindex=* \u0026#34;twhite@infinitechsolutions.xyz\u0026#34; | stats count by sourcetype 利用可能な sourcetype は syslog のみなので、正しい場所にいることが分かります。それから、フォーマットの問題を回避するために、単にファイル拡張子を探す方法に切り替えました。\nChatGPT にファイル拡張子のリストを求めた結果、以下のクエリにたどり着きました:\nindex=* sourcetype=syslog twhite@infinitechsolutions.xyz | rex field=_raw \u0026#34;attachment=(?\u0026lt;malicious_attachment\u0026gt;[\\w\\.-]+\\.(exe|zip|pdf|docx|xlsm|js|vbs|scr|bat))\u0026#34; | table _time malicious_attachment | sort _time それでも添付ファイルは見つかりませんでした。\nどうしても行き詰まったので、別の視点から考えることにしました。ラボのタイトルが \u0026ldquo;Midnight RDP\u0026rdquo; であることから、これは「Midnight Blizzard」として知られる APT を思い出させました。\n調査中に、「How Midnight Blizzard Uses Malicious .RDP Files to Exploit Windows Systems: A Technical Guide」（著: Yua Mikanana）という記事も見つけました。\nラボのタイトルを考えると、答えは明らかでした。そこで、\u0026quot;.RDP\u0026quot; を検索した結果、以下のファイルが見つかりました:\n回答: cloud zerotrust compliance.rdp\n実行 # 質問 1 # ユーザーの相互作用を分析した結果、悪意のある添付ファイルをダウンロードして実行した従業員は誰ですか？\nsourcetype を変更して、WinEventLog に切り替えます。\nWinEventLog は、Windows のイベントログで、エラー、警告、セキュリティ情報、またはアプリケーションイベントなど、システム上の様々な活動を記録し、追跡および解析を可能にします。\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; cloud zerotrust compliance.rdp ここで、ファイルをダウンロードしたユーザーのユーザー名が明確に確認できます: C:\\Users\\rnichols\\Downloads\\cloud zerotrust compliance.rdp\n回答: rnichols\n質問 2 # DC マシン上で、攻撃者がメモリ内で実行した DLL タグについて、この悪意のある DLL ファイルの SHA-256 ハッシュの最初の 10 バイトは何ですか？\nまず、DC 上で PowerShell に関連する DLL をリストアップします:\nindex=* sourcetype=xmlwineventlog \u0026#34;Powershell\u0026#34; | search host=\u0026#34;DC01\u0026#34; | rex field=_raw \u0026#34;(?\u0026lt;file\u0026gt;\\b\\w{6,8}\\.\\w{3}\\b)\u0026#34; | search file=\u0026#34;*dll\u0026#34; 完全なスクリプトが 1 つのイベントに収録するには長すぎるため、セグメントに分割されていることが分かります。これは MessageNumber によって確認できます:\n2 つのイベントは同じ ActivityID {0B39225B-3C43-0001-5078-390B433CDB01} やその他の識別子を共有しており、同じスクリプト実行に属していることを示しています。\n最初のセグメント (MessageNumber = 1) には、PowerShell 環境の設定や、func_get_proc_address、func_get_delegate_type といった関数の定義など、スクリプトの冒頭部分が含まれています。\n最後のセグメント (MessageNumber = 33) には、Base64 文字列（キー 35 で XOR されたもの）のデコードや、デコードされたコードを実行するためのメモリ割り当て部分が含まれています。\nこれらのセグメントを合わせることで、メモリ内にコードを注入・実行するためのペイロード全体が再構成されます。\n再構成されたスクリプトは、難読化されたペイロード（まず Base64、次に 35 で XOR されたもの）をデコードし、ネイティブな Windows 関数（例: VirtualAlloc を介した GetProcAddress や GetDelegateForFunctionPointer）を使用してメモリを割り当て、悪意のあるコードを実行します。\n[...] $var [...] -bxor 35 [...] Splunk 検索を使用して再構成することができます:\nindex=* sourcetype=xmlwineventlog EventID=4104 0B39225B-3C43-0001-5078-390B433CDB01 | stats values(ScriptBlockText) as Script by SystemTime | table Script その後、Cyberchef を使ってスクリプトをデコードします:\nそして、問題の DLL が見つかります:\n最後に、ファイルを抽出し、そのハッシュを取得します:\n回答: 0ee6bc20a7f855d881cce962de09c77960ea5c85ca013e3d123fce61109ff8c5\nPersistence # 質問 1 # 悪意ある接続が確立された後、システム上にファイルがドロップされました。このドロップされたファイルの名前は何ですか？\n.rdp ファイルが 20:45:27 ごろに実行されたことが分かっています（実行セクションの質問 1 を参照）。\nそのため、その時刻から検索を開始します。\nまず、PowerShell コマンド（Invoke-WebRequest、curl など）を使って Splunk でダウンロードを検索してみましたが、結果は得られませんでした。\nそこで、検索クエリを以下のように変更しました:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time なぜこれが動作するのでしょうか？\n以下はイベントの詳細です:\nフィールド TerminalSessionId=3 は、ユーザーが RDP セッションを介して接続していたことを強く示唆しています。なぜなら:\nセッション 0 はしばしば SYSTEM に使用されます。 ローカルの対話セッションは 通常 1 から始まります。 RDP セッションはしばしばより高い ID（例: 2, 3 など）を持ちます。 explorer.exe は Windows のグラフィカルインターフェースの主要プロセスであり、対話型ユーザーが起動するプログラムのランチャーとして機能します。\nこの動作を説明する考えられるシナリオ:\n対話セッション（RDP であるかどうかにかかわらず）:\nもし rnichols が RDP 経由で接続していれば、explorer.exe はユーザーシェルとして起動し、Startup に定義されたプログラム（ztssvc.exe）を実行します。 ユーザーが物理的にログインした場合や、runas などのサービスを通じても同様の状況が発生します。 ユーザーのログイン時に自動実行:\nztssvc.exe が Startup に配置されているため、ユーザーがログインするとすぐに実行されます（ローカルログインでも RDP 経由でも）。 explorer.exe を介したインジェクションまたは永続化:\n攻撃者が Startup を利用してマルウェアを持続させた場合、explorer.exe はユーザーがログインするたびに自動的にそのバイナリを実行します。 攻撃者によるエクスプロイトまたは強制実行:\nもし explorer.exe が（例えば DLL インジェクションなどにより）改ざんされていれば、ztssvc.exe を実行するために使用された可能性があります。 回答: ztssvc.exe\n質問 2 # 長期的なアクセスを維持するために、攻撃者は侵害されたマシン上でスケジュールされたタスクを作成しました。このタスクの名前は何ですか？\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=4698 OR EventCode=4702 | search user=\u0026#34;rnichols\u0026#34; | table _time EventCode TaskName Command User | rename EventCode as \u0026#34;Event ID\u0026#34;, TaskName as \u0026#34;Scheduled Task\u0026#34;, Command as \u0026#34;Executed Command\u0026#34; | sort _time 質問 3 # 永続性戦略の一環として、攻撃者は新たなユーザーアカウントを作成しました。この不正なアカウントの名前は何ですか？\n質問 1 と同じクエリを使用します:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time 結果の中に、非常に怪しげなエンコードされた PowerShell コマンドが見つかります:\nこのコマンドを Cyberchef を使ってデコードしました:\n回答: Administrator\n質問 4 # リモートアクセスを容易にするため、攻撃者はリモートデスクトップの設定を変更しました。RDP (Remote Desktop Protocol) 接続の許可を決定するレジストリキーの名前は何ですか？\n多数の Windows システムの調査・管理経験から、既に答えは分かっていましたが、確認方法は以下の通りです:\n攻撃者が実行した複数の -EncodedCommand を含む PowerShell コマンドを常に検索します:\nその中で、以下のコマンドが確認できます:\n回答: fDenyTSConnections\n質問 5 # さらなる調査により、DC 上で新しいユーザーアカウントが作成されたことが判明しました。このアカウントの名前は何ですか？\nこれは他のホストで行われたのと同じ方法で実施されたと考えられます。そこで、以下のように検索します:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; host=\u0026#34;DC01\u0026#34; \u0026#34;-EncodedCommand\u0026#34; 回答: rniclos\n特権昇格 # 質問 1 # 特権昇格手法を調査した際、攻撃者が悪用した特権 COM インターフェースの CLSID の最後の 6 バイトは何ですか？\nCLSID は、Windows COM (Component Object Model) において、レジストリ内の COM オブジェクトを識別するためのグローバルに一意な識別子 (GUID) です。\n攻撃者は、特権を持つ COM インターフェースの CLSID を利用して、より高い権限でコードを実行します：\n誤設定された COM オブジェクトを悪用して特権を昇格させます。 攻撃者は regsvr32.exe、powershell、mshta.exe、または rundll32.exe を介して、特権 COM インターフェース* を作成、操作、または呼び出すことが可能です。 ここでは、マルウェアが ztssvc.exe であることが分かっているので、ztssvc.exe の実行に関連する EventCode \u0026ldquo;1\u0026rdquo;（プロセス作成）イベントを検索し、IntegrityLevel が \u0026ldquo;High\u0026rdquo; のものだけをフィルタリングします:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=1 | search Image=\u0026#34;*ztssvc.exe*\u0026#34; | search IntegrityLevel=\u0026#34;High\u0026#34; | table _time User CommandLine IntegrityLevel ParentCommandLine | sort _time 回答: 7CE93B6DC937\n質問 2 # 特権昇格のために、攻撃者はシステム上に別のファイルをドロップしました。このファイルの名前は何ですか？\n最初のファイル（ztssvc.exe）のダウンロード後に発生したすべての動作を確認するため、同じコマンドを実行します:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time 回答: Akagi64.exe\n防御回避 # 質問 1 # 攻撃者は、システムの動作を変更してセキュリティ設定を弱体化させようと試みました。管理者ユーザー向けのユーザーアカウント制御 (UAC) プロンプト設定を管理するレジストリキーの名前は何ですか？\nこの回答は、先に観察されたエンコードされた PowerShell コマンド内に見つかります:\n回答: ConsentPromptBehaviorAdmin\n質問 2 # 検出を回避するため、攻撃者はタグを保護されたシステムディレクトリに移動させました。この移動された悪意あるファイルの名前は何ですか？\n移動が行われた場合、ファイルの作成または名前変更のイベント (Event ID 11 または 2) が発生しているはずです。\nindex=* sourcetype=xmlwineventlog EventCode=11 OR EventCode=2 \u0026#34;rnichols\u0026#34; | search TargetFilename=\u0026#34;C:\\\\Windows\\\\System32\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\Windows\\\\SysWOW64\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\ProgramData\\\\*\u0026#34; | table _time User TargetFilename ProcessName | sort _time 回答: Amazon ZeroTrust Compl.exe\n発見 # 質問 1 # 侵害されたマシン上で攻撃者の最初の行動を特定するため、システム情報を収集する最初のコマンドは何でしたか？\nマシンが 20:45:27 に侵害されたことが分かっているので（実行セクションの質問 1 を参照）、その時刻から検索を開始します:\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort — _time 回答: whoami /groups\n横方向の移動 # 質問 1 # 攻撃者はどのツールを使用して DC への横方向の移動を行いましたか？\n再度、エンコードされた PowerShell コマンドを調査する必要があります。今回は、Amazon ZeroTrust Compl.exe によって発行されたコマンドです:\npowershell -nop -exec bypass -EncodedCommand UwBlAHQALQBJAHQAZQBtACAAVwBTAE0AYQBuADoAXABsAG8AYwBhAGwAaABvAHMAdABcAEMAbABpAGUAbgB0AFwAVAByAHUAcwB0AGUAZABIAG8AcwB0AHMAIAAtAFYAYQBsAHUAZQAgACIARABDADAAMQAuAGEAZAAuAGkAbgBmAGkAbgBuAGkAdABlAGMAaABzAG8AbAB1AHQAZQBuAHMALgB4AHkAegAiACAALQBGAG8AcgBjAGUA このコマンドは、IT01 上の Windows Remote Management (WinRM) の設定を変更し、DC01.ad.infinitechsolutions.xyz をリモート接続用に信頼するようにしています。これは、PowerShell リモーティング（WinRM）を介した横方向の移動の強い指標です。\n回答: WinRM\nコマンド＆コントロール # 質問 1 # 攻撃者の活動をたどると、悪意のあるメールが送信された元の IP アドレスは何でしたか？\nフィッシングメールを送信したユーザーを検索することで、最初の質問に戻ります:\nindex=* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; 回答: 3.78.253.99\n質問 2 # cloud zerotrust compliance.rdp が IT01 で実行され、送信者のメール IP アドレスが判明しているため、以下のクエリで直接テストできます:\nindex=* sourcetype=xmlwineventlog (EventCode=1 OR EventCode=3) | search host=\u0026#34;IT01\u0026#34; | search DestinationPort=3389 AND DestinationIp=3.78.253.99 | table _time User DestinationIp DestinationPort | sort _time 回答: 3.78.253.99:3389\n質問 3 # 解析の結果、ドロップされたファイルが Cobalt Strike のビーコンとして機能していることが明らかになりました。このビーコンが通信するコマンド＆コントロール (C\u0026amp;C) サーバーのエンドポイントは何ですか？\nまず、どのファイルが Cobalt Strike のビーコンであるかを確認します:\nその後、Amazon ZeroTrust Compl.exe がどの IP/ポートに接続したかを調査します:\nindex=* sourcetype=xmlwineventlog EventCode=3 | search Image=\u0026#34;*Amazon ZeroTrust Compl.exe*\u0026#34; | search NOT DestinationIp=\u0026#34;\u0026#34; | table _time User Image DestinationIp DestinationPort Protocol | sort _time (EventCode 3 は、Windows マシン上のプロセスが確立したネットワーク接続に対応します)\n回答: 3.78.244.11:8080\n質問 4 # DLL の設定を調査すると、ビーコンの通信を指示する \u0026lsquo;C2Server\u0026rsquo; キーにはどのような値が設定されていますか？\nVirusTotal に戻り、「Behavior」タブでこの情報を確認します。\n回答: 3.78.244.11,/dot.gif\nLab 完了！\n","date":"2 3月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/posts/midnight-rdp/","section":"Posts","summary":"シナリオ # InfiniTech Solutions の IT 従業員が、自身のメールアカウントに関連する異常なアクティビティを報告しました。調査の結果、その従業員の業務用認証情報が、最近のデータ漏洩により流出していたことが判明しました。","title":"Midnight RDP Lab","type":"posts"},{"content":"","date":"2 3月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/splunk/","section":"Tags","summary":"","title":"Splunk","type":"tags"},{"content":"","date":"2 3月 2025","externalUrl":null,"permalink":"/blog-cyber/ja/tags/threat-hunting/","section":"Tags","summary":"","title":"Threat Hunting","type":"tags"},{"content":"","date":"19 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/tags/android-forensic/","section":"Tags","summary":"","title":"Android Forensic","type":"tags"},{"content":"","date":"19 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/tags/autopsy/","section":"Tags","summary":"","title":"Autopsy","type":"tags"},{"content":"","date":"19 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":" シナリオ # 当局のWiFiネットワークを侵害した悪意ある攻撃者の所在を特定することに成功しました。\n最近、OP ERADICATE作戦の一環として、ヴェロリアンの首都内のある住所で夜明けの急襲が行われ、大量の証拠品が押収されました。特に、捜査対象のエージェント所有のAndroidデバイスが没収され、攻撃現場に存在していたと考えられています。\nこのデバイスの解析と、以下の詳細な質問への回答に、あなたの専門知識を必要としています。時間が限られているため、ヴェロリアンCOBR会議があなたの所見を議論するために開催されました…\nファイル # opshieldwall2.zip\n「EVIDENCE-CASE-RAVENSKIAN-AGENT-002」を含み、Androidデバイスの「data」および「storage」フォルダが含まれています。 この構成により、/data ディレクトリには豊富な情報が含まれており、解析の余地が大きくなっています。例えば:\nCheatsheet SANS FOR585 前書き # 解析を開始する前に、Androidに関する重要な情報を以下に示します:\nAndroidのユーザーデータは内部および外部の両方に保存されることがあります。内部データは、電源が切れてもデータを保持する不揮発性メモリであるNANDフラッシュメモリに保存されます。NANDにはブートローダー、オペレーティングシステム、ユーザーデータが格納され、アプリケーションデータはNANDフラッシュメモリまたはSDカードに保存されます。\nAndroidは、LinuxカーネルのLong-Term Support（LTS）ブランチの派生版に基づいています。Android v8（Oreo）では、GoogleはLinuxカーネル4.4以上の使用を求めました。例えば、Android v9（Pie）はデバイスによって4.4、4.9、または4.14のいずれかのバージョン上で動作します。詳細はAndroid OS Wikiでご確認ください: https://source.android.com/docs/core/architecture/kernel/android-common?hl=en.\nandroid-mainline は、Android機能の主要な開発ブランチです。Linus Torvaldsがバージョンまたはリリース候補を発表するたびに、メインラインのLinuxブランチが android-mainline と統合されます:\n一般的に見られるファイルシステムには以下が含まれます:\nEXT4 F2FS YAFFS2 exFAT ほとんどのアーティファクトはSQLiteデータベースやXMLファイルとして保存されます。Androidはカーネルレベルでアプリケーションを隔離し、各アプリに固有の識別子（UID）を割り当てて実行中のアプリを追跡します。\nAndroid アーキテクチャ # LinuxカーネルはAndroidの基盤を成し、スレッドや低レベルのメモリ管理など、Android Runtime（ART）で利用される基本機能をサポートします。 ハードウェア抽象化レイヤー（HAL）は、ハードウェア機能を上位のJava APIに公開する標準化されたインターフェースを提供します。これは、カメラやBluetoothなど各ハードウェアコンポーネントに固有のライブラリモジュールで構成され、APIがハードウェアにアクセスする際に対応するモジュールを読み込みます。 Android Runtime（ART）は、各アプリケーションを独自のプロセスとインスタンスで実行し、低メモリデバイス上で複数の仮想マシンを管理します。ARTは、Android向けに特別に設計・最適化されたDEXバイトコードを使用し、d8などのコンパイルツールでJavaコードをDEXバイトコードに変換して実行します。 ARTやHALなど、多くの重要なAndroidシステムコンポーネントやサービスは、CやC++で記述されたネイティブライブラリを必要とするネイティブコードで作成されています。 Androidの機能はJava APIを通じて利用でき、通知、リソース管理、ローカリゼーションなどの主要なシステムコンポーネントやサービスの再利用が促進されます。 システムアプリケーションは、Androidに標準搭載されているコアのアプリ群です。 Android 仮想マシン # 仮想マシン（VM）は、アプリケーションと基盤となるAndroidデバイスとの間の抽象化レイヤーとして機能します。 各アプリケーションは、VM内で独自のインスタンスとして実行され、他のアプリケーションから隔離されます。 AndroidアプリはJavaで記述され、Javaバイトコードにコンパイルされます。 このバイトコードはDalvikバイトコード（.dexファイル）またはARTバイトコードに変換されます。 DalvikとARTは仮想マシン内でバイトコード（.dex）を実行し、アプリが基盤ハードウェアに依存せずに動作できるようにします。 KitKat（v4.4）以前はAndroidはDalvik VMを使用していました。 Lollipop（v5.0）以降、AndroidはAndroid Runtime（ART）を使用し、Dalvik VMは段階的に廃止されました。 DalvikとARTはどちらもDEXバイトコードを使用しますが、ARTは新たな最適化機能を備えています。 ディレクトリ構造 # /cache: Gmailの添付ファイル、ダウンロード、閲覧データ、OTAアップデートなどが含まれる可能性があります。 /efs: 障害発生時にデバイスの動作に必要なファイルが格納されます。 /data: /data/data: アプリケーションフォルダ（例: /data/data/com.example.app）、アプリ設定ファイル、SQLiteデータベース、ログ、キャッシュなどが含まれます。 /app: Androidマーケットからの.apkファイルが格納されます。*マルウェアが存在する可能性があります。 /backup: 開発者向けバックアップAPIが保存されます。ユーザーバックアップデータはここに保存されません。 /media: SDカードに相当する内部ストレージ。*マルウェアが存在する可能性があります。 /misc: Bluetooth、DHCP、VPN、Wi-Fiなどに関連するファイルが格納されます。 /system: gesture.key や passwords.key、ファイル認証用のユーザー名やパスワードを保存する accounts.db など、重要なファイルが含まれます。 /property: タイムゾーン、言語設定など、システムプロパティが保存されます。 /mnt: /asec: 暗号化されていないアプリデータが保存されます。 /DCIM: アルバムのサムネイルが保存されます。 /Pictures: カメラ画像が保存されます。 /downloads: ローカルにダウンロードされたファイルが保存されます。 /secure/asec: 暗号化されたアプリデータが保存されます。 /system: /app: .apkファイルが含まれます。*マルウェアが存在する可能性があります。 /priv-app: システムレベルの権限を持つ.apkファイルが含まれます。*マルウェアが存在する可能性があります。 詳細情報:\nアプリの権限について: https://developer.android.com/guide/topics/permissions/overview?hl=en, https://blog.mindorks.com/what-are-the-different-protection-levels-in-android-permission/ Android CLI: https://developer.android.com/tools/adb?hl=en セットアップ # これらのファイルとシナリオを考慮し、Autopsyツールを使用します。セットアップには時間がかかる可能性があるため、ここから開始します。\nAutopsyに不慣れな方のために、簡単な説明を以下に示します:\nAutopsyはオープンソースのデジタル調査ツールです。Sleuth Kitやその他のフォレンジックツールのグラフィカルインターフェースとして機能し、ハードドライブやスマートフォンの解析に一般的に使用されます。主な機能として、削除ファイルの復元、メタデータ解析、キーワード検索、タイムラインの可視化、ファイルシステム解析などがあります。\n使用するには、「ケース」を作成する必要があります:\nここでは「ディスクイメージ」やVM、ローカルディスクではなく、「Logical Files」を選択します:\nAutopsyおよびそのモジュールがインジェストプロセスを完了するのを待ちます。これには時間がかかる場合があります。\n準備完了です。調査を開始しましょう:\n質問 # 質問 1 # エージェントが各種アプリケーション／サービスで使用しているメールアドレスは何ですか？\nこれに答えるため、AutopsyをALEAPP（Android Logs Events And Protobuf Parser）経由で実行したレポートを使用します。\n（ALEAPPは、フォレンジック解析のために既知のAndroidアーティファクトをすべて解析することを目的としたオープンソースプロジェクトです。）\n迅速かつ容易に見つけるために、以下を検索します:\n/data/data/com.android.vending/databases/library.db （アプリダウンロードに使用されたGoogleアカウントを確認するため） /data/data/com.android.providers.contacts/databases/contacts2.db （連絡先同期に使用されたGoogleアカウントを確認するため） さらに（このチャレンジには該当しません）:\n/data/com.android.vending/shared_prefs/lastaccount.xml （Android 9以降でGoogle PlayStoreで最後に使用されたアカウント） /data/com.google.android.gms/shared_prefs/BackupAccount.xml （バックアップアカウントのメールアドレス） /data/com.android.email/databases/EmailProvider.db （メールアカウント、サードパーティアプリのデータ、及びメール通知に関連するメッセージ） 最終的に、HTMLレポートが生成されます:\nメールアドレスは様々な場所で確認できます。\n例えば、「Chrome」アプリの「Autofill」（保存された情報でフォームを自動入力する機能）にて:\nまた、Chromeの「Login Data」でも:\nさらに、「Installed Apps (Library)」セクションには、アプリダウンロードに使用されたGoogleアカウントのメールアドレスが記載されています:\n回答: olegpachinksy@gmail.com\n質問 2 # 逮捕されたエージェントに割り当てられたハンドラーの連絡先番号は何ですか？\n「Contacts」セクションにて:\n回答: +323145232315\n質問 3 # Ravenskiエージェント用の認証情報と公式ポータルへのリンクを取得してください。\nこれにより、Ravenski政府が計画する今後の作戦に関する実行可能な情報を収集するためのインテリジェンス上の優位性が得られる可能性があります。\nこの質問の回答は、すでに質問1でChromeの「Login Data」により確認されています:\n回答: agent.ravensk.idu.com:olegpachinksy007:HBLKNKD0MADsdfsa2334(*\u0026amp;DSMDB\n質問 4 # 安全なチャットチャネルを使用する際、エージェントとハンドラーの身元確認に使用される連絡コードは何ですか？\nまず、以下でSMSメッセージの可能性を確認します:\n/data/data/com.android.providers.telephony/databases/mmssms.db\n何も見つかりませんでした。\nまた、以下も確認可能ですが、このチャレンジには該当しません:\n/data/com.google.android.gms/databases/icing_mmssms.db (SMS/MMS) /data/com.google.android.gms/databases/ipa_mmssms.db (SMS/MMS) 使用されているメッセージングアプリを特定するため、Autopsyの「Installed Programs」セクションで全てのインストール済みアプリを確認します:\n異なるカテゴリが表示されます:\nInstalled Apps (GMS) Installed Apps (Library) Installed Apps (Vending) Installed Apps - GMS:\nこのカテゴリは、インストール方法に関係なくデバイスにインストールされたアプリを指し、データは /data/com.google.android.gms/databases/ に保存されています。\nInstalled Apps - Library:\nこのカテゴリは、デバイス上のGoogleユーザー用のアプリライブラリを指し、同一Googleアカウントで別のデバイスや以前のインストールで入手されたアプリが含まれる場合があり、データは /data/com.android.vending/databases/ に保存されています。\nInstalled Apps - Vending:\nこのカテゴリは、Google Play Store経由でインストールされたアプリを指し、アプリがアンインストールされてもデータは保持され、/data/com.android.vending/databases/ に保存されています。\n明確にするため、ALEAPPに戻り、「Vending」タイプのアプリに焦点を当てます:\n目立つアプリは mega.privacy.android.app です。実際、これはメッセージングアプリケーションです:\nALEAPPは、MEGAを介して交換されたメッセージを解析しています:\nこの情報は、次の場所で確認できます:\n/data/data/mega.privacy.android.app/karere-TU1IaTh4TUJpdTQKAfO_2P0qU8NMP7zDRlgv.db\n回答: REDAPPLEONACAR\n質問 5 # ハンドラーはクラウドストレージサービスを使用してエージェントとドキュメントを共有しました。\nこのファイルはいつエージェントと共有されたのでしょうか？\nメッセージ内には何も見つかりませんでした。ドキュメントは別の方法で送信されたに違いありません。\n他のメッセージングアプリもなく、SMS/MMSで送信された可能性もありません。\nインストール済みアプリの中に com.google.android.apps.docs が見られたため、以下を確認します:\n\\data\\data\\com.google.android.apps.docs\nこの情報を含むデータベース\n/data/data/com.google.android.apps.docs/app_cello/olegpachinksy@gmail.com/cello.db が見つかります:\nまた、ファイルは次の場所にも存在します:\nEVIDENCE-CASE-RAVENSKIAN-AGENT-002/storage/emulated/0/Download/Debrief-Velorian OP Expansion East.pdf\n注意: Autopsyはデフォルトでコンピュータのタイムゾーンを使用してタイムスタンプを解釈します。Autopsyの設定（Tools \u0026gt; Options \u0026gt; View \u0026gt; Time Zone）でこの設定を調整することを忘れないでください。\n回答: 2024-04-01 09:36:41\n質問 6 # 先に特定された共有ファイルのダウンロードURIは何ですか？\nファイルは /storage/emulated/0/Download/ に存在しているため、ダウンロードされたことが分かります。\nしたがって、/data/data/com.android.providers.downloads/databases/downloads.db を検索します:\n回答: https://www.googleapis.com/drive/v2internal/files/1iQKKlBU2vuJD1Xet6IYPt7IODVtDHxv1?alt=media\u0026amp;source=downloadUrl\u0026amp;auditContext=fileAction\u0026amp;reason=909\u0026amp;syncType=1\u0026amp;featureLabel=android-sync-classic\u0026amp;openDrive=false\u0026amp;errorRecovery=false\u0026amp;originatorApp=102\n質問 7 # ヴェロリアの対スパイ活動に向けた追加情報収集のため、Ravenski政府主導のこのサイバー作戦の主要な目的は何でしたか？\nドキュメントに戻ると:\n回答: ヴェロリアのセキュアネットワークに侵入し、今後のサイバー攻撃、その手法、及び標的国に関する情報を収集する。\n質問 8 # この作戦の範囲を把握するため、ハンドラーの特定はヴェロリアの法執行機関にとっても極めて重要です。\nハンドラーのメールアドレスは何ですか？\nこれはすでにMEGAアプリのメッセージで確認されています:\n回答: ivoryalex783@gmail.com\n質問 9 # エージェントとハンドラーが出会った場所の名称は何ですか？\nメッセージに戻ると:\nこの質問は最も時間がかかり、約1時間を費やしました。\n最初は、以下の通常の場所を検索しました:\n/data/com.google.android.apps.maps/databases/gmm_storage.db /data/com.google.android.apps.maps/databases/search_history.db /data/com.google.android.apps.maps/databases/da_destination_history /data/com.sec.android.daemonapp/db/weatherClock /data/com.google.android.apps.maps/app_tts-cache/ /data/com.google.android.apps.maps/cache/image_manager_disk_cache/ 何も見つからなかったため、回答は電話内の画像メタデータにあるかもしれないと考えました。実際、48枚の画像があり、そのうち数枚にはバーが写っていました:\nしかし、決定的なものは見つかりませんでした。\n次に以下の点を検討しました:\n電話内に他のナビゲーション／位置情報アプリはあるか？ 確実にGoogle Mapsアプリを見るべきか？ いいえ、Google Mapsのみです。 いいえ、検索はブラウザで行われた可能性もあります。 一般的なGoogle Mapsのアーティファクトを確認後、ブラウザで検索しましたが何も見つかりませんでした。\nそのため、再度Google Mapsのアーティファクトの解析に戻りました:\napp: 関連するものはありませんでした app_offline_downloads: 関連するものはありませんでした app_offline_hashes: 関連するものはありませんでした app_textures: 関連するものはありませんでした app_webview: 関連するものはありませんでした cache: 関連するものはありませんでした databases: ファイルが多すぎるため、後で再検討します files: 「new_recent_history_cache_search.cs」 結局、「Pub」というキーワードで単純に検索すればよかったことが判明しました 🤡\n回答: Levstik Pub\n質問 10 # エージェントとハンドラー間のチャットによると、ハンドラーはRavenski政府がこのサイバー諜報作戦で使用しているインフラに関連する画像をエージェントに送信したようです。\nRavenski政府が使用しているC2フレームワークは何ですか？\n質問9のために全ての画像を確認済みであるため、回答は明らかです:\n回答: Empire\n質問 11 # IPアドレスやホスト名など、インフラに関する情報の収集は、ヴェロリア当局が反撃を準備する上で極めて重要です。\nハンドラーがエージェントに送信した画像に基づいて、Ravenskiの脅威アクターが運営するC2サーバーの1つのIPアドレスは何ですか？\n回答: 98.24.12.45\n","date":"19 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/posts/opshieldwall-2/","section":"Posts","summary":"シナリオ # 当局のWiFiネットワークを侵害した悪意ある攻撃者の所在を特定することに成功しました。","title":"OpShieldWall-2","type":"posts"},{"content":"","date":"7 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"","date":"7 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/tags/network-forensic/","section":"Tags","summary":"","title":"Network Forensic","type":"tags"},{"content":" シナリオ # お電話にご対応いただき、ありがとうございます。ヴェロリアン国防省は切実な支援を必要としています\u0026hellip;\nこの件は内密に扱う必要がありますが、ヴェロリアン国防省オフィス内のパブリックWiFiが侵害された疑いがあります。被害は最小限のようですが、ネットワーク図からは実質的なセグメンテーションが実施されておらず、デバイス間の直接通信が許可されていることが分かります。政府大臣はBYoD（Bring Your Own Device）機器とヴェロリアンMoDNetホストを用いてこのネットワークを利用しています。提供されたpcapファイルを解析し、どのように、またいつこの事象が発生したのかを確認してください。なお、本調査はTLP Amberに分類されています。\nファイル # opshieldwall1.zip （ネットワークキャプチャ「VELORIA-NETWORK.pcap」を含む） セットアップ # このチャレンジはシンプルなため、tshark / wireshark のみを用いて解析を行います。\n質問 # 質問 1 # 当社のWiFiネットワークのSSIDを確認してください。\nまず、キャプチャデータに慣れるため、以下のコマンドを使用して統計情報を収集します:\n$ tshark -r traffic.pcapng -qz -r はファイルの読み込みを許可するオプション -q は出力を抑制し、グローバルな統計情報のみを表示するためのオプション -z は統計情報の表示を有効にします 考えられる統計項目は多岐に渡ります（tshark -z help で確認可能）が、ここでは主に以下を把握したいです:\nパケット数 キャプチャ時間 パケット数の多いIPv4アドレス 通信量の多いIPv4エンドポイント 最も利用されたプロトコル パケット数とキャプチャ時間: 106; 31.6秒\n$ tshark -r VELORIA-NETWORK.pcap -qz io,stat,0 =================================== | IO Statistics | | | | Duration: 31.6 secs | | Interval: 31.6 secs | | | | Col 1: Frames and bytes | |---------------------------------| | |1 | | | Interval | Frames | Bytes | | |-------------------------------| | | 0.0 \u0026lt;\u0026gt; 31.6 | 106 | 20759 | | =================================== IPv4エンドポイント:\nパケット数が最も多いもの: $ tshark -r VELORIA-NETWORK.pcap -qz endpoints,ip ================================================================================ IPv4 Endpoints Filter:\u0026lt;No Filter\u0026gt; | Packets | | Bytes | | Tx Packets | | Tx Bytes | | Rx Packets | | Rx Bytes | 0.0.0.0 3 1044 3 1044 0 0 255.255.255.255 3 1044 0 0 3 1044 10.0.3.1 3 1048 3 1048 0 0 10.0.3.52 3 1048 0 0 3 1048 ================================================================================ 通信量が最も多いもの: tshark -r VELORIA-NETWORK.pcap -qz conv,ip ================================================================================ IPv4 Conversations Filter:\u0026lt;No Filter\u0026gt; | \u0026lt;- | | -\u0026gt; | | Total | Relative | Duration | | Frames Bytes | | Frames Bytes | | Frames Bytes | Start | | 0.0.0.0 \u0026lt;-\u0026gt; 255.255.255.255 0 0 bytes 3 1044 bytes 3 1044 bytes 23.256576000 8.3680 10.0.3.1 \u0026lt;-\u0026gt; 10.0.3.52 0 0 bytes 3 1048 bytes 3 1048 bytes 23.256959000 8.3693 ================================================================================ 最も使用されたプロトコル:\ntshark -r VELORIA-NETWORK.pcap -qz io,phs =================================================================== Protocol Hierarchy Statistics Filter: sll frames:106 bytes:20759 radiotap frames:92 bytes:17572 wlan_radio frames:92 bytes:17572 wlan frames:92 bytes:17572 wlan.mgt frames:92 bytes:17572 eapol frames:6 bytes:999 eap frames:6 bytes:999 ip frames:6 bytes:2092 udp frames:6 bytes:2092 dhcp frames:6 bytes:2092 arp frames:2 bytes:96 =================================================================== 回答するために、以下のコマンドを実行します:\n$ tshark -r VELORIA-NETWORK.pcap -T fields -e wlan.ssid | head -n 1 | xxd -r -p VELORIA-MoD-AP012 解説 : (https://www.wireshark.org/docs/dfref/w/wlan.html)\n-t はユーザー指定のフィールドのみを表示するため（従って -e オプションでフィールドを指定する必要があります） -e wlan.ssid は無線ネットワークのSSIDを抽出・表示するために指定 -xxd -r -p は出力を16進数から可読テキストに変換します 回答 : VELORIA-MoD-AP012\n質問 2 # AP（アクセスポイント）のMACアドレスを確認してください。\ntshark -r VELORIA-NETWORK.pcap -T fields -e wlan.sa | head -n 1 02:00:00:00:01:00 回答 : 02:00:00:00:01:00\n質問 3 # APの認証状態／認証方式と攻撃ベクトルを確認してください。\nWiresharkに切り替えます。\n回答 : WPS\n質問 4 # 攻撃が開始されたパケット番号は何ですか?\nキャプチャ内で唯一の接続試行である最初の試行から容易に推測できます。\n回答 : 93\n質問 5 # 攻撃が終了したパケット番号は何ですか?\n認証に失敗した時点で終了していることが明らかです。\n回答 : 8\n","date":"7 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/posts/opshieldwall-1/","section":"Posts","summary":"シナリオ # お電話にご対応いただき、ありがとうございます。ヴェロリアン国防省は切実な支援を必要としています\u0026hellip;","title":"OpShieldWall-1","type":"posts"},{"content":"画像はクリック可能なリンクです。\n進行中 修士課程 (BAC+5) - データ、ネットワーク、システムセキュリティの専門家\n職業訓練（ワークスタディプログラム）のみ対応\nhttps://www.francecompetences.fr/recherche/rncp/38951/ 学士課程 (BAC+3) - サイバーセキュリティ \u0026 倫理的ハッキング\n3年目は職業訓練プログラム\n成績優秀賞（フランスの「Très Bien」に相当する評価） 学士課程 (BAC+3) - 情報システム設計者\n成績優秀賞（フランスの「Très Bien」に相当する評価） これまでに完了したすべてのチャレンジ、ラボ、ボックスなど、および参加した会議やトレーニングのリストです\nHackTheBox # Iron = Insane Red = Hard Orange = Medium Green = Easy Purple = Very Easy 一部の画像は、HTBの結果ページにリンクしていません。これらはHackTheBox Enterpriseプラットフォームでのみ利用可能なボックスやシャーロックであり、共有リンクが許可されていません。\nシャーロック # DFIR / SOC # OpShieldWall-7 APTNightmare-2 Latus Heartbreaker Trent APTNightmare OpShieldWall-4 OpShieldWall-2 OpShieldWall-1 Jingle Bell Recollection Noted Tracer Log Jammer Rogue One CrownJewel-2 CrownJewel-1 Brutus マルウェア分析 # OpShieldWall-6 Loggy HB-Continuum クラウド # Nubilum-2 ボックス # Linux # OpShieldWall-5 OpShieldWall-3 Blurry Runner IClean Perfection BoardLight Headless Wifinetic MetaTwo Lame Nibbles Precious Windows # Jerry Netmon Blue HackTheBoxアカデミー # Transcript.pdf\nRootMe # CyberDefenders # 脅威ハンティング # Hard ネットワークフォレンジック # Hard Medium Medium Medium Medium Medium Easy Easy Easy Easy Easy Easy Easy Easy エンドポイント・フォレンジックス # Medium Easy 脅威インテリジェンス # Medium Medium Easy Easy Easy Easy クラウド・フォレンジックス # Easy TryHackMe # 92部屋を完了\nPath :\nPre Security Complete Beginner Web Fundamentals Comptia Pentest+ コース # OALABS : Reverse Engineering 101 (RE101) （リバースエンジニアリング101） Evasive Malware : A Field Guide to Detecting, Analyzing, and Defeating Advanced Threats (Kyle Cucci - no starch press) Kaspersky : Advanced Malware Analysis Techniques （高度なマルウェア分析技術） Kaspersky : Hunting APTs like a Ninja with YARA （YARAを使った忍者のようなAPT追跡） 13Cubed : Investigating Windows Endpoint 13Cubed : Investigating Windows Memory Roman Stuehler : Android App Hacking - Black Belt Edition （Androidアプリハッキング - ブラックベルト版） Pentherz : Intro to SDR Hacking （SDRハッキング入門） Christopher Negus : Linux Bible （リナックスバイブル） OSINT (Open Source Intelligence Techniques) : IntelTechniques （オープンソースインテリジェンステクニック） Opdisk : The Cyber Plumber\u0026rsquo;s Handbook （サイバープランバーのハンドブック） 会議とミートアップ # 2025 # THCON 2025 2024 # DEFCON Paris Meetups HTB France 2023 # Hexacon DEFCON Paris LeHack Meetups HTB France ","date":"6 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/posts/portfolio/","section":"Posts","summary":"画像はクリック可能なリンクです。","title":"Portfolio","type":"posts"},{"content":"これまでに実施したプロジェクトのリストです。\nセルフホスト型インフラストラクチャ # 2023年6月 - 現在\nProxmoxを使用したプロフェッショナルサーバー (HP ProLiant DL380 Gen9 2U) OPNsenseで稼働するファイアウォール セルフホストされたサービスとツール: VPN、Security Onion、Wazuh、Cuckoo Sandbox、GitLab、CTFマシン、様々なラボ (レッドチーム / ブルーチーム) セキュリティ、プライバシー、OPSECを考慮した特別なマルウェア解析ラボとOSINTラボ アーキテクチャ設計、ネットワーク分割、IPS/IDS統合、負荷分散、SRE、VPN CTFチャレンジクリエーター # 2024年6月 - 2024年6月\n「PwnMe CTF 2024」のために2つの無線通信チャレンジ (簡単なものと中程度の難易度) を作成しました。\nhttps://ctftime.org/ctf/807/\nhttps://www.phreaks2600.fr/\nサイドクエスト - ネットワークフォレンジック＆マルウェア解析ツールキット # 2024年2月 - 2024年6月\nサイドクエストは、ネットワークフォレンジック解析とマルウェア解析に強力なツールキットを提供することを目的とした学生の共同プロジェクトです。このリポジトリには、調査の異なる側面に焦点を当てた2つのサブプロジェクトが含まれています：\nネットワークフォレンジック解析: PCAPファイル内のネットワークトラフィックを解析するためのツール。 マルウェア解析: バイナリファイルを解析し、隠された情報を見つけ、悪意のある特徴を検出するためのツール。 https://github.com/jaybird1291/toolkit-network-forensic-malware-analysis-sidequest\n","date":"5 5月 2024","externalUrl":null,"permalink":"/blog-cyber/ja/posts/projets/","section":"Posts","summary":"これまでに実施したプロジェクトのリストです。","title":"Projets","type":"posts"},{"content":"google-site-verification: googledd33d08d34e9aada.html","externalUrl":null,"permalink":"/blog-cyber/googledd33d08d34e9aada/","section":"Jaybird1291","summary":"google-site-verification: googledd33d08d34e9aada.","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/ja/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/ja/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/ja/series/","section":"Series","summary":"","title":"Series","type":"series"}]