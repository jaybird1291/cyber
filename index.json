[{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/tags/cve-2025-43200/","section":"Tags","summary":"","title":"CVE-2025-43200","type":"tags"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/tags/graphite/","section":"Tags","summary":"","title":"Graphite","type":"tags"},{"content":" âš ï¸ Attention :\nJe suis un Ã©tudiant en cybersÃ©curitÃ©. Ce post est personnel et non-professionnel. Mon analyse peut contenir des erreurs ou des imprÃ©cisions, je suis encore en apprentissage. Si vous constatez des erreurs ou si vous avez des suggestions, n\u0026rsquo;hÃ©sitez pas Ã  me contacter !\n1. Citizen Lab rÃ©vÃ¨le l\u0026rsquo;affaire # Le 12 juin 2025, Citizen Lab publie le rapport Â« First Forensic Confirmation of Paragon\u0026rsquo;s iOS Mercenary Spyware Â».\nLe rapport associe le spyware Graphite de Paragon Ã  une attaque zero-click iMessage ciblant plusieurs journalistes europÃ©ens.\nFaits principaux :\nUn victime a reÃ§u une threat notif d\u0026rsquo;Apple en avril 2025. Vecteur d\u0026rsquo;attaque : utilisation d\u0026rsquo;une attaque sophistiquÃ©e zero-click via iMessage. Tout Ã§a se termine le 11 juin 2025 (UTC), date Ã  laquelle Apple publie iOS 18.3.1 avec la CVE-2025-43200 pour la correction.\n2. CVE-2025-43200 \u0026amp; Avis succinct d\u0026rsquo;Apple # La note de sÃ©curitÃ© d\u0026rsquo;Apple pour iOS 18.3.1 indique :\nImpact : Un problÃ¨me logique existait lors du traitement d\u0026rsquo;une photo ou d\u0026rsquo;une vidÃ©o malicieusement conÃ§ue partagÃ©e via un lien iCloud. Apple est au courant d\u0026rsquo;un rapport selon lequel ce problÃ¨me aurait Ã©tÃ© exploitÃ© dans une attaque extrÃªmement sophistiquÃ©e contre des individus ciblÃ©s.\nDescription : Ce problÃ¨me a Ã©tÃ© rÃ©solu par une vÃ©rification amÃ©liorÃ©e.\nCVE-2025-43200 - Apple.\nAucun chemin de fichier ni indication du binaire modifiÃ©. C\u0026rsquo;est lÃ  que le patch diffing entre en jeu !\n3. Checker le blacktop/ipsw-diffs entre 18.3 (22D63) et 18.3.1 (22D72) # Le diff automatisÃ© de Blacktop montre 10 Mach-Os modifiÃ©s, dont trois seulement liÃ©s Ã  Messages :\niMessage (System/Library/Messages/PlugIns/iMessage.imservice/iMessage) SafetyMonitor (System/Library/Messages/iMessageApps/SafetyMonitorMessages.bundle/SafetyMonitorMessages) identityservicesd (System/Library/PrivateFrameworks/IDS.framework/identityservicesd.app/identityservicesd) Binaire Pourquoi ce choix ? AperÃ§u du diff iMessage.imservice Logique iMessage, dÃ©sÃ©rialisation rÃ©seau et renvois Important : nouvelle chaÃ®ne de log + vÃ©rification anticipÃ©e SafetyMonitorMessages Pop-ups de sÃ©curitÃ© de communication Aucun delta fonctionnel vu avec le diffing tool identityservicesd Daemon IDS/Push acheminant le trafic vers Messages Aucun delta fonctionnel vu avec le diffing tool 4. Analyse de 18.3 (22D63) et 18.3.1 (22D72) # Depuis iOS 18, Apple a ajoutÃ© les dmg.aea, rendant l\u0026rsquo;analyse diffÃ©rent si comme moi vous Ã©tiez habituÃ© au dmg basique. Voici un micro-guide (si vous Ãªtes uniquement intÃ©ressÃ© Ã  l\u0026rsquo;analyse technique passÃ© Ã  la partie 5.).\nTÃ©lÃ©chargement des deux versions d\u0026rsquo;iOS ipsw download ipsw --device iPhone17,1 --build 22D63 ipsw download ipsw --device iPhone17,1 --build 22D72 Extraction du filesystem ipsw extract --dmg fs iPhone17,1_18.3_22D63_Restore.ipsw ipsw extract --dmg fs iPhone17,1_18.3.1_22D72_Restore.ipsw Extraction de la fcs-key et du dmg ipsw extract --fcs-key iPhone17,1_18.3_22D63_Restore.ipsw ipsw fw aea --pem \u0026#39;044-59182-075.dmg.aea.pem\u0026#39; \u0026#39;044-59515-074.dmg.aea\u0026#39; --output extracted/ # do this for the other one too Montage ipsw mount fs --pem-db extracted/fcs-keys.json ../iPhone17,1_18.3_22D63_Restore.ipsw If like me this doesn\u0026rsquo;t work for any reasons:\nsudo apfs-fuse -o allow_other,uid=1001,gid=1001 extracted/044-59515-074.dmg /mnt/ios_old Copie des fichiers nÃ©cessaires cp System/Library/PrivateFrameworks/IDS.framework/identityservicesd.app/identityservicesd ~/Documents/CVE-2025-43200/18.3.1/ cp System/Library/Messages/PlugIns/iMessage.imservice/iMessage ~/Documents/CVE-2025-43200/18.3.1/ cp System/Library/Messages/iMessageApps/SafetyMonitorMessages.bundle/SafetyMonitorMessages ~/Documents/CVE-2025-43200/18.3.1/ 5. DiffÃ©rences dans iMessage.imservice entre 18.3 (22D63) et 18.3.1 (22D72) # PremiÃ¨rement voici la similaritÃ© :\nradiff2 -s 18.3/iMessage 18.3.1/iMessage similarity: 0.977 distance: 49654 Ensuite nous pouvons creuser plus profondÃ©ment avec IDA Pro et Diaphora script :\nNous pouvons voir un \u0026ldquo;partial match\u0026rdquo; pour-[MessageServiceSession _reAttemptMessageDeliveryForGUID: â€¦].\nAvec un nouveau log \u0026quot;Being requested to re-send a message that wasn't sent by me\u0026quot;.\nEn utilisant la Graph view nous pouvons clairement voir la nouvelle vÃ©rification :\nVoici les deux changements importants :\nUne nouvelle vÃ©rification de l\u0026rsquo;auteur qui empÃªche la primitive de rÃ©flexion // APRÃˆS 18.3.1 - Bloque le renvoi des messages Ã©trangers. if (![message isFromMe]) { // message authored by someone else os_log_info(MessageServiceLog, \u0026#34;Being requested to re-send a message that wasn\u0026#39;t sent by me\u0026#34;); return; // bail = exploit dies } Pourquoi ? - On peut supposer que la chaÃ®ne zÃ©ro-clic de Paragon a crÃ©Ã© une trame de contrÃ´le \u0026ldquo;renvoi\u0026rdquo; pointant vers une GUID dans la DB de discussion de la victime (oÃ¹ is_from_me == 0). La protection unique ci-dessus rejette cette requÃªte.\nNous pouvons voir ces informations dans la SMS.db:\nTest de age-limit, plus de tentatives pour les messages obsolÃ¨tes // AVANT 18.3 - on n\u0026#39;interrompait le renvoi que si le message Ã©tait encore rÃ©cent (logique inversÃ©e) if (timeSinceDelivered \u0026lt;= [self _messageRetryTimeout]) { // !v37 â€¦ proceed toward retry â€¦ } // AFTER 18.3.1 â€“ interruption immÃ©diate si le message est trop ancien if (timeSinceDelivered \u0026gt; [self _messageRetryTimeout]) { // v37 os_log_info(MessageServiceLog, \u0026#34;Message %@ originally delivered at %@ is too old to retry.\u0026#34;, guid, deliveredDate); return; // no resend } Pourquoi ? - Apple a restreint la fenÃªtre de renvoi pour empÃªcher les attaquants de relancer indÃ©finiment le mÃªme GUID plusieurs mois aprÃ¨s.\nMise en perspective:\nVÃ©rification de l\u0026rsquo;auteur corrige le bug logique central exploitÃ© par CVE-2025-43200. Test d\u0026rsquo;anciennetÃ© renforcÃ© rÃ©duit la fenÃªtre de rejouabilitÃ© (dÃ©fense en profondeur). CVE-2025-43200 est un correctif logique d\u0026rsquo;une seule ligne:\n\u0026ldquo;Ne renvoie que les messages que tu as rÃ©ellement Ã©crits.\u0026rdquo;\nL\u0026rsquo;exploit a fonctionnÃ© car cette invariant Ã©vidente n\u0026rsquo;Ã©tait jamais appliquÃ©e dans l\u0026rsquo;helper de renvoi. Le correctif d\u0026rsquo;Apple se compose de :\nif (!msg.isFromMe) return; Une instruction os_log pour le triage / log. 18.3 (vulnerable) 18.3.1 (patched) â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â€¦ look-ups â€¦ â”‚ â”‚ â€¦ same â€¦ â”‚ â”‚ age-limit check â”‚ â”‚ age-limit check (unchanged) â”‚ â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚ â”‚ NO author check â”‚ â”‚ if (!message.isFromMe) { â”‚ â—„â”€ NEW â”‚ retry logic â”‚ â”‚ log \u0026#34;...not sent by me...\u0026#34; | â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ return; â”‚ â”‚ } â”‚ â”‚ retry logic (unchanged) â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ 6. Comment cela se traduit dans la CVE-2025-43200 # L\u0026rsquo;attaquant :\nInjectait ou rejouait une requÃªte iMessage \u0026ldquo;renvoi\u0026rdquo; spÃ©cialement conÃ§ue pointant vers un GUID existant dans la base de donnÃ©es SQLite locale de la victime. Comme iOS 18.3 ne vÃ©rifiait pas isFromMe, la mÃ©thode _reAttemptMessageDeliveryForGUID:â€¦ consommait un crÃ©dit de renvoi et rÃ©expÃ©diait le message Ã©tranger (ou sa piÃ¨ce jointe) vers le contact contrÃ´lÃ© par l\u0026rsquo;attaquant. Le correctif d\u0026rsquo;iOS 18.3.1 comble cette faille en exigeant que le bit isFromMe du GUID soit vrai. Le message doit impÃ©rativement provenir de l\u0026rsquo;utilisateur local ; toute requÃªte falsifiÃ©e rÃ©fÃ©rant Ã  un message tiers dÃ©clenche dÃ©sormais la nouvelle entrÃ©e de log et interrompt immÃ©diatement le processus.\n7. Vecteur d\u0026rsquo;attaque â€“ reconstruction plausible # Ã€ ce jour, je n\u0026rsquo;ai pas identifiÃ© de scÃ©nario complet et convaincant montrant comment la CVE-2025-43200 s\u0026rsquo;insÃ¨re exactement dans les cas documentÃ©s par Citizen Lab. Si vous avez d\u0026rsquo;autres idÃ©es ou des artefacts que j\u0026rsquo;aurais pu manquer, n\u0026rsquo;hÃ©sitez pas Ã  me contacter.\nMon premier scÃ©nario envisageait que ce bug fournisse un canal d\u0026rsquo;exfiltration furtif. Ã€ y regarder de plus prÃ¨s, cela paraÃ®t peu probable : la primitive de renvoi ne peut transmettre que des piÃ¨ces jointes dÃ©jÃ  prÃ©sentes dans la sandbox de Messages. Elle ne permettrait pas, Ã  elle seule, d\u0026rsquo;extraire des donnÃ©es arbitraires (bases Signal, WhatsApp, etc.).\n8. Forensique # Ã‰tant donnÃ© que je n\u0026rsquo;ai pas accÃ¨s aux donnÃ©es des iPhone compromis par Citizen Lab, tout ce qui suit est purement hypothÃ©tique ou fondÃ© sur des dÃ©ductions logiques.\n1. RequÃªtes de logs unifiÃ©s dÃ©voilant lâ€™activitÃ© CVE-2025-43200 :\nÃ€ rechercher Pourquoi câ€™est important \u0026quot;re-send a message that wasn't sent by me\u0026quot; Nouvelle chaÃ®ne os_log introduite uniquement Ã  partir dâ€™iOS 18.3.1â€‰; sa prÃ©sence indique que lâ€™appareil a bloquÃ© une tentative de renvoi falsifiÃ©e. stack traces _reAttemptMessageDeliveryForGUID (prÃ©-patch) Sur les appareils vulnÃ©rables (18.3/18.2.1), vous pouvez toujours trouver dans les logs de crash des rÃ©fÃ©rences Ã  ce sÃ©lecteur si lâ€™exploit Ã©choue. Attention : les logs unifiÃ©s rotate au bout dâ€™environ 7 jours sur lâ€™appareil ; pensez Ã  extraire un sysdiagnose complet immÃ©diatement.\n2. Artefacts dans la base de chat (sms.db)\n/* Possible reflection duplicates: same GUID appears as both inbound (is_from_me = 0) and outbound (is_from_me = 1) within a short window */ SELECT guid, date, is_from_me, text FROM message WHERE guid IN ( SELECT guid FROM message WHERE is_from_me = 0 ) ORDER BY date ASC; Un GUID dupliquÃ© passant de is_from_me = 0 âœ 1 sans action de lâ€™utilisateur suggÃ¨re fortement un abus du mÃ©canisme de renvoi. Recouper ce GUID avec la table attachments. 3. Traces IDS \u0026amp; livraison de messages :\nEmplacement (dump rootÃ© ou systÃ¨me de fichiers complet iOS) : /private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/ids.* Rechercher dans les logs avec grep : \u0026quot;resend-request\u0026quot; valeurs de \u0026quot;guid\u0026quot; apparaissant Ã©galement dans les doublons de sms.db \u0026quot;handleID\u0026quot; correspondant Ã  des numÃ©ros/email inconnus Ces trames de contrÃ´le IDS en clair survivent souvent dans les logs de diagnostic mÃªme lorsque les logs unifiÃ©s ont Ã©tÃ© archivÃ©s.\n","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/posts/graphite-caught/","section":"Posts","summary":"âš ï¸ Attention :","title":"Graphite Paragon's zero-click iMessage bug et comment Apple l'a patchÃ©","type":"posts"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/tags/ios/","section":"Tags","summary":"","title":"IOS","type":"tags"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/","section":"Jaybird1291","summary":"","title":"Jaybird1291","type":"page"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/tags/paragon/","section":"Tags","summary":"","title":"Paragon","type":"tags"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/tags/patch-diffing/","section":"Tags","summary":"","title":"Patch-Diffing","type":"tags"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"8 juillet 2025","externalUrl":null,"permalink":"/blog-cyber/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/hackthebox/","section":"Tags","summary":"","title":"HackTheBox","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/hard/","section":"Tags","summary":"","title":"Hard","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/sherlock/","section":"Tags","summary":"","title":"Sherlock","type":"tags"},{"content":" ScÃ©nario # Simon Stark est un dÃ©veloppeur chez forela qui a rÃ©cemment prÃ©vu de diffuser des sessions de programmation avec ses collÃ¨gues, ce qui lui a valu l\u0026rsquo;apprÃ©ciation du PDG et d\u0026rsquo;autres collÃ¨gues. Il a installÃ© sans le savoir un logiciel de streaming bien connu qu\u0026rsquo;il a trouvÃ© par le biais d\u0026rsquo;une recherche sur Google et qui Ã©tait l\u0026rsquo;une des principales URL promues par les publicitÃ©s de Google. Malheureusement, les choses ont mal tournÃ© et un incident de sÃ©curitÃ© s\u0026rsquo;est produit. Analysez les artefacts triÃ©s fournis pour dÃ©couvrir ce qui s\u0026rsquo;est passÃ© exactement.\nAttack Flow Diagram - SchÃ©ma global # Pour un rapide overview du challenge voici l\u0026rsquo;attack flow diagram que j\u0026rsquo;ai rÃ©alisÃ©, si vous ne voulez pas vous spoil vous pouvez le sauter :\nSetup # Pour ce Sherlock nous allons utiliser :\nEric Zimmerman\u0026rsquo;s Tools (Registry Explorer, EvtxECmd, MFTECmd TimeLine Explorer, PECmd\u0026hellip;) HxD Hex Editor strings Pour nous aider on va aussi s\u0026rsquo;appuyer sur des Cheatsheets tels que :\nhttps://cdn.13cubed.com/downloads/windows_event_log_cheat_sheet.pdf https://cdn.13cubed.com/downloads/windows_registry_cheat_sheet.pdf https://cdn.13cubed.com/downloads/anatomy_of_an_ntfs_file_record.pdf Question 1 # Quel est le nom original du fichier zip malveillant que l\u0026rsquo;utilisateur a tÃ©lÃ©chargÃ© en pensant qu\u0026rsquo;il s\u0026rsquo;agissait d\u0026rsquo;une copie lÃ©gitime du logiciel ?\nPour rÃ©pondre Ã  cette question nous allons chercher dans la hive utilisateur NTUSER.DAT. En effet, c\u0026rsquo;est ici que sont enregistrÃ©es, dans la clÃ© RecentDocs, les fichiers rÃ©cemment ouverts par lâ€™utilisateur.\nRÃ©ponse : OBS-Studio-28.1.2-Full-Installer-x64.zip\nQuestion 2 # Simon Stark a renommÃ© le fichier zip tÃ©lÃ©chargÃ© en un autre nom. Quel est le nom renommÃ© du fichier ainsi que le chemin d\u0026rsquo;accÃ¨s complet ?\nPour rÃ©pondre Ã  cette question, il faut dâ€™abord comprendre que toute opÃ©ration de renommage sous NTFS (le filesystem de Windows) gÃ©nÃ¨re une modification du $FILE_NAME (attribut 0x30) dans la MFT.\nOn utilise donc MFTECmd pour parser la $MFT :\nMFTECmd.exe -f \u0026#34;C:\\$MFT\u0026#34; --csv \u0026#34;C:\\Temp\\Out\u0026#34; Puis on l\u0026rsquo;importe dans Timeline Explorer :\nRÃ©ponse : C:\\Users\\Simon.stark\\Documents\\Streaming Software\\Obs Streaming Software.zip\nQuestion 3 # Quelle est l\u0026rsquo;heure Ã  laquelle le fichier a Ã©tÃ© renommÃ© ?\nToujours au mÃªme endroit :\nRÃ©ponse : 2023-05-05 10:22:23\nQuestion 4 # Quelle est l\u0026rsquo;URL complÃ¨te Ã  partir de laquelle le logiciel a Ã©tÃ© tÃ©lÃ©chargÃ© ?\nToujours au mÃªme endroit :\nLe fait de tÃ©lÃ©charger un fichier sous Windows (via un navigateur comme Edge ou Internet Explorer) crÃ©e automatiquement, sur le NTFS, un flux de donnÃ©es auxiliaire nommÃ© Zone.Identifier.\nCe flux ADS (â€œAlternate Data Streamâ€) est stockÃ© avec le fichier lui-mÃªme et contient notamment :\nZoneId : la zone de sÃ©curitÃ© (3 = internet) ReferrerUrl : lâ€™URL de la page qui a lancÃ© le tÃ©lÃ©chargement HostUrl : lâ€™URL exacte du fichier tÃ©lÃ©chargÃ© RÃ©ponse : http://obsproicet.net/download/v28_23/OBS-Studio-28.1.2-Full-Installer-x64.zip\nQuestion 5 # Approfondissez vos recherches et trouvez l\u0026rsquo;adresse IP sur laquelle le domaine malveillant Ã©tait hÃ©bergÃ©.\nIci trÃ¨s simple, on parse avec EvtxECmd les event logs et on cherche le nom de domaine :\nEvtxECmd.exe -d \u0026#39;C:\\Windows\\System32\\winevt\\Logs\\\u0026#39; --csv \u0026#39;C:\\Temp\\out\u0026#39; RÃ©ponse : 13.232.96.186\nQuestion 6 # Plusieurs ports sources sont connectÃ©s pour communiquer et tÃ©lÃ©charger le fichier malveillant Ã  partir du site web malveillant. RÃ©pondez au numÃ©ro de port source le plus Ã©levÃ© Ã  partir duquel la machine s\u0026rsquo;est connectÃ©e au site web malveillant.\nSur Windows si le pare-feu est configurÃ© pour loggÃ© les connexions, il va enregistrer chaque tentative dâ€™accÃ¨s, non pas sous forme de nom de domaine, mais sous la forme de lâ€™IP cible.\nLe fichier pfirewall.log (C:\\Windows\\System32\\LogFiles\\Firewall) enregistre, pour chaque paquet examinÃ© :\nla date et lâ€™heure, lâ€™action (par exemple â€œALLOWâ€ ou â€œDROPâ€), le protocole (TCP/UDP), lâ€™adresse IP source, lâ€™adresse IP de destination, les ports source et destination etc. Ici seulement 6 connexions Ã  cette IP donc pas la peine de s\u0026rsquo;embÃªter, on peut le trouver manuellement en 5 secondes :\nRÃ©ponse : 50045\nQuestion 7 # Le fichier zip contenait un fichier d\u0026rsquo;installation malveillant qui installait un logiciel malveillant et une instance lÃ©gitime du logiciel OBS studio, de sorte que l\u0026rsquo;utilisateur n\u0026rsquo;avait aucune idÃ©e qu\u0026rsquo;il avait Ã©tÃ© compromis. Trouvez le hachage du fichier d\u0026rsquo;installation.\nPour rÃ©pondre Ã  cette question on va chercher du cÃ´tÃ© de la hive Amcache. Elle recense tous les exÃ©cutables lorsquâ€™ils sont lancÃ©s, installÃ©s, copiÃ©s, etc. Elle stocke pour chaque application plusieurs metadata : chemin complet, date dâ€™apparition, et notamment le hash SHA1 du binaire.\nConcrÃ¨tement, au moment oÃ¹ lâ€™utilisateur a extrait le zip et que le setup malveillant a Ã©tÃ© exÃ©cutÃ© (ou mÃªme simplement ouvert en soit), Windows a ajoutÃ© une entrÃ©e dans la clÃ© :\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AppModel\\InventoryApplicationFile (correspondant Ã  Amcache\\InventoryApplicationFile dans le hive Amcache.hve)\nSi nous avions eu une copie du disque complÃ¨te, on aurait pu calculer le hash Ã  la volÃ©e pour aller plus rapidement. NÃ©anmoins, c\u0026rsquo;est une mauvaise idÃ©e.\nContrairement au simple hash calculÃ© Ã  la volÃ©e, Amcache enregistre le SHA1 dÃ¨s la premiÃ¨re exÃ©cution ou extraction dans le systÃ¨me local, indÃ©pendamment de toute modification ultÃ©rieure (Ã  moins que lâ€™entrÃ©e Amcache soit explicitement Ã©ditÃ© / supprimÃ©).\nMÃªme si lâ€™utilisateur a effacÃ© le zip ou renommÃ© le setup, Amcache conserve cette ancienne trace tant que le fichier nâ€™est pas rÃ©installÃ© ou que lâ€™entrÃ©e nâ€™est pas nettoyÃ©e.\nRÃ©ponse : 35e3582a9ed14f8a4bb81fd6aca3f0009c78a3a1\nQuestion 8 # Le logiciel malveillant a installÃ© automatiquement une porte dÃ©robÃ©e sur le poste de travail de la victime. Quels sont le nom et le chemin d\u0026rsquo;accÃ¨s au fichier de la porte dÃ©robÃ©e ?\nRetournons Ã  la $MFT car elle enregistre chaque crÃ©ation et exÃ©cution de fichier.\nPour procÃ©der j\u0026rsquo;ai simplement chercher un lien temporel avec l\u0026rsquo;exÃ©cution du setup malveillant :\nje savais quâ€™Ã  lâ€™instant T0 (2023-05-05 10:23:14), lâ€™utilisateur a lancÃ© le setup malveillant quelques secondes plus tard (T0 + quelques secondes) apparaÃ®t dans la chronologie une nouvelle entrÃ©e : C:\\Program Files\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe comme il nâ€™existait pas avant (aucune entrÃ©e antÃ©rieure dans le $MFT pour ce chemin), on en dÃ©duit que câ€™est ce fichier quâ€™a crÃ©Ã© le setup malveillant. RÃ©ponse : C:\\Users\\Simon.stark\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe\nQuestion 9 # Trouver le \u0026ldquo;prefetch hash\u0026rdquo; de la backdoor.\nLorsque qu\u0026rsquo;on exÃ©cute un programme sous Windows, le systÃ¨me enregistre un fichier .pf (prefetch) dans C:\\Windows\\Prefetch dont le nom combine :\nLe nom de lâ€™exÃ©cutable (LAT TAKEWODEâ€¦.exe) Un hash calculÃ© Ã  partir de son chemin complet sur le disque Ce hash nâ€™est pas alÃ©atoire, Windows le gÃ©nÃ¨re pour distinguer plusieurs instances du mÃªme exÃ©cutable si elles rÃ©sident Ã  des chemins diffÃ©rents.\n.\\PECmd.exe -d \u0026#39;C:\\Windows\\prefetch\u0026#39; --csv \u0026#39;C:\\Temp\\Out\u0026#39; RÃ©ponse : D8A6D943\nQuestion 10 # La backdoor est Ã©galement utilisÃ©e comme mÃ©canisme de persistance de maniÃ¨re furtive pour se fondre dans l\u0026rsquo;environnement. Quel est le nom utilisÃ© pour le mÃ©canisme de persistance afin qu\u0026rsquo;il ait l\u0026rsquo;air lÃ©gal ?\nLes mÃ©canismes de persistance les plus couramment mis en oeuvre sont :\nClÃ©s de registre Run / RunOnce Service Windows TÃ¢ches planifiÃ©es Dossier de dÃ©marrage (dossier Startup) etc. Ici, il repose sur la crÃ©ation dâ€™une tÃ¢che planifiÃ©e dont le nom imite un processus systÃ¨me COMSurrogate. Quand Windows crÃ©e ou modifie une tÃ¢che planifiÃ©e, un Ã©vÃ©nement ID 4698 (â€œA scheduled task was createdâ€) est enregistrÃ© dans le journal de sÃ©curitÃ© (Security.evtx).\n.\\EvtxECmd.exe -d \u0026#39;C:\\Windows\\System32\\winevt\\Logs\\\u0026#39; --csv \u0026#39;C:\\Temp\\Out\\\u0026#39; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-16\u0026#34;?\u0026gt; \u0026lt;Task version=\u0026#34;1.2\u0026#34; xmlns=\u0026#34;http://schemas.microsoft.com/windows/2004/02/mit/task\u0026#34;\u0026gt; \u0026lt;RegistrationInfo\u0026gt; \u0026lt;Date\u0026gt;2023-05-05T15:23:21\u0026lt;/Date\u0026gt; \u0026lt;Author\u0026gt;FORELA\\simon.stark\u0026lt;/Author\u0026gt; \u0026lt;URI\u0026gt;\\COMSurrogate\u0026lt;/URI\u0026gt; \u0026lt;/RegistrationInfo\u0026gt; \u0026lt;Triggers\u0026gt; \u0026lt;LogonTrigger\u0026gt; \u0026lt;StartBoundary\u0026gt;2023-05-05T15:23:00\u0026lt;/StartBoundary\u0026gt; \u0026lt;Enabled\u0026gt;true\u0026lt;/Enabled\u0026gt; \u0026lt;/LogonTrigger\u0026gt; \u0026lt;/Triggers\u0026gt; \u0026lt;Principals\u0026gt; \u0026lt;Principal id=\u0026#34;Author\u0026#34;\u0026gt; \u0026lt;RunLevel\u0026gt;HighestAvailable\u0026lt;/RunLevel\u0026gt; \u0026lt;UserId\u0026gt;FORELA\\simon.stark\u0026lt;/UserId\u0026gt; \u0026lt;LogonType\u0026gt;InteractiveToken\u0026lt;/LogonType\u0026gt; \u0026lt;/Principal\u0026gt; \u0026lt;/Principals\u0026gt; \u0026lt;Settings\u0026gt; \u0026lt;MultipleInstancesPolicy\u0026gt;IgnoreNew\u0026lt;/MultipleInstancesPolicy\u0026gt; \u0026lt;DisallowStartIfOnBatteries\u0026gt;true\u0026lt;/DisallowStartIfOnBatteries\u0026gt; \u0026lt;StopIfGoingOnBatteries\u0026gt;true\u0026lt;/StopIfGoingOnBatteries\u0026gt; \u0026lt;AllowHardTerminate\u0026gt;true\u0026lt;/AllowHardTerminate\u0026gt; \u0026lt;StartWhenAvailable\u0026gt;false\u0026lt;/StartWhenAvailable\u0026gt; \u0026lt;RunOnlyIfNetworkAvailable\u0026gt;false\u0026lt;/RunOnlyIfNetworkAvailable\u0026gt; \u0026lt;IdleSettings\u0026gt; \u0026lt;Duration\u0026gt;PT10M\u0026lt;/Duration\u0026gt; \u0026lt;WaitTimeout\u0026gt;PT1H\u0026lt;/WaitTimeout\u0026gt; \u0026lt;StopOnIdleEnd\u0026gt;true\u0026lt;/StopOnIdleEnd\u0026gt; \u0026lt;RestartOnIdle\u0026gt;false\u0026lt;/RestartOnIdle\u0026gt; \u0026lt;/IdleSettings\u0026gt; \u0026lt;AllowStartOnDemand\u0026gt;true\u0026lt;/AllowStartOnDemand\u0026gt; \u0026lt;Enabled\u0026gt;true\u0026lt;/Enabled\u0026gt; \u0026lt;Hidden\u0026gt;false\u0026lt;/Hidden\u0026gt; \u0026lt;RunOnlyIfIdle\u0026gt;false\u0026lt;/RunOnlyIfIdle\u0026gt; \u0026lt;WakeToRun\u0026gt;false\u0026lt;/WakeToRun\u0026gt; \u0026lt;ExecutionTimeLimit\u0026gt;PT72H\u0026lt;/ExecutionTimeLimit\u0026gt; \u0026lt;Priority\u0026gt;7\u0026lt;/Priority\u0026gt; \u0026lt;/Settings\u0026gt; \u0026lt;Actions Context=\u0026#34;Author\u0026#34;\u0026gt; \u0026lt;Exec\u0026gt; \u0026lt;Command\u0026gt;C:\\Users\\Simon.stark\\Miloyeki\u0026lt;/Command\u0026gt; \u0026lt;Arguments\u0026gt;ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe\u0026lt;/Arguments\u0026gt; \u0026lt;/Exec\u0026gt; \u0026lt;/Actions\u0026gt; \u0026lt;/Task\u0026gt; RÃ©ponse : COMSurrogate\nQuestion 11 # Quel est le domaine erronÃ©/invalide nommÃ© de maniÃ¨re alÃ©atoire que le logiciel malveillant a tentÃ© d\u0026rsquo;atteindre ?\nPuisque la tÃ¢che planifiÃ©e a Ã©tÃ© crÃ©Ã©e Ã  10:23:21, on se place autour de cet horaire dans le channel Microsoft-Windows-DNS-Client/Operational pour repÃ©rer le domaine \u0026ldquo;invalide\u0026rdquo; que le malware a tentÃ© de rÃ©soudre.\nRÃ©ponse : oaueeewy3pdy31g3kpqorpc4e.qopgwwytep\nQuestion 12 # Le logiciel malveillant a essayÃ© d\u0026rsquo;exfiltrer les donnÃ©es vers un seau s3. Quelle est l\u0026rsquo;url du seau s3 ?\nIdem mais on filtre avec \u0026ldquo;s3\u0026rdquo; :\nRÃ©ponse : bbuseruploads.s3.amazonaws.com\nQuestion 13 # Sur quel sujet Simon allait-il faire un stream en semaine 1 ? Trouvez une note ou quelque chose de similaire et rÃ©cupÃ©rez son contenu pour rÃ©pondre Ã  la question.\nOn retrouve dans les fichiers rÃ©cents de l\u0026rsquo;utilisateur un shortcut vers le fichier \u0026ldquo;Week 1 plan.txt\u0026rdquo;. Mais aucune trace du fichier car on n\u0026rsquo;a pas la copie du dossier en question.\nOn va donc analyser la $MFT. Comme on l\u0026rsquo;a dÃ©jÃ  vu, chaque fichier mÃªme s\u0026rsquo;il a Ã©tÃ© effacÃ© ou dÃ©placÃ© possÃ¨de une entrÃ©e dans la MFT et on va pouvoir retrouver la \u0026ldquo;resident data\u0026rdquo; :\nNon-resident : pour les fichiers de taille suffisante, NTFS ne stocke pas directement leurs donnÃ©es dans la MFT. Le champ $DATA contient alors des â€œrunsâ€ (des blocs) qui pointent vers des clusters sur le disque oÃ¹ le contenu rÃ©el est stockÃ©. Resident : quand que le fichier est trÃ¨s petit (historiquement : moins de 1 KB ou de lâ€™ordre de quelques centaines dâ€™octets, selon la version de Windows et la taille de lâ€™attribut), ses donnÃ©es sont stockÃ©es directement Ã  lâ€™intÃ©rieur mÃªme de lâ€™entrÃ©e MFT, dans le bloc $DATA. On parle alors de resident data. â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ MFT Header â”‚ Attribut #0 (STANDARD_INFO) â”‚ ... â”‚ â”‚ (48 bytesâ€¦) â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”‚ â”‚ Attribut #1 (FILE_NAME)â”‚ â”‚ â”‚ â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â”‚ â”‚ Attribut #2 (DATA, resident) â”‚ \u0026lt;â€” câ€™est lÃ  quâ€™est â”‚ â”‚ â”‚ â”‚ stockÃ© le texte. â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚\t...... â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ cf. https://youtu.be/B4b6Ocf3wYs?si=rUruujZiEIdjgFKD\nRÃ©ponse : Filesystem Security\nQuestion 14 # Quel est le nom de l\u0026rsquo;analyste de sÃ©curitÃ© qui a triÃ© le poste de travail infectÃ© ?\nUn peu de guess car la question n\u0026rsquo;est pas trÃ¨s intÃ©ressante, si vous avez fait pas mal de Sherlock vous commencez Ã  avoir l\u0026rsquo;habitude c\u0026rsquo;est CyberJunkie.\nRÃ©ponse : CyberJunkie\nQuestion 15 # Quel est le chemin d\u0026rsquo;accÃ¨s au rÃ©seau Ã  partir duquel les outils d\u0026rsquo;acquisition ont Ã©tÃ© exÃ©cutÃ©s ?\nPremiÃ¨rement nous devons trouver le tool utilisÃ©. Pour cela, plusieurs mÃ©thodes :\nvÃ©rifier les fichiers LNK \u0026amp; Jump Lists Event ID 4688 (A new process has been created) AmCache (InventoryApplicationFile) $MFT comme on l\u0026rsquo;a vu plus tÃ´t Les fichiers Prefetch Pour le plus de rapiditÃ© j\u0026rsquo;ai dÃ©cidÃ© de passer via les fichiers prefetch. Logiquement le tool d\u0026rsquo;acquisition a Ã©tÃ© lancÃ© le plus rÃ©cemment possible :\nNÃ©anmoins pas de chemin.\nDu coup, je vÃ©rifie dans :\nAppCompatCache : RAS Event ID 4688 : RAS $MFT : RAS Je vais donc chercher du cÃ´tÃ© du NTUSER.DAT mais RAS aussi\u0026hellip; NÃ©anmoins on voit bien qu\u0026rsquo;on a ntuser.dat.LOG1 et LOG2.\nCe sont des journaux de transactions associÃ© Ã  la ruche de registre utilisateur (NTUSER.DAT).\nChaque modification apportÃ©e aux clÃ©s et valeurs du registre (par exemple, lorsquâ€™un chemin rÃ©seau est ajoutÃ© dans un MRU ou un clÃ© UserAssist) est dâ€™abord Ã©crite dans ce journal avant dâ€™Ãªtre intÃ©grÃ©e (â€œcommittÃ©e\u0026quot;) dans NTUSER.DAT lui-mÃªme. ConcrÃ¨tement :\ncâ€™est le log transactionnel de la ruche utilisateur : Ã  chaque fois quâ€™une application ou Windows Ã©crit quelque chose dans HKCU (RunMRU, UserAssist, RecentDocs, etc.), la modification est dâ€™abord consignÃ©es dans NTUSER.DAT.LOG1 (et LOG2), puis fusionnÃ©e dans NTUSER.DAT Ã  un checkpoint si on ferme brutalement la session ou quâ€™aucun â€œcheckpointâ€ nâ€™a encore eu lieu, NTUSER.DAT.LOG1 peut contenir des entrÃ©es qui nâ€™apparaissent pas encore dans NTUSER.DAT Je lance donc une recherche via string et bingo :\nRÃ©ponse : \\\\DESKTOP-887GK2L\\Users\\CyberJunkie\\Desktop\\Forela-Triage-Workstation\\Acquisiton and Triage tools\nIOC Table # CatÃ©gorie Type / Champ Valeur (indicateur) Notes Hash Fichiers (origine) Nom ZIP original OBS-Studio-28.1.2-Full-Installer-x64.zip NTUSER.DAT â–¸ RecentDocs RAS (pas le fichier) Setup malveillant OBS Studio 28.1.2 Full Installer x64.exe Amcache â–¸ InventoryApplicationFile SHA-1 = 35e3582a9ed14f8a4bb81fd6aca3f0009c78a3a1 Backdoor EXE C:\\Users\\Simon.stark\\Miloyeki ker konoyogi\\lat takewode libigax weloj jihi quimodo datex dob cijoyi mawiropo.exe $MFT RAS (pas le fichier) RÃ©seau Domain obsproicet.net ADS Zone.Identifier URL exacte http://obsproicet.net/download/v28_23/OBS-Studio-28.1.2-Full-Installer-x64.zip ADS Zone.Identifier IP serveur 13.232.96.186 pfirewall.log Port source max 50045 (TCP) pfirewall.log Domain invalide oaueeewy3pdy31g3kpqorpc4e.qopgwwytep DNS-Client Operational Bucket S3 exfil bbuseruploads.s3.amazonaws.com DNS-Client Operational Persistance Scheduled Task Name \\COMSurrogate Security.evtx (4698) Prefetch hash D8A6D943 Nom du .pf Lab terminÃ© !\nhttps://labs.hackthebox.com/achievement/sherlock/1271052/899\n","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/posts/streamer/","section":"Posts","summary":"ScÃ©nario # Simon Stark est un dÃ©veloppeur chez forela qui a rÃ©cemment prÃ©vu de diffuser des sessions de programmation avec ses collÃ¨gues, ce qui lui a valu l\u0026rsquo;apprÃ©ciation du PDG et d\u0026rsquo;autres collÃ¨gues.","title":"Streamer","type":"posts"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/windows/","section":"Tags","summary":"","title":"Windows","type":"tags"},{"content":"","date":"1 juin 2025","externalUrl":null,"permalink":"/blog-cyber/tags/writeup/","section":"Tags","summary":"","title":"Writeup","type":"tags"},{"content":"","date":"18 mai 2025","externalUrl":null,"permalink":"/blog-cyber/tags/2025/","section":"Tags","summary":"","title":"2025","type":"tags"},{"content":"","date":"18 mai 2025","externalUrl":null,"permalink":"/blog-cyber/tags/fcsc/","section":"Tags","summary":"","title":"FCSC","type":"tags"},{"content":" ScÃ©nario # Lors d\u0026rsquo;un passage de douane, le douanier vous demande de lui remettre votre tÃ©lÃ©phone ainsi que son code de dÃ©verrouillage. Le tÃ©lÃ©phone vous est rendu quelques heures plus tard â€¦ Suspicieux, vous envoyez votre tÃ©lÃ©phone pour analyse au CERT-FR de l\u0026rsquo;ANSSI. Les analystes du CERT-FR effectuent une collecte sur le tÃ©lÃ©phone, composÃ©e d\u0026rsquo;un sysdiagnose et d\u0026rsquo;un backup. Ces Ã©preuves font partie d\u0026rsquo;une sÃ©rie. Les Ã©preuves sont indÃ©pendantes sauf iBackdoor 2/2 qui dÃ©pend de iBackdoor 1/2 : iForensics - iCrash iForensics - iDevice iForensics - iWiFi iForensics - iTreasure iForensics - iNvisible iForensics - iBackdoor 1/2 iForensics - iBackdoor 2/2 iForensics - iC2 iForensics - iCompromise\nOn a donc une backup.tar.xz (logique) et des sysdiagnose \u0026amp; crashes !\nSetup # Pour ces challenges nous allons utiliser :\nDB Browser for SQLite EC-DIGIT-CSIRC/sysdiagnose iLEAPP Autopsy On peut aussi s\u0026rsquo;aider de cheatsheets telles que :\nOn pourrait aussi utiliser des tools et mÃ©thodologies plus \u0026ldquo;pro\u0026rdquo; (via Plaso etc.) mais dans le contexte du CTF (fait en retard) je n\u0026rsquo;ai pas pris le temps de le faire. ğŸ¤ \nIntro - iForensics - iCrash # Il semblerait qu\u0026rsquo;un flag se soit cachÃ© Ã  l\u0026rsquo;endroit oÃ¹ sont stockÃ©s les crashes sur le tÃ©lÃ©phone â€¦\nIci trÃ¨s simple. On sait que les crashs se trouvent dans l\u0026rsquo;archive sysdiagnose_and_crashes.tar.xz. On l\u0026rsquo;extrait donc :\ntar -xf sysdiagnose_and_crashes.tar.xz Ici on peut trouver de plusieurs maniÃ¨res, un simple grep grep -r \u0026quot;FCSC{\u0026quot;, se balader dans les logs de crash etc.\nSi on se rend dans sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/ on trouve le fichier fcsc_intro.txt avec le flag.\nFlag : FCSC{7a1ca2d4f17d4e1aa8936f2e906f0be8}\nâ­ - iForensics - iDevice # Pour commencer, trouvez quelques informations d\u0026rsquo;intÃ©rÃªt sur le tÃ©lÃ©phone : version d\u0026rsquo;iOS et identifiant du modÃ¨le de tÃ©lÃ©phone. Le flag est au format FCSC{\u0026lt;identifiant du modÃ¨le\u0026gt;|\u0026lt;numÃ©ro de build\u0026gt;}. Par exemple, pour un iPhone 14 Pro Max en iOS 18.4 (22E240) : FCSC{iPhone15,3|22E240}.\nPour rÃ©pondre Ã  cette question il faut savoir de quoi est constituÃ© une backup iOS. J\u0026rsquo;ai parlÃ© plus haut de backup \u0026ldquo;logique\u0026rdquo;. Cela a une importance car si on regarde Ã  l\u0026rsquo;intÃ©rieur de la backup on ne voit que des dossiers bizarres :\nEn fait il faut reconstruire la structure et noms de dossiers / fichiers. Pour cela il faut utiliser la Manifest.db (iOS 10+) en faisant la correspondance entre les RelativePath et les FileID.\nNÃ©anmoins on voit aussi des fichiers avec des noms normaux dont Info.plist. C\u0026rsquo;est ici qu\u0026rsquo;Apple conserve les metadata clÃ©s concernant l\u0026rsquo;appareil :\nProduct Type (identifiant du modÃ¨le, ex. iPhone12,3), Product Version (version d\u0026rsquo;iOS, ex. 16.0), Build Version (numÃ©ro de build, ex. 20A362), Divers identifiants (IMEI, MEID, Serial Number, GUIDâ€¦), Date du dernier backup, applications installÃ©es, etc. On a donc tout ce qu\u0026rsquo;il nous faut pour faire le flag :\nFlag : FCSC{iPhone12,3|20A362}\nSi reconstruire l\u0026rsquo;arbo vous intÃ©resse voici pour la dÃ©monstration :\nPremiÃ¨rement regardons de quoi est constituÃ© Manifest.db :\nTrÃ¨s direct, on peut donc scripter facilement la reconstruction comme cela :\n#!/bin/bash BACKUP=\u0026#34;/mnt/hgfs/backup/backup\u0026#34; OUT=\u0026#34;/mnt/hgfs/backup/reconstructed-backup\u0026#34; mkdir -p \u0026#34;$OUT\u0026#34; # on utilise -separator \u0026#39;|\u0026#39; pour que SQLite nous renvoie directement fileID|domain|relativePath sqlite3 -separator \u0026#39;|\u0026#39; \u0026#34;$BACKUP/Manifest.db\u0026#34; \\ \u0026#34;SELECT fileID, domain, COALESCE(relativePath,\u0026#39;\u0026#39;) FROM Files;\u0026#34; \\ | while IFS=\u0026#34;|\u0026#34; read -r FILEID DOMAIN RELPATH; do # Si relativePath est vide, on saute (ce sont souvent des entrÃ©es de dossier sans chemin) [[ -z \u0026#34;$RELPATH\u0026#34; ]] \u0026amp;\u0026amp; continue # Chemins de sortie pour recrÃ©er l\u0026#39;arborescence DEST_DIR=\u0026#34;$OUT/$DOMAIN/$(dirname \u0026#34;$RELPATH\u0026#34;)\u0026#34; DEST_PATH=\u0026#34;$OUT/$DOMAIN/$RELPATH\u0026#34; mkdir -p \u0026#34;$DEST_DIR\u0026#34; ln -s \u0026#34;$BACKUP/$FILEID\u0026#34; \u0026#34;$DEST_PATH\u0026#34; 2\u0026gt;/dev/null || true done Et voilÃ  :\nâ­ - iForensics - iWiFi # Pour continuer, trouvez quelques informations d\u0026rsquo;intÃ©rÃªt sur le tÃ©lÃ©phone : SSID et BSSID du rÃ©seau WiFi sur lequel le tÃ©lÃ©phone est connectÃ© ainsi que le compte iCloud associÃ© au tÃ©lÃ©phone. Le flag est au format FCSC{||}. Par exemple, si le tÃ©lÃ©phone est connectÃ© sur le rÃ©seau WiFi example, qui a pour BSSID 00:11:22:33:44:55 et que le compte iCloud associÃ© est example@example.com : FCSC{example|00:11:22:33:44:55|example@example.com}.\nAfin d\u0026rsquo;accÃ©lÃ©rer l\u0026rsquo;extraction des informations Wi-Fi et iCloud, on peut utiliser iLEAPP (iOS Logs, Events, and Protobuf Parser) : il va collecter et organiser automatiquement pour nous pleins d\u0026rsquo;artefacts et faire un rapport.\nBref aprÃ¨s avoir fait passÃ© l\u0026rsquo;ILEAPP on trouve le SSID \u0026amp; BSSID ici :\nPour le compte iCloud plusieurs maniÃ¨res mais une faÃ§on assez direct avec iLEAPP et de regarder par quel compte les apps ont-elles Ã©tÃ© installÃ© :\nFlag : FCSC{FCSC|66:20:95:6c:9b:37|robertswigert@icloud.com}\nâ­â­ - iForensics - iTreasure # Avant la remise du tÃ©lÃ©phone Ã  la douane, le propriÃ©taire du tÃ©lÃ©phone a eu le temps d\u0026rsquo;envoyer un trÃ©sor. Retrouvez ce trÃ©sor.\nIci plusieurs maniÃ¨res rapide de le trouver. En effet le scÃ©nario parle d\u0026rsquo;un envoi. On pense directement au SMS.\niLEAPP parse cela donc on peut aller checker directement :\nOn peut aussi le faire ingÃ©rer Ã  Autopsy avec le module \u0026ldquo;Logical File Analysis\u0026rdquo;. GrÃ¢ce Ã  cela, Autopsy va scanner tous les fichiers et, d\u0026rsquo;aprÃ¨s leurs en-tÃªtes (magic bytes), il va regrouper certains des mÃ©dias (JPEG, PNG, etc.) sous l\u0026rsquo;onglet \u0026ldquo;User Content Suspected\u0026rdquo; car le Chemin d\u0026rsquo;accÃ¨s est localisÃ© dans HomeDomain/Media/DCIM/â€¦. Il considÃ¨re donc qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un contenu utilisateur (photo prise ou importÃ©e)\nFlag : FCSC{511773550dca}\nâ­â­ - iForensics - iNvisible # Il semblerait qu\u0026rsquo;un message n\u0026rsquo;ait pas pu s\u0026rsquo;envoyer â€¦ Retrouvez le destinataire de ce message. Le flag est au format FCSC{}. Par exemple, si le destinataire est example@example.com : FCSC{example@example.com}.\nIci trÃ¨s rapide, on peut directement aller chercher dans la DB sms.db. C\u0026rsquo;est cette base qui contient toutes les conversations (iMessage et SMS), avec les tables principales message (headers, Ã©tat, texte, etc.) et handle (liste des correspondants, numÃ©ros / adresses).\nNe faites pas l\u0026rsquo;erreur d\u0026rsquo;aller chercher dans la table \u0026ldquo;message\u0026rdquo;. En effet, on ne retrouve que les iMessage ici. Pour les SMS il faut aller dans la table \u0026ldquo;chat\u0026rdquo;.\nFlag : FCSC{kristy.friedman@outlook.com}\nâ­â­ - iForensics - iBackdoor 1/2 # Vous continuez vos analyses afin de trouver la backdoor sur le tÃ©lÃ©phone. Vous finissez par vous rendre compte qu\u0026rsquo;une application est compromise et que le tÃ©lÃ©phone Ã©tait infectÃ© au moment de la collecte â€¦ Trouvez l\u0026rsquo;identifiant de l\u0026rsquo;application compromise ainsi que l\u0026rsquo;identifiant de processus (PID) du malware.\nLe flag est au format FCSC{|}. Par exemple, si l\u0026rsquo;application compromise est Example (com.example) et que le PID est 1337 : FCSC{com.example|1337}.\nIci on va devoir s\u0026rsquo;appuyer sur les sysdiagnose (/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362).\nMais avant c\u0026rsquo;est quoi les sysdiagnose ? C\u0026rsquo;est une archive gÃ©nÃ©rÃ©e par iOS qui regroupe automatiquement les logs systÃ¨me, rapports de crash, Ã©tats rÃ©seau et informations de configuration au moment de la capture. Il sert principalement Ã  diagnostiquer des problÃ¨mes de performance ou de stabilitÃ© en fournissant un instantanÃ© complet de l\u0026rsquo;appareil. Mais il est aussi trÃ¨s utile d\u0026rsquo;un point de vu forensic aprÃ¨s une compromission.\nPour Ãªtre un minimum pro et gagner du temps je vais utiliser le superbe tool EC-DIGIT-CSIRC/sysdiagnose https://github.com/EC-DIGIT-CSIRC/sysdiagnose.\nâ”Œâ”€â”€(venv)â”€(kaliã‰¿kali)-[~/sysdiagnose] â””â”€$ sysdiag create /mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz Sysdiagnose file has been processed: /mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz Case \u0026#39;C39ZL6V1N6Y6_20250407_080618\u0026#39; created successfully from \u0026#39;/mnt/hgfs/backup/sysdiagnose_and_crashes/private/var/mobile/Library/Logs/CrashReporter/DiagnosticLogs/sysdiagnose/sysdiagnose_2025.04.07_08-06-18-0700_iPhone-OS_iPhone_20A362.tar.gz\u0026#39; On voit bien que la case a Ã©tÃ© crÃ©Ã© :\nOn fait passer le parser \u0026ldquo;ps\u0026rdquo; car trÃ¨s utile dans ce contexte. En effet analyser le contenu de ps.txt (le listing des processus) permet :\nD\u0026rsquo;avoir une visibilitÃ© sur tous les processus en cours : Le ps.txt fournit un instantanÃ© de tout ce qui tourne sur l\u0026rsquo;iPhone (y compris les exÃ©cutables cachÃ©s ou lancÃ©s par des services systÃ¨me). Sans ce listing, un malware qui se dissimule derriÃ¨re un nom trompeur ou dans un rÃ©pertoire non standard pourrait passer inaperÃ§u.\nDÃ©tection d\u0026rsquo;anomalies dans les privilÃ¨ges En regardant les colonnes user/uid et ppid, on repÃ¨re rapidement quand un processus tiers (par exemple extrait d\u0026rsquo;une app tierce) s\u0026rsquo;exÃ©cute sous l\u0026rsquo;utilisateur root (UID 0). Or, une app normale ne devrait jamais obtenir un tel niveau de privilÃ¨ges sans passer par un mÃ©canisme officiel.\nIdentification de commandes et arguments suspects Le champ command montre l\u0026rsquo;exÃ©cutable et ses arguments. Tout binaire inconnu (comme ce qu\u0026rsquo;on verra par la suite) ou toute URL codÃ©e (Base64 ou autre) est immÃ©diatement visible et peut Ãªtre dÃ©codÃ©/inspectÃ©.\nTracking temporel et contexte Avec la date/heure (started, datetime) et les champs de performance (%cpu, %mem), on sait si un processus a dÃ©marrÃ© anormalement tÃ´t (au boot) ou s\u0026rsquo;il consomme des ressources pour exfiltrer des donnÃ©es, mÃªme si Ã§a reste Ã  0 % pour masquer son activitÃ©.\nCorroboration avec d\u0026rsquo;autres modules de sysdiagnose Le ps.txt s\u0026rsquo;intÃ¨gre Ã  l\u0026rsquo;ensemble des autres dumps (rÃ©seau, fichiers ouverts, configurations). On peut croiser : \u0026ldquo;X processus root vers IP Y\u0026rdquo; + \u0026ldquo;connexion rÃ©seau vers Y\u0026rdquo; + \u0026ldquo;fichiers crÃ©Ã©s dans Z\u0026rdquo; pour construire un fil d\u0026rsquo;attaque.\nOn voit donc ceci :\nroot â€¦ 279 1 â€¦ /var/containers/Bundle/Application/â€¦/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== root â€¦ 330 1 â€¦ /var/containers/Bundle/Application/â€¦/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== root â€¦ 345 344 â€¦ /var/containers/Bundle/Application/â€¦/Signal.app/mussel dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== 1. Binaire \u0026ldquo;mussel\u0026rdquo; â€“ Un fichier mussel embarquÃ© dans l\u0026rsquo;app Signal est inhabituel : ce n\u0026rsquo;est pas un dÃ©mon standard d\u0026rsquo;iOS.\n2. ExÃ©cution en root â€“ Il tourne avec l\u0026rsquo;UID 0 (root), ce qui est extrÃªmement suspect pour un composant d\u0026rsquo;application tierce.\n3. Argument codÃ© en Base64 â€“ dGNwOi8vOTguNjYuMTU0LjIzNToyOTU1Mg== est une chaÃ®ne Base64 qui, dÃ©codÃ©e, donne tcp://98.66.154.235:29552, un canal TCP vers une IP externe, sans doute un C2.\n4. Comportement typique d\u0026rsquo;un spyware â€“ Un dÃ©mon inconnu qui s\u0026rsquo;exÃ©cute en root et ouvre une connexion vers un hÃ´te externe ressemble fortement Ã  un implant malveillant ou spyware.\nAnswer : FCSC{org.whispersystems.signal|345}\nâ­â­ - iForensics - iBackdoor 2/2 # Maintenant que vous savez quelle application a Ã©tÃ© compromise, retrouvez comment est-ce que l\u0026rsquo;attaquant a rÃ©cupÃ©rÃ© l\u0026rsquo;application lÃ©gitime, prÃ©alablement Ã  l\u0026rsquo;infection. Il vous faudra retrouver :\nL\u0026rsquo;identifiant de l\u0026rsquo;application utilisÃ©e pour rÃ©cupÃ©rer l\u0026rsquo;application lÃ©gitime; Le chemin utilisÃ© pour stocker l\u0026rsquo;application lÃ©gitime; La date de dÃ©sinstallation de l\u0026rsquo;application lÃ©gitime (en heure locale). Le flag est au format FCSC{||}. Par exemple, si l\u0026rsquo;application utilisÃ©e est Example (com.example), que le chemin est /private/var/tmp/test.xyz et que la date de dÃ©sinstallation est 2025-01-01 01:00:00 : FCSC{com.example|/private/var/tmp/test.xyz|2025-01-01 01:00:00}.\nRemettons les choses Ã  plat :\non sait que c\u0026rsquo;est Signal l\u0026rsquo;app en question on sait qu\u0026rsquo;elle a Ã©tÃ© lancÃ© vers 7:47AM on doit trouver le chemin de l\u0026rsquo;app, ce qui a \u0026ldquo;rÃ©cupÃ©rÃ©\u0026rdquo; / installÃ© l\u0026rsquo;app lÃ©gitime et la date de dÃ©sinstallation Pour cela je me suis directement dirigÃ© vers les mobileinstallation.\nEn effet, c\u0026rsquo;est la couche d\u0026rsquo;iOS responsable de l\u0026rsquo;installation, la mise Ã  jour et dÃ©sinstallation des apps.\nOn pourra y retrouver :\nles timestamps prÃ©cis (timestamp + datetime) les bundle id les dÃ©tails du process d\u0026rsquo;uninstall les erreurs et leur contexte Bingo : // Ã  07:40:47-07:00, premiÃ¨re dÃ©sinstallation de Signal { \u0026#34;datetime\u0026#34;: \u0026#34;2025-04-07T07:40:47.000000-07:00\u0026#34;, \u0026#34;event_type\u0026#34;: \u0026#34;MIClientConnection _uninstallIdentities\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Uninstall requested by installcoordinationd ... for identity [org.whispersystems.signal]\u0026#34; } // Ã  la mÃªme seconde, on dÃ©truit ses containers : \u0026#34;message\u0026#34;: \u0026#34;Destroying container org.whispersystems.signal ... at /private/var/containers/Bundle/Application/1EC20F02-...\u0026#34; // Ã  07:43:55, dÃ©sinstallation de l\u0026#39;outil com.fiore.trolldecrypt { \u0026#34;datetime\u0026#34;: \u0026#34;2025-04-07T07:43:55.000000-07:00\u0026#34;, \u0026#34;message\u0026#34;: \u0026#34;Uninstalling identifier com.fiore.trolldecrypt\u0026#34; // puis destruction du bundle container correspondant } On sait donc maintenant que l\u0026rsquo;attaquant a utilisÃ© TrollDecrypt qui est utilitaire opensource destinÃ© aux appareils iOS Ã©quipÃ©s de TrollStore. Il permet de dÃ©chiffrer Ã  la volÃ©e les applications installÃ©es (IPA protÃ©gÃ©es par FairPlay DRM) directement sur l\u0026rsquo;appareil, sans nÃ©cessiter de jailbreak. ConcrÃ¨tement, il :\nscanne la liste des apps installÃ©es sur l\u0026rsquo;iDevice via TrollStore dÃ©chiffre le binaire FairPlay de l\u0026rsquo;application ciblÃ©e emballe le rÃ©sultat dans un fichier .ipa exploitable (pour analyses, rÃ©installations, sideloading, etc.) TrollStore exploite une faille CoreTrust pour signer Ã  vie n\u0026rsquo;importe quelle IPA. TrollDecrypt s\u0026rsquo;appuie dessus pour lancer l\u0026rsquo;app ciblÃ©e, dumper sa mÃ©moire et sortir un IPA FairPlay free. D\u0026rsquo;oÃ¹ la prÃ©sence du dossier /Library/TrollDecrypt/decrypted/.\nJ\u0026rsquo;avoue qu\u0026rsquo;il y aurait mille faÃ§ons intelligentes de pivoter, analyser et trouver le path de stockage de l\u0026rsquo;app lÃ©gitime mais il y a plus rapide. Dans un contexte de CTF Ã§a compte.\nChercher un .ipa tout simplement.\nCe qui donne pour une timeline trÃ¨s succincte :\n07h40m47s : dÃ©sinstallation de Signal (log MI) 07h40â€“42m : dump â†’ Signal_7.53_decrypted.ipa (fslisting) 07h43m55s : dÃ©sinstallation de TrollDecrypt (log MI) 07h47mxxs : lancement de l\u0026rsquo;IPA repackÃ©e (unified log) On a dÃ©sormais tout pour crÃ©er le flag.\nFlag : FCSC{com.fiore.trolldecrypt|/private/var/mobile/Library/TrollDecrypt/decrypted/Signal_7.53_decrypted.ipa|2025-04-07 07:40:47}\nâ­â­â­ - iForensics - iC2 # Retrouvez le nom de l\u0026rsquo;outil malveillant dÃ©ployÃ© sur le tÃ©lÃ©phone, ainsi que le protocole, l\u0026rsquo;adresse IP et le port de communication vers le serveur C2.\nLe flag est au format FCSC{|||}. Par exemple, si l\u0026rsquo;outil est Cobalt Strike, le protocole TCP, l\u0026rsquo;adresse IP 127.0.0.1 et le port 1337 : FCSC{Cobalt Strike|TCP|127.0.0.1|1337}.\nJe me suis donc renseignÃ© davantage sur TrollStore et les actualitÃ©s intÃ©ressantes liÃ©es. Je suis tombÃ© sur cette article : https://idevicecentral.com/news/ios-malware-makes-trollstore-users-vulnerable-to-monitoring-file-extraction-remote-control-on-ios-14-ios-17/\nOn a dÃ©jÃ  rÃ©cupÃ©rÃ© le protocol, l\u0026rsquo;IP et le port plus tÃ´t donc c\u0026rsquo;est simple :\nFlag : FCSC{SeaShell|TCP|98.66.154.235|29552}\n","date":"18 mai 2025","externalUrl":null,"permalink":"/blog-cyber/posts/fcsc/","section":"Posts","summary":"ScÃ©nario # Lors d\u0026rsquo;un passage de douane, le douanier vous demande de lui remettre votre tÃ©lÃ©phone ainsi que son code de dÃ©verrouillage.","title":"FCSC 2025 - iOS Forensic","type":"posts"},{"content":" ScÃ©nario # Ã€ l\u0026rsquo;issue du processus de rÃ©cupÃ©ration du serveur, l\u0026rsquo;Ã©quipe IR a mis en Ã©vidence un rÃ©seau complexe de trafic persistant, de communications furtives et de processus tenaces ayant rÃ©sistÃ© Ã  nos tentatives d\u0026rsquo;arrÃªt. Il est Ã©vident que la portÃ©e de l\u0026rsquo;incident dÃ©passe la violation initiale de nos serveurs et de nos clients. En tant qu\u0026rsquo;expert en forensic, pouvez-vous Ã©clairer les ombres qui cachent ces activitÃ©s clandestines ?\nSetup # Pour ce Sherlock nous allons utiliser :\nVolatility2 IDA Nous allons Ã©galement nous appuyer sur cette cheatsheet :\nhttps://downloads.volatilityfoundation.org/releases/2.4/CheatSheet_v2.4.pdf Profil volatility # PremiÃ¨rement on doit installer python2, volatility2 et ajouter le profil nÃ©cessaire.\nUn profil Volatility est un fichier contenant des informations structurelles sur le systÃ¨me d\u0026rsquo;exploitation cible. Pour simplifier, c\u0026rsquo;est comme une \u0026ldquo;carte\u0026rdquo; qui permet Ã  Volatility de comprendre comment les donnÃ©es sont organisÃ©es dans la mÃ©moire d\u0026rsquo;un systÃ¨me spÃ©cifique.\nCe profil contient principalement deux types d\u0026rsquo;informations :\nles dÃ©finitions des structures de donnÃ©es du kernel les symboles du kernel (adresses des fonctions et variables) Installation :\nsudo apt install -y python2 python2-dev build-essential libdistorm3-dev libssl-dev libffi-dev zlib1g-dev curl -sS https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py sudo python2 get-pip.py sudo python2 -m pip install --upgrade pip setuptools wheel sudo python2 -m pip install distorm3 pycrypto openpyxl pillow yara-python git clone https://github.com/volatilityfoundation/volatility.git cd volatility python2 vol.py -h Profil :\ncp Ubuntu_5.3.0-70-generic_profile.zip /home/kali/Documents/volatility/volatility/plugins/overlays/linux/ python2 vol.py --info | grep Linux Question 1 # Quels sont les IP et le port utilisÃ©s par l\u0026rsquo;attaquant pour le reverse shell ?\nPour cela on va utiliser le module linux_netstat de volatility qui permet d\u0026rsquo;extraire et afficher toutes les connexions rÃ©seaux qui Ã©taient prÃ©sentes lors de la capture mÃ©moire. On va rediriger l\u0026rsquo;output dans un fichier pour faciliter la recherche via un Ã©diteur de texte / IDE etc.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_netstat \u0026gt; netstat.txt Sous Linux, le plus probable est de retrouver un reverse shell bash particuliÃ¨rement basique, et effectivement :\nRÃ©ponse : 10.0.2.6:443\nQuestion 2 # Quel Ã©tait le PPID de la connexion malveillante du reverse shell ?\nTout d\u0026rsquo;abord, testons avec ``linux_pstree` :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_pstree | grep -C 5 3633 Pas de PPID. Pourquoi ? Le plugin linux_pstree reconstruit l\u0026rsquo;arborescence des processus en se basant principalement sur une seule source d\u0026rsquo;information : la liste des tÃ¢ches actives du systÃ¨me (task_struct).\nhttps://makelinux.github.io/kernel/map/\nOn va donc plutÃ´t utiliser le plugin linux_psxview qui est conÃ§u spÃ©cifiquement pour dÃ©tecter les processus cachÃ©s. Il utilise plusieurs sources pour idenfifier les processus :\ntask_struct list : la mÃªme liste de tÃ¢ches utilisÃ©e par linux_pstree pid hash table : une structure de hachage utilisÃ©e par le kernel pour rechercher rapidement les processus par PID pslist : liste des processus extraite d\u0026rsquo;autres sources mÃ©moire kmem_cache : cache du kernel qui peut contenir des rÃ©fÃ©rences aux processus d_path : informations sur les processus tirÃ©es du systÃ¨me de fichiers procfs thread_info : informations des threads qui peuvent rÃ©vÃ©ler des processus cachÃ©s Il compare ensuite les rÃ©sultats de ces diffÃ©rentes sources et signale les incohÃ©rences, par exemple lorsqu\u0026rsquo;un processus apparaÃ®t dans une source mais pas dans une autre.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_psxview \u0026gt; psxview.txt Et logiquement, on se doute bien que le parent est le PID juste avant.\nMais pourquoi le cacher ? Au vu du scÃ©nario, on sait que l\u0026rsquo;on a Ã  faire Ã  un rootkit. Ce qui s\u0026rsquo;est probablement passÃ© c\u0026rsquo;est que le rootkit a modifiÃ© la liste des tÃ¢ches (task_struct list) en \u0026ldquo;dÃ©connectant\u0026rdquo; son processus de reverse shell de cette liste chaÃ®nÃ©e. ConcrÃ¨tement, il a manipulÃ© les pointeurs next et prev de cette liste pour que son processus soit ignorÃ© lors du parcours de la liste.\nCependant, le rootkit n\u0026rsquo;a pas rÃ©ussi Ã  effacer toutes les traces de son existence. Il a omis de modifier une ou plusieurs des autres structures surveillÃ©es par linux_psxview.\nLe rÃ©sultat est que linux_pstree, qui ne se fie qu\u0026rsquo;Ã  la liste des tÃ¢ches, ne voit pas le processus malveillant, tandis que linux_psxview, qui vÃ©rifie plusieurs sources, le dÃ©tecte via les structures que le rootkit a nÃ©gligÃ© de modifier.\nRÃ©ponse : 3632\nQuestion 3 # Indiquer le nom du module malveillant du kernel.\nPour cela on va utiliser le plugin linux_check_modules. Mais avant, remettons en contexte qu\u0026rsquo;est-ce qu\u0026rsquo;un module kernel et quel est le lien avec un rootkit.\nUn module kernel c\u0026rsquo;est un morceau de code qui peut Ãªtre chargÃ© et dÃ©chargÃ© dynamiquement dans le kernel d\u0026rsquo;un systÃ¨me d\u0026rsquo;exploitation en cours d\u0026rsquo;exÃ©cution. Cela permet d\u0026rsquo;Ã©tendre ses fonctionnalitÃ©s (comme la prise en charge de nouveaux pÃ©riphÃ©riques ou systÃ¨mes de fichiers) sans devoir redÃ©marrer ou recompiler complÃ¨tement le kernel.\nLes rootkits opÃ¨rent au niveau du kernel Linux en insÃ©rant leurs propres modules kernel (LKM - Loadable Kernel Modules). Ces modules malveillants peuvent:\nintercepter les appels systÃ¨me pour dissimuler des fichiers, processus ou connexions Ã©tablir des backdoors persistantes dans le systÃ¨me dÃ©sactiver certaines fonctionnalitÃ©s de sÃ©curitÃ© du kernel masquer leur propre prÃ©sence aux outils standard du systÃ¨me etc. Concernant le plugin volatility linux_check_modules. Il est conÃ§u pour dÃ©tecter les LKM cachÃ© en comparant encore une fois diffÃ©rente sources d\u0026rsquo;information du kernel.\n1. Analyse de la liste officielle des modules\nTout d\u0026rsquo;abord, le plugin examine la liste des modules officiellement chargÃ©s (modules.list). Cette liste circulairement chaÃ®nÃ©e est maintenue par le kernel et contient tous les modules lÃ©gitimement chargÃ©s. Elle est accessible via la commande lsmod.\n2. Analyse des symboles du kernel\nEnsuite, il parcourt la table des symboles du kernel (accessible via /proc/kallsyms). Cette table contient les adresses de toutes les fonctions et variables du kernel, y compris celles introduites par des modules chargÃ©s.\n3. Analyse de la section modulaire .ko\nLe plugin examine Ã©galement les sections mÃ©moire oÃ¹ les modules kernel (.ko) sont typiquement chargÃ©s, recherchant les signatures caractÃ©ristiques des modules mÃªme s\u0026rsquo;ils ne sont pas rÃ©fÃ©rencÃ©s ailleurs.\n4. Techniques de dÃ©tection des modules cachÃ©s\nla technique principale consiste Ã  comparer les modules trouvÃ©s dans la liste officielle avec ceux dÃ©tectÃ©s par l\u0026rsquo;analyse des symboles ou des sections mÃ©moire. Un module prÃ©sent dans une source mais absent de la liste officielle est probablement cachÃ© intentionnellement. le plugin examine Ã©galement la table des appels systÃ¨me (syscall table) pour dÃ©tecter si des fonctions originales ont Ã©tÃ© remplacÃ©es par des versions modifiÃ©es - une technique courante des rootkits pour intercepter les interactions avec le kernel. il vÃ©rifie si les adresses des fonctions de modules pointent vers des rÃ©gions mÃ©moire suspectes ou non standard, ce qui pourrait indiquer du code injectÃ©. les attributs des modules sont analysÃ©s (comme l\u0026rsquo;horodatage, le nom, l\u0026rsquo;auteur) pour dÃ©tecter des informations incohÃ©rentes ou inhabituelles. Ok c\u0026rsquo;est cool mais comment les rootkit se cache au fait ?\nIl y a beaucoup de technique diffÃ©rente mais on retrouve gÃ©nÃ©ralement :\nDKOM (Direct Kernel Object Manipulation) : Ils modifient les structures de donnÃ©es du kernel en mÃ©moire pour retirer leur module de la liste modules.list, tout en laissant le module fonctionnel.\nHooks de syscall : Ils remplacent les fonctions lÃ©gitimes du kernel par leurs propres versions qui filtrent les rÃ©sultats (par exemple, une version modifiÃ©e de read qui ne montre jamais certains fichiers).\nModule sans nom : Certains modules malveillants utilisent des chaÃ®nes vides ou des caractÃ¨res spÃ©ciaux comme nom pour compliquer leur dÃ©tection.\nEnfin bref, revenons Ã  la question.\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_check_modules Le nom \u0026ldquo;nfentlink\u0026rdquo; est une tentative de camouflage d\u0026rsquo;un module malveillant en se faisant passer pour \u0026ldquo;nfnetlink\u0026rdquo;, qui est un module kernel lÃ©gitime de Linux utilisÃ© pour la communication entre l\u0026rsquo;espace kernel et l\u0026rsquo;espace utilisateur pour le firewall et le rÃ©seau.\nRÃ©ponse : nfentlink\nQuestion 4 # Quand est-ce que le module a Ã©tÃ© chargÃ© ?\nAu dÃ©part, j\u0026rsquo;Ã©tais parti sur une mauvaise piste. Ma pensÃ©e Ã©tait :\nprendre le timestamp du chargement du module dans dmesg via linux_dmesg prendre le timestamp du boot dans linux_pslist calculer et hop Cela aurait fonctionnÃ© si c\u0026rsquo;Ã©tait la premiÃ¨re fois que le module Ã©tait chargÃ©. NÃ©anmoins, il a dÃ©jÃ  Ã©tÃ© chargÃ© dans le passÃ©. Cette mÃ©thode est intrinsÃ¨quement mauvaise et peut induire en erreur dans un contexte de rÃ©ponse Ã  incident.\nAu final j\u0026rsquo;ai remis tout Ã  plat et je me suis dit \u0026ldquo;oÃ¹ puis-je trouver des timestamp liÃ© Ã  des actions passÃ©es aprÃ¨s de multiple boot ?\u0026rdquo;.\nLes logs systÃ¨mes Ã©videmment. Tout particuliÃ¨rement /var/log/kern.log ou /var/log/syslog.log.\nPour rÃ©cupÃ©rer ces fichiers on va premiÃ¨rement Ã©numÃ©rer les fichiers dans la capture mÃ©moire :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_enumerate_files \u0026gt; files.txt Et en effet on retrouve bien : Ensuite, pour extraire /var/log/kern.log on va :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea5a732fa8 -O kern.log RÃ©ponse : 2024-05-01 20:42:57\nQuestion 5 # Quel est le chemin d\u0026rsquo;accÃ¨s complet et le nom du fichier du module du kernel malveillant ?\nDe mÃªme, vÃ©rifions parmi les fichiers Ã©numÃ©rÃ©s. PremiÃ¨rement on cherche le module qu\u0026rsquo;on a identifiÃ© \u0026ldquo;nfentlink\u0026rdquo;.\ncat files.txt |grep nfentlink Ã§a ne donne rien d\u0026rsquo;intÃ©ressant.\nOn va donc chercher le module qui a le vrai nom pour voir :\nOn va revenir sur le deuxiÃ¨me fichier plus tard.\nRÃ©ponse : /lib/modules/5.3.0-70-generic/kernel/drivers/net/nfnetlink.ko\nQuestion 6 # Quel est le hash MD5 du fichier du module malveillant ?\nIl suffit d\u0026rsquo;extraire le fichier et calculer son hash :\npython2 vol.py -f ~/Downloads/APTNightmare-2/dump.mem --profile=LinuxUbuntu_5_3_0-70-generic_profilex64 linux_find_file -i 0xffff98ea266b5a68 -O nfnetlink.ko md5sum nfnetlink.ko RÃ©ponse : 35bd8e64b021b862a0e650b13e0a57f7\nQuestion 7 # Quel est le chemin d\u0026rsquo;accÃ¨s complet et le nom du fichier du module du kernel lÃ©gitime ?\nRevenons au screen de la question 5.\nRÃ©ponse : /lib/modules/5.3.0-70-generic/kernel/net/netfilter/nfnetlink.ko\nQuestion 8 # Quelle est la diffÃ©rence d\u0026rsquo;un seul caractÃ¨re dans la valeur de l\u0026rsquo;auteur entre le module lÃ©gitime et le module malveillant ?\nPremiÃ¨rement on va checker le lÃ©gitime via modinfo qui permet d\u0026rsquo;afficher des informations dÃ©taillÃ©s sur un module kernel spÃ©cifique.\nmodinfo /lib/modules/6.11.2-amd64/kernel/net/netfilter/nfnetlink.ko.xz Ensuite, on check le module kernel qu\u0026rsquo;on a rÃ©cupÃ©rÃ© dans la capture :\nmodinfo malicious-nfnetlink.ko On voit donc bien qu\u0026rsquo;il manque un \u0026ldquo;i\u0026rdquo;.\nRÃ©ponse : i\nQuestion 9 # Quel est le nom de la fonction d\u0026rsquo;initialisation du module du kernel malveillant ?\nPour rÃ©pondre Ã  cette question je vais utiliser IDA. C\u0026rsquo;est vraiment overkill, on peut se limiter Ã  gdb (gef\u0026gt;gdb), radare2 etc.\nOn va donc regarder les fonctions : On voit bien que la fonction d\u0026rsquo;initialisation est nfnetlink_init mais aussi init_module. C\u0026rsquo;est encore plus visible avec gef :\nGef affiche les deux fonctions Ã  la mÃªme adresse mÃ©moire. On observe donc une technique dÃ©libÃ©rÃ©e de camouflage utilisÃ©e par des rootkits au niveau kernel.\nLe module malveillant utilise la fonction standard init_module (qui est l\u0026rsquo;entrÃ©e obligatoire pour tout module kernel Linux) mais a intentionnellement renommÃ© cette fonction en nfnetlink_init pour ressembler au module lÃ©gitime du kernel.\nLes symboles d\u0026rsquo;exportation comme init_module sont essentiels pour que le kernel Linux puisse charger le module, mais l\u0026rsquo;attaquant a utilisÃ© des astuces de compilation pour que la mÃªme fonction porte deux noms diffÃ©rents, l\u0026rsquo;un pour le chargement par le kernel et l\u0026rsquo;autre pour le camouflage visuel.\nRÃ©ponse : nfnetlink_init\nQuestion 10 # Il existe une fonction pour hooker les syscall. Quel est le dernier syscall du tableau ?\nDans la fonction nfnetlink_init on voit bien _sys_call_table = kallsyms_lookup_name(\u0026quot;sys_call_table\u0026quot;); :\n_sys_call_table = kallsyms_lookup_name(\u0026#34;sys_call_table\u0026#34;); Cette ligne utilise la fonction kallsym_lookup_name pour obtenir l\u0026rsquo;adresse de la table des syscall sys_call_table dans la mÃ©moire du kernel.\nsys_call_table est un tableau contenant les pointeurs vers les fonctions des syscall utilisÃ©s par le kernel. En modifiant cette table, l\u0026rsquo;attaquant redirige les appels systÃ¨me vers ses propres routines malveillantes.\nOn va donc aller voir le tableau de donnÃ©es dans la section .rodata (section contenant des chaÃ®nes de caractÃ¨res et des donnÃ©es en lecture seule).\nCe tableau contient des rÃ©fÃ©rences Ã  des symboles qui sont utilisÃ©es pour diverses manipulations dans le module malicieux.\naX64SysGetdents db \u0026#39;_x64_sys_getdents64\u0026#39;,0 aX64SysGetdents db \u0026#39;_x64_sys_getdents\u0026#39;,0 aX64SysKill db \u0026#39;_x64_sys_kill\u0026#39;,0 Ces chaÃ®nes sont des rÃ©fÃ©rences aux symboles des fonctions systÃ¨me que le module va utiliser ou modifier.\nCes fonctions font partie de l\u0026rsquo;API des syscall du kernel Linux, et dans ce cas, elles sont hookÃ©es ou utilisÃ©es pour rediriger des appels.\nRÃ©ponse : __x64_sys_kill\nQuestion 11 # Quel numÃ©ro de signal est utilisÃ© pour masquer le PID d\u0026rsquo;un processus en cours d\u0026rsquo;exÃ©cution lors de l\u0026rsquo;envoi ?\nOn va donc aller voir la fonction hook_kill :\nCe qui retient immÃ©diatement notre attention est :\ncmp dword ptr [rdi+68h], 64 ainsi que le hide_pid.\nAllons voir le pseudocode gÃ©nÃ©rÃ© par IDA :\nif ( (*(DWORD *)(a1 + 104)) != 64 ) return ((__int64 (*) (void))orig_kill()); a1 + 104 : cela accÃ¨de au signal envoyÃ© avec l\u0026rsquo;appel kill(). Le champ Ã  l\u0026rsquo;adresse a1 + 104 correspond donc au signal.\n(*(DWORD *)(a1 + 104)) != 64 : cette condition vÃ©rifie si le signal n\u0026rsquo;est pas Ã©gal Ã  64.\nSi le signal n\u0026rsquo;est pas Ã©gal Ã  64, la fonction exÃ©cute la fonction orig_kill (l\u0026rsquo;originale, avant le hook) pour continuer l\u0026rsquo;exÃ©cution normale du kernel.\nSinon il fait appel Ã  hide_pid :\nsprintf(hide_pid, \u0026#34;%d\u0026#34;, *((QWORD *)(a1 + 112))); sprintf(hide_pid, \u0026quot;%d\u0026quot;, ...) : la fonction sprintf est utilisÃ©e ici pour formater et passer le PID dans la fonction hide_pid. On comprend donc que ce PID est utilisÃ© par la fonction hide_pid afin de dissimuler le processus au niveau du systÃ¨me, par exemple en supprimant ses entrÃ©es dans /proc ou dans d\u0026rsquo;autres structures internes du kernel.\nhide_pid : est la fonction pour cacher un processus, empÃªchant ainsi sa visibilitÃ©.\n%d : C\u0026rsquo;est un format pour afficher l\u0026rsquo;entier (le PID).\nRÃ©ponse : 64\nLab terminÃ© !\n","date":"20 avril 2025","externalUrl":null,"permalink":"/blog-cyber/posts/aptnightmare2/","section":"Posts","summary":"ScÃ©nario # Ã€ l\u0026rsquo;issue du processus de rÃ©cupÃ©ration du serveur, l\u0026rsquo;Ã©quipe IR a mis en Ã©vidence un rÃ©seau complexe de trafic persistant, de communications furtives et de processus tenaces ayant rÃ©sistÃ© Ã  nos tentatives d\u0026rsquo;arrÃªt.","title":"APTNightmare-2","type":"posts"},{"content":"","date":"20 avril 2025","externalUrl":null,"permalink":"/blog-cyber/tags/linux/","section":"Tags","summary":"","title":"Linux","type":"tags"},{"content":" ScÃ©nario # Le 28 juin, notre client a dÃ©tectÃ© des sessions RDP non autorisÃ©es, sans dÃ©ploiement de PAM, dans leur environnement. Ils ont rÃ©cupÃ©rÃ© des preuves sur un serveur quâ€™ils suspectaient de servir de pivot pour un mouvement latÃ©ral vers dâ€™autres cibles. MÃªme si lâ€™attaquant a supprimÃ© les events log, je pense que les quelques artefacts restants suffisent Ã  confirmer le dÃ©roulement de lâ€™attaque et Ã  retracer le comportement de lâ€™assaillant.\nSetup # Pour ce Sherlock nous allons utiliser :\nZimmerman Tools (EvtxECmd, Registry Explorer, Timeline Explorer, PECmd, WxTCmd\u0026hellip;) Impacket (secretsdump.py) NirSoft DataProtectionDecryptor ANSSI BMC-tools BSI-Bund RdpCacheStitcher On va aussi s\u0026rsquo;appuyer sur des cheatsheets tels que celle de la FOR500 de SANS et celle portant sur les registres windows de 13Cubed :\nhttps://13cubed.s3.amazonaws.com/downloads/windows_registry_cheat_sheet.pdf\nQuestion 1 # Quand a eu lieu la derniÃ¨re tentative de connexion Ã©chouÃ©e utilisant l\u0026rsquo;utilisateur emman.t ? (UTC)\nPremiÃ¨rement on va vÃ©rifier si, comme le scÃ©nario l\u0026rsquo;explique, les events logs ont bien Ã©tÃ© effacÃ©s. Pour cela, nous allons utiliser les tools de Zimmerman EvtxECmd et Timeline Explorer afin de rÃ©pondre Ã  cette question.\nEvtxECmd.exe -d \u0026#34;C:/C___NONAME [NTFS]\\[root]\\Windows\\System32\\winevt\\Logs\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; On recherche l\u0026rsquo;ID 4625 (Account failed to log on), mais RAS.\nEt effectivement on voit bien que les logs ont Ã©tÃ© effacÃ©s :\nIl nous reste cependant une chance de les retrouver si on dispose de VSS (Volume Shadow Copy).\nLe (VSS) est une fonctionnalitÃ© Windows qui crÃ©e des snapshots de lâ€™Ã©tat dâ€™un disque Ã  un moment donnÃ©. Si des VSS sont disponibles, on peut retrouver des versions antÃ©rieures de fichiers supprimÃ©s ou altÃ©rÃ©s, y compris les events log. Donc, mÃªme si un attaquant a effacÃ© les logs sur la machine en live, il est parfois possible de rÃ©cupÃ©rer ceux qui existaient au moment oÃ¹ le snapshot VSS a Ã©tÃ© crÃ©Ã©.\nMalheureusement, aprÃ¨s vÃ©rification, on n\u0026rsquo;a pas de VSS. On est donc obligÃ© de se rediriger sur les Registry.\nPour Ã§a nous allons utiliser un autre outil de Zimmerman, Registry Explorer.\nOn va aller voir du cÃ´tÃ© de la registry hive SAM. En effet, on pourra y retrouver des artÃ©facts dans SAM\\Domains\\Account\\Users tels que :\nlast login time last incorrect password last password change login counts group membership account creation time etc. Pour cela, on va charger le fichier C___NONAME [NTFS]\\[root]\\Windows\\System32\\config\\SAM dans Registry Explorer :\nEt effectivement on retrouve le \u0026ldquo;Last Incorrect Password\u0026rdquo;\nRÃ©ponse : 2024-06-26 07:24:35\nQuestion 2 # Quelles sont les 3 premiÃ¨res adresses IP auxquelles emman.t s\u0026rsquo;est connectÃ© via Remote Desktop (RDP) ?\nPour rÃ©pondre Ã  cette question on va aller regarder du cÃ´tÃ© du NTUSER.dat. C\u0026rsquo;est la registry hive situÃ©e dans le dossier de profil de l\u0026rsquo;utilisateur, il contient toutes les configurations personnelles et le prÃ©fÃ©rences de l\u0026rsquo;environnement de bureau.\nLorsqu\u0026rsquo;un utilisateur se connecte, ce fichier est chargÃ© pour appliquer ses paramÃ¨tres spÃ©cifiques (les paramÃ¨tres d\u0026rsquo;application, l\u0026rsquo;historique des activitÃ©s, etc.).\nOn va particuliÃ¨rement porter notre attention sur HKEY_CURRENT_USER\\Software\\Microsoft\\Terminal Server Client car c\u0026rsquo;est ici que sont stockÃ©s les paramÃ¨tres RDP et la liste des serveurs auxquels l\u0026rsquo;utilisateur s\u0026rsquo;est connectÃ© via RDP.\nOn charge donc le fichier NTUSER.dat de l\u0026rsquo;utilisateur en question dans Registry Explorer et on se rend au chemin voulu :\nRÃ©ponse : 192.168.86.250,192.168.25.128,192.168.25.131\nQuestion 3 # Quel est le nom d\u0026rsquo;utilisateur de destination utilisÃ© pour se connecter en Remote Desktop pour la premiÃ¨re fois le 2024-06-20 Ã  16:01:05 UTC ?\nOn a dÃ©jÃ  la rÃ©ponse sur le screen de la question 2.\nRÃ©ponse : tommyxiaomi\nQuestion 4 # Quelle est l\u0026rsquo;adresse IP de destination de la derniÃ¨re session Remote Desktop (RDP) ?\nIdem.\nRÃ©ponse : 192.168.70.133\nQuestion 5 # emman.t est trÃ¨s nÃ©gligent en sauvegardant systÃ©matiquement ses identifiants RDP pour se connecter Ã  d\u0026rsquo;autres hÃ´tes, ce qui laisse penser que l\u0026rsquo;attaquant les a, d\u0026rsquo;une maniÃ¨re ou d\u0026rsquo;une autre, divulguÃ©s. Pouvez-vous confirmer les identifiants divulguÃ©s du serveur avec l\u0026rsquo;IP 192.168.70.133 ?\nCette question est un petit dÃ©fi trÃ¨s intÃ©ressant.\nPremiÃ¨rement, allons droit au but, oÃ¹ pouvons-nous trouver les credentials RDP ? Lorsqu\u0026rsquo;on se connecte en RDP via l\u0026rsquo;application de Microsoft par dÃ©faut, l\u0026rsquo;app nous propose de sauvegarder les credentials :\nPour stocker ces credentials, Windows utilise le systÃ¨me de Credential Manager pour gÃ©rer et stocker de maniÃ¨re \u0026ldquo;sÃ©curisÃ©e\u0026rdquo;. Lorsque lâ€™utilisateur sauvegarde ses identifiants lors dâ€™une connexion RDP, ces credentials sont enregistrÃ©s dans le dossier spÃ©cifique de lâ€™utilisateur, ici situÃ© Ã  C:\\Users\\emman.t\\AppData\\Local\\Microsoft\\Credentials.\nCredential Manager s\u0026rsquo;appuie sur la DPAPI (Data Protection API) afin de chiffrer les informations d\u0026rsquo;authentifications. L\u0026rsquo;API est trÃ¨s straightforward :\nDPAPI_IMP BOOL CryptProtectData( [in] DATA_BLOB *pDataIn, [in, optional] LPCWSTR szDataDescr, [in, optional] DATA_BLOB *pOptionalEntropy, [in] PVOID pvReserved, [in, optional] CRYPTPROTECT_PROMPTSTRUCT *pPromptStruct, [in] DWORD dwFlags, [out] DATA_BLOB *pDataOut ); Cette API est largement utilisÃ©e par Microsoft et d\u0026rsquo;autres applications telles que Chrome, Edge etc. afin de stocker des mots de passe et autres secrets en tout genre.\nDPAPI fonctionne en utilisant des clÃ©s appelÃ©es masterkeys. Ces masterkeys servent Ã  chiffrer les donnÃ©es protÃ©gÃ©es par DPAPI. Chaque masterkey est elle-mÃªme chiffrÃ©e Ã  l\u0026rsquo;aide d\u0026rsquo;un dÃ©rivÃ© du mot de passe de l\u0026rsquo;utilisateur ou de la clÃ© systÃ¨me DPAPI.\nCes masterkeys sont stockÃ©es dans :\nPour l\u0026rsquo;utilisateur : C:\\Users\\\u0026lt;user\u0026gt;\\AppData\\Roaming\\Microsoft\\Protect\\\u0026lt;SID\u0026gt; Pour le systÃ¨me : C:\\Windows\\System32\\Microsoft\\Protect\\S-1-5-18 Ces masterkeys :\nsont renouvelÃ©s automatiquement tous les 3 mois ou aprÃ¨s un changement de mot de passe utilisateur. mise en cache (stockage temporaire en clair) dans le processus LSASS (trÃ¨s utile memory forensic ou alors en pentest) Voici comment fonctionne le mÃ©canisme DPAPI :\nAu centre, on retrouve la masterkey qui est la clÃ© principale utilisÃ©e par DPAPI pour chiffrer et dÃ©chiffrer des secrets.\nCette Masterkey est elle-mÃªme chiffrÃ©e et protÃ©gÃ©e. Selon la situation, elle peut Ãªtre dÃ©chiffrÃ©e Ã  partir de diffÃ©rentes clÃ©s : - Le NT hash du mot de passe utilisateur d\u0026rsquo;un compte de domaine. - Le hash SHA1 du mot de passe dâ€™un compte utilisateur local. - Une clÃ© machine nommÃ©e Domain Backup Key, spÃ©cifique aux environnements Active Directory, permettant de dÃ©chiffrer les masterkeys sans avoir le mot de passe utilisateur, si lâ€™on possÃ¨de les droits suffisants.\nUne fois la Masterkey dÃ©chiffrÃ©e grÃ¢ce Ã  l\u0026rsquo;une de ces clÃ©s, elle permet de dÃ©river une clÃ© de session (Session Key), qui est directement utilisÃ©e pour chiffrer ou dÃ©chiffrer les donnÃ©es protÃ©gÃ©es par DPAPI.\nPour dÃ©chiffrer des donnÃ©es protÃ©gÃ©es par DPAPI on peut s\u0026rsquo;aider de pas mal de tool :\nutilisable sur un live system : LaZagne pypykatzÂ - dpapi module mimikatz SharpDPAPI offline aprÃ¨s avoir rÃ©cupÃ©rÃ© les fichiers nÃ©cessaires : pypykatzÂ - dpapi module dpapi.pyÂ -Â impacket mimikatz SharpDPAPI dpapilab-ng diana Si vous souhaitez rentrer davantage dans les dÃ©tails de la DPAPI, je vous invite Ã  lire cette publication de Synacktiv (l\u0026rsquo;explication ci-dessus est basÃ© sur le post): https://www.synacktiv.com/publications/windows-secrets-extraction-a-summary\nMaintenant qu\u0026rsquo;on sait tout Ã§a, comment peut-on l\u0026rsquo;appliquer Ã  notre situation ? Ici j\u0026rsquo;ai souhaitÃ© partir sur :\nImpacket (secretsdump.py) NirSoft DataProtectionDecryptor Le script secretsdump.py va nous permettre de rÃ©cupÃ©rer le mot de passe de l\u0026rsquo;utilisateur en question afin de pouvoir dÃ©chiffrer les secrets DPAPI :\nsecretsdump.py -sam \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SAM\u0026#34; --security \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SECURITY\u0026#34; --system \u0026#34;C:\\C___NONAME [NTFS]\\[root]\\Windows\\System32\\SYSTEM\u0026#34; LOCAL Parfait, on a rÃ©cupÃ©rÃ© le hash du mot de passe de l\u0026rsquo;utilisateur en question, on peut ensuite le bruteforce :\nMaintenant qu\u0026rsquo;on a son mot de passe on peut dÃ©chiffrer les credentials via l\u0026rsquo;outil DataProtectionDecryptor :\nIl existe aussi une faÃ§on non intentionnel de trouver le mot de passe du user :\nEffectivement, si on va dans l\u0026rsquo;historique des commandes powershell, on peut retrouver le moment ou le crÃ©ateur du challenge a crÃ©Ã© les users :\nRÃ©ponse : Administrator:C@mv@0s3rv3r\nQuestion 6 # Quand l\u0026rsquo;application Remote Desktop Connection a-t-elle Ã©tÃ© exÃ©cutÃ©e pour la derniÃ¨re fois ? (UTC)\nPour rÃ©pondre Ã  cette question on va se pencher sur les artÃ©facts Prefetch.\nLe Prefetch est un mÃ©canisme conÃ§u pour accÃ©lÃ©rer le lancement des applications couramment utilisÃ©es en conservant certaines donnÃ©es relatives aux exÃ©cutions prÃ©cÃ©dentes. Windows stocke ces informations sous forme de fichiers .pf dans le dossier suivant C:\\Windows\\Prefetch\\.\nChaque fichier .pf contient notamment :\nle nom de lâ€™exÃ©cutable le nombre de fois oÃ¹ l\u0026rsquo;application a Ã©tÃ© lancÃ©e les timestamps de derniÃ¨re exÃ©cution les chemins vers les fichiers associÃ©s et bibliothÃ¨ques chargÃ©es durant le dÃ©marrage du processus Dans le cas d\u0026rsquo;une connexion RDP, lâ€™exÃ©cutable utilisÃ© est gÃ©nÃ©ralement MSTSC.EXE. Lâ€™analyse du fichier Prefetch associÃ© (MSTSC.EXE-XXXXXX.pf) permet ainsi de vÃ©rifier si une connexion RDP a Ã©tÃ© Ã©tablie depuis cette machine, ainsi que le moment prÃ©cis de son lancement.\nPour les charger dans Timeline Explorer on doit les parser, pour cela on va utiliser PECmd :\nPECmd.exe -d \u0026#34;C:\\___NONAME [NTFS]\\[root]\\Windows\\Prefetch\u0026#34; --csv \u0026#34;C:\\Users\\username\\Desktop\\HTB\\latus\u0026#34; Et effectivement on retrouve les informations de lancement de MSTSC.exe :\nRÃ©ponse : 2024-06-28 13:56:48\nQuestion 7 # Quand l\u0026rsquo;application Remote Desktop Connection a-t-elle Ã©tÃ© fermÃ©e pour la derniÃ¨re fois ? (UTC)\nPremiÃ¨rement on va chercher du cÃ´tÃ© du UserAssist (dans la registry hive NTUSER.dat) se situant : NTUSER.DAT\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist\\.\nCette clÃ© conserve lâ€™historique dâ€™utilisation des applications exÃ©cutÃ©es par lâ€™utilisateur notamment :\nle nombre dâ€™exÃ©cutions dâ€™un programme le moment prÃ©cis de la derniÃ¨re exÃ©cution de l\u0026rsquo;application le moment prÃ©cis oÃ¹ l\u0026rsquo;application a Ã©tÃ© fermÃ©e ou terminÃ©e (dernier arrÃªt du processus) Ces informations sont stockÃ©es dans des sous-clÃ©s encodÃ©es via ROT13 mais heureusement Registry Explorer nous rend tout cela lisible :\nMais ce qui nous choque en premier c\u0026rsquo;est la diffÃ©rence entre la valeur \u0026ldquo;Last Executed\u0026rdquo; contenu dans le UserAssist et la \u0026ldquo;Last Run\u0026rdquo; dans le Prefetch.\nPourquoi cette divergence entre Prefetch et UserAssist ?\nPrefetch (.pf) : Enregistre les exÃ©cutions directement au niveau du processus (mstsc.exe). Le compteur augmente Ã  chaque chargement du processus en mÃ©moire, peu importe comment il est dÃ©marrÃ©. UserAssist (registre) : Enregistre uniquement les exÃ©cutions effectuÃ©es par interaction directe de lâ€™utilisateur (ex : clic sur lâ€™icÃ´ne, menu DÃ©marrer, barre de recherche, raccourci). Ne comptabilise pas nÃ©cessairement les exÃ©cutions indirectes (exÃ©cution via ligne de commande, exÃ©cution automatique, scripts, etc.). Donc on fait fausse route ici.\nOn peut alors se pencher sur la clÃ© BAM (HKLM\\SYSTEM\\CurrentControlSet\\Services\\bam\\UserSettings\\) qui enregistre explicitement la durÃ©e de vie des applications.\nEn effet, BAM maintient pour chaque exÃ©cutable un historique prÃ©cis comprenant :\nle dernier moment dâ€™exÃ©cution (lancement de lâ€™application) le moment prÃ©cis de fermeture (terminaison du processus) Vous pouvez retrouver plus d\u0026rsquo;informations sur les artÃ©facts RDP ici : https://www.thedfirspot.com/post/lateral-movement-remote-desktop-protocol-rdp-artifacts\nRÃ©ponse : 2024-06-28 14:01:26\nQuestion 8 # Quelle a Ã©tÃ© la durÃ©e de l\u0026rsquo;avant-derniÃ¨re session RDP ?\nPour rÃ©pondre Ã  cette question on va se pencher sur l\u0026rsquo;ActivitiesCache.db :\nAprÃ¨s l\u0026rsquo;avoir chargÃ© dans Timeline Explorer on voit bien les diffÃ©rentes \u0026ldquo;duration\u0026rdquo; des sessions RDP :\nPour une raison inconnue, la rÃ©ponse prend -1 sec.\nRÃ©ponse : 00:11:42\nQuestion 9 # Quand l\u0026rsquo;attaquant a-t-il dÃ©connectÃ© la derniÃ¨re session Remote Desktop (RDP) ? (UTC)\nPour cela on va aller voir le fichier \u0026ldquo;Default.rdp\u0026rdquo; contenu dans le ...\\Documents\\ de l\u0026rsquo;utilisateur. En effet, ce fichier est gÃ©nÃ©rÃ© automatiquement par Windows lorsqu\u0026rsquo;une connexion RDP est Ã©tablie via l\u0026rsquo;application MSTSC.\nOn peut y retrouver :\nl\u0026rsquo;adresse IP ou nom du serveur utilisÃ© lors de la derniÃ¨re connexion RDP le nom dâ€™utilisateur ayant Ã©tÃ© utilisÃ© pour la connexion le paramÃ¨tres graphiques (rÃ©solution, couleurs, etc.) l\u0026rsquo;options de partage des pÃ©riphÃ©riques locaux (presse-papiers, disques locaux, imprimantes, etc.) les paramÃ¨tres de performances (qualitÃ© graphique, compression, etc.). Mais on peut aussi voir quand est-ce que le fichier a Ã©tÃ© modifiÃ© pour la derniÃ¨re fois :\nRÃ©ponse : 2024-06-28 13:51:03\nQuestion 10 # Quelle est la taille du bureau Ã  distance configurÃ© ?\nOn retourne sur le fichier Default.rdp et on y retrouve :\nRÃ©ponse : 1920:1080\nQuestion 11 # Quel outil l\u0026rsquo;attaquant a-t-il utilisÃ© pour explorer le rÃ©seau aprÃ¨s s\u0026rsquo;Ãªtre dÃ©placÃ© latÃ©ralement vers 192.168.70.133 ?\nPour rÃ©pondre Ã  cette question on va devoir chercher du cÃ´tÃ© du cache bitmap RDP.\nLors de lâ€™analyse des sessions utilisant le protocole RDP (Remote Desktop Protocol) sous Windows, le cache bitmap RDP constitue un artefact souvent nÃ©gligÃ©, mais pourtant trÃ¨s pertinent en forensic.\nCe cache permet d\u0026rsquo;amÃ©liorer les performances des sessions RDP en stockant localement des sections d\u0026rsquo;Ã©cran dÃ©jÃ  affichÃ©es. Ainsi, lorsqu\u0026rsquo;une partie de l\u0026rsquo;Ã©cran reste statique, le systÃ¨me peut rapidement rÃ©cupÃ©rer l\u0026rsquo;image en mÃ©moire locale plutÃ´t que de la recharger Ã  distance, ce qui fluidifie l\u0026rsquo;expÃ©rience utilisateur.\nD\u0026rsquo;un point de vue forensic, ce cache peut reprÃ©senter une source prÃ©cieuse d\u0026rsquo;informations. En effet, l\u0026rsquo;analyse des fichiers du cache bitmap peut rÃ©vÃ©ler des dÃ©tails sensibles sur les activitÃ©s de l\u0026rsquo;utilisateur, telles que les fenÃªtres ouvertes, les contenus affichÃ©s ou les actions rÃ©alisÃ©es pendant la session RDP.\nSi vous voulez plus d\u0026rsquo;informations je vous invite Ã  lire le post : https://www.cyberengage.org/post/analyzing-and-extracting-bitmap-cache-files-from-rdp-sessions.\nOn retrouve ces fichiers ici C:\\Users\\user\\AppData\\Local\\Microsoft\\Terminal Server Client\\Cache\\.\nPour les parser \u0026amp; exporter on va utiliser le tool de l\u0026rsquo;ANSSI \u0026ldquo;BMC-Tools\u0026rdquo;.\nEnsuite, on va utiliser le tool de la BSI Bund \u0026ldquo;RdpCacheStitcher\u0026rdquo; pour les analyser :\nEn reconstruisant, on voit donc bien que l\u0026rsquo;attaquant a utilisÃ© \u0026ldquo;NetBScanner\u0026rdquo; pour scanner le rÃ©seau.\nRÃ©ponse : NetBScanner\nQuestion 12 # Quand l\u0026rsquo;attaquant a-t-il supprimÃ© le journal des Ã©vÃ©nements ? (UTC)\nOn revient sur ce qu\u0026rsquo;on avait trouvÃ© lors de la question 1 :\nRÃ©ponse : 2024-06-28 14:03:25\nQuestion 13 # Ã€ quelle heure l\u0026rsquo;attaquant a-t-il dÃ©connectÃ© la session vers 192.168.70.129 ? (UTC)\nSi on regarde juste aprÃ¨s l\u0026rsquo;effacement des events log, on voit bien un \u0026ldquo;An account was logged off\u0026rdquo; :\nRÃ©ponse : 2024-06-28 14:03:53\nLab terminÃ© !\n","date":"10 mars 2025","externalUrl":null,"permalink":"/blog-cyber/posts/latus/","section":"Posts","summary":"ScÃ©nario # Le 28 juin, notre client a dÃ©tectÃ© des sessions RDP non autorisÃ©es, sans dÃ©ploiement de PAM, dans leur environnement.","title":"Latus","type":"posts"},{"content":"","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/tags/cyberdefenders/","section":"Tags","summary":"","title":"Cyberdefenders","type":"tags"},{"content":" ScÃ©nario # Un employÃ© informatique dâ€™InfiniTech Solutions a signalÃ© une activitÃ© inhabituelle associÃ©e Ã  son compte e-mail. Lors de lâ€™investigation, il a Ã©tÃ© dÃ©couvert que les identifiants professionnels de lâ€™employÃ© avaient Ã©tÃ© divulguÃ©s lors dâ€™une rÃ©cente fuite de donnÃ©es.\nLâ€™employÃ© avait utilisÃ© son adresse mail professionnelle pour sâ€™inscrire sur une plateforme tierce, ce qui a exposÃ© ses identifiants. Des acteurs malveillants ont exploitÃ© ces identifiants pour se connecter au compte mail de lâ€™employÃ© et envoyer des e-mails de phishing Ã  dâ€™autres employÃ©s de lâ€™organisation.\nVotre tÃ¢che est dâ€™enquÃªter sur cet incident en analysant les logs, en dÃ©terminant lâ€™Ã©tendue de lâ€™attaque, en identifiant si des utilisateurs ont interagi avec les mails de phishing, et en dÃ©couvrant lâ€™impact de la campagne de phishing sur le rÃ©seau.\nSetup # Pour ce scÃ©nario d\u0026rsquo;investigation, nous allons principalement utiliser Splunk Search pour analyser les logs. En complÃ©ment, nous utiliserons dâ€™autres outils tels que xml.onlineviewer, Cyberchef ainsi que VirusTotal.\nRappels # Splunk est une plateforme dâ€™analyse qui permet de collecter, indexer et rechercher des donnÃ©es gÃ©nÃ©rÃ©es par des systÃ¨mes, applications et Ã©quipements rÃ©seau. Il rÃ©cupÃ¨re ses logs via divers mÃ©canismes tels que des agents installÃ©s sur les endpoints, lâ€™ingestion de fichiers de logs ou encore des API.\nUne fois collectÃ©es, les donnÃ©es sont indexÃ©es, ce qui permet de les organiser et de faciliter la recherche. Splunk utilise le langage de recherche SPL (Search Processing Language) pour interroger ces donnÃ©es.\nInitial Access # Question 1 # Quel compte de messagerie a Ã©tÃ© compromis et utilisÃ© pour lancer l\u0026rsquo;attaque ?\nPremiÃ¨rement, vÃ©rifions les \u0026ldquo;sourcetype\u0026rdquo; disponibles sur notre\nindex=\u0026#34;main\u0026#34; | stats count by sourcetype Les sourcetypes dans Splunk sont des Ã©tiquettes qui indiquent le type de donnÃ©es ou l\u0026rsquo;origine des Ã©vÃ©nements collectÃ©s.\nPour rÃ©pondre Ã  cette question, on va se focus sur les \u0026ldquo;syslog\u0026rdquo; premiÃ¨rement. En effet, les syslog regroupent les logs gÃ©nÃ©rÃ©s par divers Ã©quipements et contiennent gÃ©nÃ©ralement des informations dÃ©taillÃ©es sur les activitÃ©s systÃ¨me et de sÃ©curitÃ©.\nPour aller plus vite et Ã©viter de s\u0026rsquo;inonder d\u0026rsquo;informations, on va chercher avec un regex pour uniquement afficher les adresses mails :\n* sourcetype=syslog | regex _raw=\u0026#34;[\\w\\.-]+@[\\w\\.-]+\\.\\w+\u0026#34; On voit beaucoup de logs, pour nous faciliter la tÃ¢che, on va compter combien de fois chaque adresse mail apparaÃ®t et afficher les rÃ©sultats sous forme de tableau :\n* sourcetype=syslog | rex field=_raw \u0026#34;(?\u0026lt;email\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | stats count by email | sort -count | head 10 | rename count AS \u0026#34;Number of occurrences\u0026#34;, email AS \u0026#34;Email address\u0026#34; On peut mÃªme visualiser Ã§a sous forme de graphique :\nRÃ©ponse : twhite@infinitechsolutions.xyz\nQuestion 2 # AprÃ¨s avoir identifiÃ© le compte compromis, l\u0026rsquo;attaquant a envoyÃ© des mails de phishing Ã  d\u0026rsquo;autres employÃ©s de l\u0026rsquo;entreprise. Quels sont les noms de ces employÃ©s, classÃ©s par ordre chronologique et sÃ©parÃ©s par des virgules ?\nLe formatage de log d\u0026rsquo;envoi de mail est comme cela :\nUser [email_expÃ©diteur] [adresse_IP]; Message [ID_message] for [email_destinataire] Pour la recherche on va donc faire :\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | rex field=_raw \u0026#34;Message \u0026lt;[^\u0026gt;]+\u0026gt; for (?\u0026lt;recipient\u0026gt;[\\w\\.-]+@[\\w\\.-]+\\.\\w+)\u0026#34; | table _time recipient | sort _time | stats list(recipient) as recipients | eval recipients=mvjoin(recipients, \u0026#34;, \u0026#34;) Cette requÃªte nous permet d\u0026rsquo;identifier et lister chronologiquement les destinataires en question.\nEn effet, on y sÃ©lectionne le user du compte compromis et on utilise un regex pour extraire et stocker dans une variable l\u0026rsquo;adresse mail du destinataire.\nEnsuite, on trie les rÃ©sultats par ordre chronologique et on format le rÃ©sultat pour que Ã§a soit bien lisible.\nRÃ©ponse : rnichols,llopez,gbaker,ahall\nQuestion 3 # Quel est le nom de la piÃ¨ce jointe malveillante envoyÃ©e depuis le compte compromis ?\nCette question m\u0026rsquo;a posÃ© plus de problÃ¨me que ce que Ã  quoi je m\u0026rsquo;attendais. En effet, premiÃ¨rement j\u0026rsquo;ai cherchÃ© :\n* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; | regex _raw=\u0026#34;for (rnichols|llopez|gbaker|ahall)@infinitechsolutions\\.xyz\u0026#34; NÃ©anmoins aucune trace de piÃ¨ce jointe. Je me suis donc dit \u0026ldquo;mhmm je ne dois pas Ãªtre sur le bon sourcetype, je vais rechercher les autres.\u0026rdquo;\nJ\u0026rsquo;ai donc recherchÃ© :\nindex=* \u0026#34;twhite@infinitechsolutions.xyz\u0026#34; | stats count by sourcetype Uniquement syslog, je suis donc sur le bon sourcetype. Je continue donc Ã  rÃ©flÃ©chir et je me dis \u0026ldquo;je vais bypass le problÃ¨me de formatage et simplement chercher des extensions de fichier\u0026rdquo;\nJe demande donc Ã  ChatGPT de me faire une liste d\u0026rsquo;extension et je me retrouve avec cette requÃªte :\nindex=* sourcetype=syslog twhite@infinitechsolutions.xyz | rex field=_raw \u0026#34;attachment=(?\u0026lt;malicious_attachment\u0026gt;[\\w\\.-]+\\.(exe|zip|pdf|docx|xlsm|js|vbs|scr|bat))\u0026#34; | table _time malicious_attachment | sort _time Toujours rien, pas de piÃ¨ce jointe.\nÃ‰tant toujours bloquÃ©, j\u0026rsquo;ai dÃ©cidÃ© de rÃ©flÃ©chir diffÃ©remment. Le titre du lab est \u0026ldquo;Midnight RDP\u0026rdquo;, ce qui me fait penser Ã  l\u0026rsquo;APT nommÃ©e \u0026ldquo;Midnight Blizzard\u0026rdquo;.\nDans mes recherches, je suis tombÃ© sur un article intitulÃ© \u0026ldquo;How Midnight Blizzard Uses Malicious .RDP Files to Exploit Windows Systems: A Technical Guide\u0026rdquo; (Yua Mikanana).\nBon, au vu du nom du lab, c\u0026rsquo;est Ã©vident. Je cherche donc \u0026ldquo;.RDP\u0026rdquo; et j\u0026rsquo;obtiens le fichier :\nRÃ©ponse : cloud zerotrust compliance.rdp\nExecution # Question 1 # AprÃ¨s avoir analysÃ© les interactions des utilisateurs, quel employÃ© a tÃ©lÃ©chargÃ© et exÃ©cutÃ© la piÃ¨ce jointe malveillante ?\nOn change de sourcetype, on passe sur les WinEventLog.\nLes WinEventLog correspondent aux journaux d\u0026rsquo;Ã©vÃ©nements de Windows, qui enregistrent diverses activitÃ©s du systÃ¨me (comme les erreurs, les avertissements, les informations de sÃ©curitÃ© ou les activitÃ©s applicatives) pour permettre un suivi et une analyse des Ã©vÃ©nements sur un systÃ¨me Windows.\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; cloud zerotrust compliance.rdp On voit donc bien le username de l\u0026rsquo;utilisateur qui a tÃ©lÃ©chargÃ© ce fichier : C:\\Users\\rnichols\\Downloads\\cloud zerotrust compliance.rdp\nRÃ©ponse : rnichols\nQuestion 2 # Sur la machine DC, une balise DLL a Ã©tÃ© exÃ©cutÃ©e par l\u0026rsquo;attaquant en mÃ©moire. Quels sont les 10 premiers octets du hachage SHA-256 de ce fichier DLL malveillant ?\nPremiÃ¨rement, listons les DLL ayant un lien avec PowerShell sur le DC :\nindex=* sourcetype=xmlwineventlog \u0026#34;Powershell\u0026#34; | search host=\u0026#34;DC01\u0026#34; | rex field=_raw \u0026#34;(?\u0026lt;file\u0026gt;\\b\\w{6,8}\\.\\w{3}\\b)\u0026#34; | search file=\u0026#34;*dll\u0026#34; On remarque que le script complet est trop long pour Ãªtre enregistrÃ© en un seul Ã©vÃ©nement. Il est donc dÃ©coupÃ© en segments. On peut le voir grÃ¢ce au MessageNumber :\nLes deux Ã©vÃ©nements partagent le mÃªme ActivityID {0B39225B-3C43-0001-5078-390B433CDB01} ainsi que dâ€™autres identifiants, ce qui montre quâ€™ils appartiennent Ã  la mÃªme exÃ©cution de script.\nLe premier segment (MessageNumber = 1) contient le dÃ©but du script, incluant la configuration de lâ€™environnement PowerShell et la dÃ©finition de fonctions telles que func_get_proc_address et func_get_delegate_type.\nLe dernier segment (MessageNumber = 33) contient la fin du script, notamment la partie qui effectue le dÃ©codage dâ€™une chaÃ®ne Base64 (XORÃ©e avec la clÃ© 35) et qui alloue de la mÃ©moire pour exÃ©cuter le code dÃ©codÃ©.\nEnsemble, ces segments reconstituent lâ€™intÃ©gralitÃ© dâ€™un payload qui cherche vraisemblablement Ã  injecter et exÃ©cuter du code en mÃ©moire.\nLe script, une fois reconstituÃ©, dÃ©code un payload obfusquÃ© (dâ€™abord en Base64, puis XORÃ© avec 35) et utilise des fonctions Windows natives (comme VirtualAlloc via GetProcAddress et GetDelegateForFunctionPointer) pour allouer de la mÃ©moire et exÃ©cuter le code malveillant.\n[...] $var [...] -bxor 35 [...] On peut le reconstituer via une recherche Splunk :\nindex=* sourcetype=xmlwineventlog EventID=4104 0B39225B-3C43-0001-5078-390B433CDB01 | stats values(ScriptBlockText) as Script by SystemTime | table Script On peut ensuite dÃ©sencoder le script via Cyberchef :\nOn retrouve notre DLL en question :\nEnfin, on extrait le fichier et on rÃ©cupÃ¨re son hash :\nRÃ©ponse : 0ee6bc20a7f855d881cce962de09c77960ea5c85ca013e3d123fce61109ff8c5\nPersistence # Question 1 # AprÃ¨s l\u0026rsquo;Ã©tablissement de la connexion malveillante, un fichier a Ã©tÃ© dÃ©posÃ© sur le systÃ¨me. Quel est le nom de ce fichier dÃ©posÃ© ?\nOn sait que le fichier .rdp a Ã©tÃ© exÃ©cutÃ© vers 20:45:27 (cf. question 1 de la partie Execution).\nOn va donc chercher Ã  partir de ce moment-lÃ .\nPremiÃ¨rement, j\u0026rsquo;ai tentÃ© de rechercher dans Splunk des tÃ©lÃ©chargements via des commandes PowerShell (Invoke-WebRequest, curl, etc.), mais Ã§a n\u0026rsquo;a rien donnÃ©.\nJ\u0026rsquo;ai donc modifiÃ© ma recherche :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort â€” _time Alors pourquoi cela fonctionne ?\nVoici le dÃ©tail de lâ€™Ã©vÃ©nement :\nLe champ TerminalSessionId=3 suggÃ¨re fortement que l\u0026rsquo;utilisateur Ã©tait connectÃ© via une session RDP, car :\nLa session 0 est souvent utilisÃ©e par SYSTEM. Les sessions interactives locales commencent gÃ©nÃ©ralement Ã  1. Les sessions RDP prennent souvent des ID plus Ã©levÃ©s (2, 3, etc.). explorer.exe est le processus principal de lâ€™interface graphique Windows et agit comme un lanceur pour les programmes dÃ©marrÃ©s par un utilisateur interactif.\nScÃ©narios possibles expliquant ce comportement :\nSession interactive (RDP ou non) : Si rnichols s\u0026rsquo;est connectÃ© via RDP, explorer.exe sâ€™est lancÃ© en tant que shell utilisateur et a exÃ©cutÃ© les programmes dÃ©finis dans Startup (ztssvc.exe). Cette situation se produit mÃªme sans RDP si lâ€™utilisateur se connecte physiquement ou via un service comme runas. ExÃ©cution automatique au dÃ©marrage de l\u0026rsquo;utilisateur : ztssvc.exe Ã©tant dans Startup, il est exÃ©cutÃ© dÃ¨s que l\u0026rsquo;utilisateur se connecte (que ce soit en local ou via RDP). Injection ou Persistance via explorer.exe : Si un attaquant a persistÃ© un malware via Startup, explorer.exe va automatiquement exÃ©cuter ce binaire dÃ¨s qu\u0026rsquo;un utilisateur se connecte. Exploit ou ExÃ©cution forcÃ©e par un attaquant : Si explorer.exe a Ã©tÃ© compromis (via injection DLL ou autre technique), il aurait pu Ãªtre utilisÃ© pour exÃ©cuter ztssvc.exe. RÃ©ponse : ztssvc.exe\nQuestion 2 # Pour conserver un accÃ¨s Ã  long terme, l\u0026rsquo;attaquant a crÃ©Ã© une tÃ¢che planifiÃ©e sur la machine compromise. Quel est le nom de cette tÃ¢che ?\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=4698 OR EventCode=4702 | search user=\u0026#34;rnichols\u0026#34; | table _time EventCode TaskName Command User | rename EventCode as \u0026#34;Event ID\u0026#34;, TaskName as \u0026#34;Scheduled Task\u0026#34;, Command as \u0026#34;Executed Command\u0026#34; | sort _time Question 3 # Dans le cadre de sa stratÃ©gie de persistance, l\u0026rsquo;attaquant a crÃ©Ã© un nouveau compte utilisateur. Quel est le nom de ce compte non autorisÃ© ?\nToujours avec la mÃªme requÃªte que pour la question 1 :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort â€” _time On peut y trouver une commande PowerShell encodÃ©e qui paraÃ®t trÃ¨s suspecte :\nOn prend cette commande et on la dÃ©code via Cyberchef :\nRÃ©ponse : Administrator\nQuestion 4 # Pour faciliter l\u0026rsquo;accÃ¨s Ã  distance, l\u0026rsquo;attaquant a modifiÃ© les paramÃ¨tres du bureau Ã  distance. Quel est le nom de la clÃ© de registre qui dÃ©termine si les connexions RDP (Remote Desktop Protocol) sont autorisÃ©es ?\nAyant dÃ©jÃ  investiguÃ© et administrÃ© pas mal de Windows, je connaissais dÃ©jÃ  la rÃ©ponse. NÃ©anmoins, voici comment la trouver :\nOn recherche toujours les commandes PowerShell avec -EncodedCommand, car l\u0026rsquo;attaquant en a exÃ©cutÃ© plusieurs :\nOn y trouve cette commande :\nRÃ©ponse : fDenyTSConnections\nQuestion 5 # Des recherches supplÃ©mentaires ont rÃ©vÃ©lÃ© la crÃ©ation d\u0026rsquo;un nouveau compte d\u0026rsquo;utilisateur sur le DC. Quel est le nom de ce compte ?\nOn peut supposer que cela a Ã©tÃ© fait de la mÃªme maniÃ¨re que sur l\u0026rsquo;autre host. On recherche donc :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; host=\u0026#34;DC01\u0026#34; \u0026#34;-EncodedCommand\u0026#34; RÃ©ponse : rniclos\nPrivilege Escalation # Question 1 # En examinant la technique d\u0026rsquo;escalade de privilÃ¨ge, quels sont les 6 derniers octets du CLSID de l\u0026rsquo;interface COM privilÃ©giÃ©e que l\u0026rsquo;attaquant a exploitÃ©e ?\nLe CLSID est un identifiant unique global (GUID) utilisÃ© par Windows COM (Component Object Model) pour identifier des objets COM dans le registre.\nLes attaquants utilisent des CLSID de COM Interfaces privilÃ©giÃ©es pour exÃ©cuter du code avec des privilÃ¨ges Ã©levÃ©s :\nIls exploitent des COM Objects mal configurÃ©s pour escalader leurs privilÃ¨ges. Un attaquant peut crÃ©er, manipuler ou appeler une interface COM privilÃ©giÃ©e* via regsvr32.exe, powershell, mshta.exe ou rundll32.exe. Ici, on sait que le malware est ztssvc.exe. On va donc rechercher tout EventCode \u0026ldquo;1\u0026rdquo; (crÃ©ation de processus) liÃ© Ã  l\u0026rsquo;exÃ©cution de ztssvc.exe et filtrer uniquement sur les IntegrityLevel \u0026ldquo;High\u0026rdquo; :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; EventCode=1 | search Image=\u0026#34;*ztssvc.exe*\u0026#34; | search IntegrityLevel=\u0026#34;High\u0026#34; | table _time User CommandLine IntegrityLevel ParentCommandLine | sort _time RÃ©ponse : 7CE93B6DC937\nQuestion 2 # Pour Ã©lever ses privilÃ¨ges, l\u0026rsquo;attaquant a dÃ©posÃ© un autre fichier sur le systÃ¨me. Quel est le nom de ce fichier ?\nOn refait la mÃªme commande et on vÃ©rifie tout ce qui s\u0026rsquo;est passÃ© aprÃ¨s le tÃ©lÃ©chargement du premier fichier (ztssvc.exe) :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort â€” _time RÃ©ponse : Akagi64.exe\nDefense Evasion # Question 1 # L\u0026rsquo;attaquant a cherchÃ© Ã  modifier le comportement du systÃ¨me pour affaiblir les paramÃ¨tres de sÃ©curitÃ©. Quel est le nom de la clÃ© de registre qui rÃ©git les paramÃ¨tres de l\u0026rsquo;invite du ContrÃ´le de compte d\u0026rsquo;utilisateur (UAC) pour les utilisateurs administratifs ?\nOn trouve la rÃ©ponse dans les commandes PowerShell encodÃ©es dÃ©jÃ  observÃ©es :\nRÃ©ponse : ConsentPromptBehaviorAdmin\nQuestion 2 # Pour Ã©viter d\u0026rsquo;Ãªtre dÃ©tectÃ©, l\u0026rsquo;attaquant a dÃ©placÃ© la balise dans un rÃ©pertoire protÃ©gÃ© du systÃ¨me. Quel est le nom de ce fichier malveillant dÃ©placÃ© ?\nSâ€™il y a eu dÃ©placement, il devrait y avoir un Ã©vÃ©nement de crÃ©ation ou de renommage de fichier (Event ID 11 ou 2).\nindex=* sourcetype=xmlwineventlog EventCode=11 OR EventCode=2 \u0026#34;rnichols\u0026#34; | search TargetFilename=\u0026#34;C:\\\\Windows\\\\System32\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\Windows\\\\SysWOW64\\\\*\u0026#34; OR TargetFilename=\u0026#34;C:\\\\ProgramData\\\\*\u0026#34; | table _time User TargetFilename ProcessName | sort _time RÃ©ponse : Amazon ZeroTrust Compl.exe\nDiscovery # Question 1 # En dÃ©terminant la premiÃ¨re action de l\u0026rsquo;attaquant sur la machine compromise, quelle a Ã©tÃ© la premiÃ¨re commande exÃ©cutÃ©e pour recueillir des informations sur le systÃ¨me ?\nSachant que la machine a Ã©tÃ© compromise Ã  20:45:27 (cf. question 1 de la partie Execution), on va chercher Ã  partir de ce moment-lÃ  :\nindex=* sourcetype=\u0026#34;xmlwineventlog\u0026#34; \u0026#34;rnichols\u0026#34; | rex field=_raw \u0026#34;CommandLine=(?\u0026lt;CommandLine\u0026gt;.*)\u0026#34; | fillnull value=\u0026#34;\u0026#34; | search NOT CommandLine=\u0026#34;\u0026lt;/Data\u0026gt;\u0026lt;/EventData\u0026gt;\u0026lt;/Event\u0026gt;\u0026#34;,\u0026#34;\u0026#34; | search NOT ParentCommandLine=\u0026#34;\u0026#34; | stats values(CommandLine) as CommandLine by _time, ParentCommandLine | sort â€” _time RÃ©ponse : whoami /groups\nLateral Movement # Question 1 # Quel outil l\u0026rsquo;attaquant a-t-il utilisÃ© pour se dÃ©placer latÃ©ralement vers le DC ?\nEncore une fois, on va devoir investiguer les commandes PowerShell encodÃ©es, cette fois-ci celles Ã©mises par Amazon ZeroTrust Compl.exe.\npowershell -nop -exec bypass -EncodedCommand UwBlAHQALQBJAHQAZQBtACAAVwBTAE0AYQBuADoAXABsAG8AYwBhAGwAaABvAHMAdABcAEMAbABpAGUAbgB0AFwAVAByAHUAcwB0AGUAZABIAG8AcwB0AHMAIAAtAFYAYQBsAHUAZQAgACIARABDADAAMQAuAGEAZAAuAGkAbgBmAGkAbgBpAHQAZQBjAGgAcwBvAGwAdQB0AGkAbwBuAHMALgB4AHkAegAiACAALQBGAG8AcgBjAGUA Cette commande modifie les paramÃ¨tres de Windows Remote Management (WinRM) sur IT01 pour faire confiance Ã  DC01.ad.infinitechsolutions.xyz pour les connexions distantes. Câ€™est un bon indicateur de mouvement latÃ©ral via PowerShell Remoting (WinRM).\nRÃ©ponse : WinRM\nCommand \u0026amp; Control # Question 1 # En remontant le fil des activitÃ©s de l\u0026rsquo;attaquant, quelle Ã©tait l\u0026rsquo;adresse IP Ã  partir de laquelle les courriels malveillants ont Ã©tÃ© envoyÃ©s ?\nOn revient aux toutes premiÃ¨res questions en cherchant le user qui a envoyÃ© le phishing :\nindex=* sourcetype=syslog \u0026#34;User twhite@infinitechsolutions.xyz\u0026#34; RÃ©ponse : 3.78.253.99\nQuestion 2 # Puisque cloud zerotrust compliance.rdp a Ã©tÃ© exÃ©cutÃ© sur IT01 et quâ€™on connaÃ®t lâ€™adresse IP de lâ€™expÃ©diteur de mail, on peut tester directement :\nindex=* sourcetype=xmlwineventlog (EventCode=1 OR EventCode=3) | search host=\u0026#34;IT01\u0026#34; | search DestinationPort=3389 AND DestinationIp=3.78.253.99 | table _time User DestinationIp DestinationPort | sort _time RÃ©ponse : 3.78.253.99:3389\nQuestion 3 # L\u0026rsquo;analyse a rÃ©vÃ©lÃ© que le fichier dÃ©posÃ© fonctionne comme une balise Cobalt Strike. Quel est le point de terminaison du serveur de commande et de contrÃ´le (C\u0026amp;C) avec lequel cette balise communique ?\nPremiÃ¨rement vÃ©rifions bien quel fichier est le Cobalt Strike beacon :\nEnsuite, on continue l\u0026rsquo;investigation en recherchant Ã  quelle IP/port sâ€™est connectÃ© Amazon ZeroTrust Compl.exe :\nindex=* sourcetype=xmlwineventlog EventCode=3 | search Image=\u0026#34;*Amazon ZeroTrust Compl.exe*\u0026#34; | search NOT DestinationIp=\u0026#34;\u0026#34; | table _time User Image DestinationIp DestinationPort Protocol | sort _time (EventCode 3 correspond Ã  une connexion rÃ©seau Ã©tablie par un processus sur une machine Windows)\nRÃ©ponse : 3.78.244.11:8080\nQuestion 4 # En examinant la configuration de la DLL, quelle valeur est associÃ©e Ã  la clÃ© \u0026lsquo;C2Server\u0026rsquo; qui dirige la communication de la balise ?\nOn retourne sur VirusTotal et on retrouve cette information dans l\u0026rsquo;onglet \u0026ldquo;Behavior\u0026rdquo;.\nRÃ©ponse : 3.78.244.11,/dot.gif\nLab terminÃ© !\n","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/posts/midnight-rdp/","section":"Posts","summary":"ScÃ©nario # Un employÃ© informatique dâ€™InfiniTech Solutions a signalÃ© une activitÃ© inhabituelle associÃ©e Ã  son compte e-mail.","title":"Midnight RDP Lab","type":"posts"},{"content":"","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/tags/splunk/","section":"Tags","summary":"","title":"Splunk","type":"tags"},{"content":"","date":"2 mars 2025","externalUrl":null,"permalink":"/blog-cyber/tags/threat-hunting/","section":"Tags","summary":"","title":"Threat Hunting","type":"tags"},{"content":"","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/android-forensic/","section":"Tags","summary":"","title":"Android Forensic","type":"tags"},{"content":"","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/autopsy/","section":"Tags","summary":"","title":"Autopsy","type":"tags"},{"content":"","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/medium/","section":"Tags","summary":"","title":"Medium","type":"tags"},{"content":" ScÃ©nario # Nous avons rÃ©ussi Ã  confirmer la localisation de l\u0026rsquo;acteur malveillant qui a compromis le rÃ©seau WiFi de notre gouvernement.\nRÃ©cemment, un raid Ã  l\u0026rsquo;aube dans le cadre de l\u0026rsquo;OP ERADICATE a Ã©tÃ© menÃ© Ã  une adresse dans la capitale vÃ©lorienne et une quantitÃ© considÃ©rable d\u0026rsquo;Ã©lÃ©ments de preuve a Ã©tÃ© saisie. On notera en particulier un appareil Android appartenant Ã  l\u0026rsquo;agent, dont on pense qu\u0026rsquo;il se trouvait sur le lieu de l\u0026rsquo;attaque.\nNous avons besoin de votre expertise pour analyser cet appareil et rÃ©pondre aux questions dÃ©taillÃ©es ci-dessous. Vous n\u0026rsquo;avez pas beaucoup de temps, une rÃ©union du COBR vÃ©lorien a Ã©tÃ© organisÃ©e pour discuter de vos rÃ©sultats\u0026hellip;\nFichiers # opshieldwall2.zip contenant \u0026ldquo;EVIDENCE-CASE-RAVENSKIAN-AGENT-002\u0026rdquo; oÃ¹ on le retrouve le dossier \u0026ldquo;data\u0026rdquo; et \u0026ldquo;storage\u0026rdquo; d\u0026rsquo;un Android Cela nous laisse pas mal de marge de manÅ“uvre, en effet, le /data contient Ã©normÃ©ment d\u0026rsquo;informations telles que :\nCheatsheet SANS FOR585 Avant propos # Avant de commencer, voici quelques informations importantes sur Android :\nLes donnÃ©es utilisateur peuvent Ãªtre stockÃ©es en interne et en externe sur Android. Les donnÃ©es internes sont enregistrÃ©es dans la mÃ©moire flash NAND, une mÃ©moire non volatile qui conserve les donnÃ©es mÃªme en cas de coupure d\u0026rsquo;alimentation. La NAND stocke le bootloader, le systÃ¨me d\u0026rsquo;exploitation et les donnÃ©es utilisateur. Les donnÃ©es des applications sont stockÃ©es sur la mÃ©moire flash NAND ou sur la carte SD.\nAndroid est basÃ© sur des variantes des branches LTS (long-term support) du Kernel Linux. Avec Android v8 (Oreo), Google a imposÃ© l\u0026rsquo;utilisation de la version 4.4 ou supÃ©rieur du Kernel Linux. Par exemple Android v9 (Pie) fonctionne sur les versions 4.4, 4.9 ou 4.14 selon l\u0026rsquo;appareil. Plus d\u0026rsquo;info disponnible sur le wiki d\u0026rsquo;Android OS https://source.android.com/docs/core/architecture/kernel/android-common?hl=fr.\nandroid-mainlineÂ est la principale branche de dÃ©veloppement des fonctionnalitÃ©s Android. La ligne principale Linux est fusionnÃ©e avecÂ android-mainlineÂ chaque fois que Linus Torvalds publie une version ou une version candidate :\nOn retrouve principalement ces systÃ¨mes de fichiers :\nEXT4 F2FS YAFFS2 exFAT La plupart des artefacts sont des DB SQLite et des fichiers XML. Android isole les applications au niveau du Kernel, leur attribuant un identifiant unique (UID) pour suivre les applications exÃ©cutÃ©es.\nAndroid Architecture # Le noyau Linux constitue la base d\u0026rsquo;Android, supportant des fonctionnalitÃ©s cruciales telles que les threads et la gestion de la mÃ©moire de bas niveau utilisÃ©es par Android Runtime (ART).\nLe HAL fournit des interfaces standardisÃ©es qui exposent les fonctionnalitÃ©s matÃ©rielles aux API Java de niveau supÃ©rieur. Il est composÃ© de modules de bibliothÃ¨que spÃ©cifiques Ã  chaque composant matÃ©riel (comme la camÃ©ra ou le Bluetooth). Lorsqu\u0026rsquo;une API accÃ¨de au matÃ©riel, Android charge le module de bibliothÃ¨que correspondant\nL\u0026rsquo;environnement d\u0026rsquo;exÃ©cution Android (Android Runtime dit ART) exÃ©cute chaque application dans son propre processus et instance. GÃ©rant plusieurs machines virtuelles sur des appareils Ã  faible mÃ©moire grÃ¢ce au bytecode DEX spÃ©cialement conÃ§u et optimisÃ© pour Android. Les outils de compilation comme d8 transforment le code Java en bytecode DEX pour l\u0026rsquo;exÃ©cution sur Android.\nDe nombreux composants et services systÃ¨me Android essentiels, tels qu\u0026rsquo;ART et HAL, sont crÃ©Ã©s Ã  partir de code natif nÃ©cessitant des bibliothÃ¨ques natives Ã©crites en C et C++.\nLes fonctionnalitÃ©s d\u0026rsquo;Android sont accessibles via des API Java, facilitant la rÃ©utilisation des principaux composants et services systÃ¨me modulaires comme les notifications, la gestion des ressources et la localisation.\nLes applications systÃ¨me sont l\u0026rsquo;ensemble des applications de base fournies avec Android.\nAndroid Virtual Machine # Les VM sont utilisÃ©s comme couches d\u0026rsquo;abstraction entre une application et l\u0026rsquo;appareil Android sous-jacent.\nChaque application fonctionne dans sa propre instance dans une VM, isolant les applications les unes des autres.\nLes applications Android sont Ã©crites en Java mais sont compilÃ©es et compilÃ©es en bytecode Java.\nCe bytecode est ensuite transformÃ© en bytecode Dalvik (fichiers .dex) ou bytecode ART.\nDalvik et ART exÃ©cutent le bytecode (.dex) dans une machine virtuelle, permettant aux applications de fonctionner indÃ©pendamment du matÃ©riel sous-jacent.\nAvant KitKat (v.4.4), Android utilisait des VM Dalvik.\nAvec Lollipop (v5.0), Android a commencÃ© Ã  utiliser Android Runtime (ART) et a cessÃ© d\u0026rsquo;utiliser la VM Dalvik.\nLes deux environnements d\u0026rsquo;exÃ©cution Dalvik et ART fonctionnent avec le bytecode DEX, mais ART possÃ¨de de nouvelles fonctionnalitÃ©s d\u0026rsquo;optimisation.\nDirectory structure # /cache : peut contenir des piÃ¨ces jointes gmail, des tÃ©lÃ©chargements, des donnÃ©es de navigation et des mises Ã  jour OTA /efs : contient des fichiers nÃ©cessaires au fonctionnement de l\u0026rsquo;appareil en cas de dÃ©faillance /data : /data/data : contient les dossiers des applications (/data/data/com.example.app), les fichiers de configurations des apps, les DB SQLite des apps, leurs logs, cache etc. /app : contient des fichiers .apk du marchÃ© Android *Des malwares peuvent Ãªtre trouvÃ©s ici /backup : stocke l\u0026rsquo;API de sauvegarde pour les dÃ©veloppeurs donc les donnÃ©es de sauvegarde des utilisateurs ne sont pas stockÃ©es ici /media : l\u0026rsquo;emplacement de stockage interne Ã©quivalent Ã  une carte SD. *Des malwares malveillants peuvent Ãªtre trouvÃ©s ici /misc : les fichiers liÃ©s Ã  Bluetooth, dhcp, vpn, Wi-Fi, etc. sont stockÃ©s ici /system : contient des fichiers clÃ©s tels que gesture.key et passwords.key ; le fichier accounts.db qui contient les usernames et les mots de passe pour l\u0026rsquo;authentification des fichiers etc. /property : contient les propriÃ©tÃ©s du systÃ¨me, y compris le fuseau horaire, les paramÃ¨tres de langue, etc. /mnt : /asec : stocke les donnÃ©es non chiffrÃ©s des apps /DCIM : stocke les thumbnails des albums /Pictures : stocke les images de l\u0026rsquo;appareil photo /downloads : fichiers tÃ©lÃ©chargÃ©s localement /secure/asec : stocke les donnÃ©es chiffrÃ©s des apps /system : /app : contient des fichiers .apk. *Des malwares peuvent Ãªtre trouvÃ©s ici /priv-app : contient des fichiers \u0026amp; apk avec des permissions au niveau du systÃ¨me. *Des malwares peuvent Ãªtre trouvÃ©s ici Pour avoir plus d\u0026rsquo;informations sur\nles permissions des app : https://developer.android.com/guide/topics/permissions/overview?hl=fr ; https://blog.mindorks.com/what-are-the-different-protection-levels-in-android-permission/ la CLI d\u0026rsquo;Android : https://developer.android.com/tools/adb?hl=fr Setup # Au vu des fichiers et du scÃ©nario, je vais utiliser l\u0026rsquo;outil Autopsy. Cela peut prendre un peu de temps Ã  ce setup, c\u0026rsquo;est pour cela que j\u0026rsquo;attaque cela ici.\nSi vous ne connaissez pas Autopsy, voici une briÃ¨ve description :\nAutopsy est un outil d\u0026rsquo;investigation numÃ©rique opensource. Il se rapporte Ã  l\u0026rsquo;interface graphique du Sleuth Kit et d\u0026rsquo;autres outils de forensic. Il est utilisÃ© pour analyser des disques durs et des smartphones dans le cadre d\u0026rsquo;enquÃªtes. Les fonctionnalitÃ©s clÃ©s d\u0026rsquo;Autopsy incluent la rÃ©cupÃ©ration de fichiers supprimÃ©s, l\u0026rsquo;analyse des mÃ©tadonnÃ©es, la recherche par mots-clÃ©s, la visualisation des timelines d\u0026rsquo;activitÃ©s, et l\u0026rsquo;analyse des systÃ¨mes de fichiers etc.\nPour l\u0026rsquo;utiliser, nous devons crÃ©er une \u0026ldquo;Case\u0026rdquo; :\nIci, nous savons que nous n\u0026rsquo;avons pas Ã  faire Ã  une \u0026ldquo;Disk Image\u0026rdquo; ou Ã  une VM, de mÃªme pour un disque local. Nous choisissons donc l\u0026rsquo;option appropriÃ©e \u0026ldquo;Logical Files\u0026rdquo; :\nOn attend qu\u0026rsquo;Autopsy \u0026amp; ses modules terminent l\u0026rsquo;ingestion. Cela peut prendre un moment.\nC\u0026rsquo;est bon, on peut commencer l\u0026rsquo;investigation :\nQuestions # Question 1 # Quelle est l\u0026rsquo;adresse mail de l\u0026rsquo;agent qui a Ã©tÃ© utilisÃ©e dans diverses applications/services ?\nPour y rÃ©pondre, je vais utiliser le rapport qu\u0026rsquo;Autopsy a gÃ©nÃ©rÃ© via ALEAPP (Android Logs Events And Protobuf Parser), un projet open-source qui vise Ã  analyser tous les artefacts Android connus Ã  des fins d\u0026rsquo;analyse forensic.\nPour trouver rapidement et simplement nous pouvons chercher dans :\n/data/data/com.android.vending/databases/library.db pour y trouver le compte google utilisÃ© pour download des apps /data/data/com.android.providers.contacts/databases/contacts2.db pour y trouver le compte google utilisÃ© pour synchroniser ses contacts Mais aussi (mais non applicable sur ce challenge) ici :\n/data/com.android.vending/shared_prefs/lastaccount.xml (dernier compte utilisÃ© sur Google PlayStore (Android 9 et plus)) /data/com.google.android.gms/shared_prefs/BackupAccount.xml (email du compte de backup) /data/com.android.email/databases/EmailProvider.db (email accounts, 3rd party app data et les messages associÃ©s aux notifications par emails) Enfin bref, on se retrouve donc avec le rapport en format html :\nOn peut retrouver son adresse mail un peu partout.\nDans l\u0026rsquo;app \u0026ldquo;Chrome\u0026rdquo; par exemple avec la partie \u0026ldquo;Autofill\u0026rdquo; (fonctionnalitÃ© qui permet de remplir automatiquement des formulaires avec des informations prÃ©enregistrÃ©es) :\nDans les \u0026ldquo;Login Data\u0026rdquo; de Chrome :\nEnfin dans la partie \u0026ldquo;Installed Apps (Library)\u0026rdquo; nous retrouvons l\u0026rsquo;adresse mail du compte google utilisÃ© pour download des apps :\nRÃ©ponse : olegpachinksy@gmail.com\nQuestion 2 # Quel est le numÃ©ro de contact du gestionnaire (handler) affectÃ© Ã  l\u0026rsquo;agent qui a Ã©tÃ© arrÃªtÃ© ?\nDans la partie \u0026ldquo;Contacts\u0026rdquo; :\nRÃ©ponse : +323145232315\nQuestion 3 # RÃ©cupÃ©rer les identifiants et le lien du portail officiel des agents ravenskiens. Cela peut nous donner un avantage en matiÃ¨re de renseignement car nous pouvons utiliser cet accÃ¨s pour obtenir d\u0026rsquo;autres informations exploitables sur les opÃ©rations que le gouvernement ravenskien planifie.\nNous avons dÃ©jÃ  trouvÃ© la rÃ©ponse Ã  cette question Ã  la question nÂ°1 via les \u0026ldquo;Login Data\u0026rdquo; de Chrome :\nRÃ©ponse : agent.ravensk.idu.com:olegpachinksy007:HBLKNKD0MADsdfsa2334(*\u0026amp;DSMDB\nQuestion 4 # Quel est le code de contact utilisÃ© pour confirmer l\u0026rsquo;identitÃ© de l\u0026rsquo;agent et du gestionnaire lors de l\u0026rsquo;utilisation d\u0026rsquo;un canal de discussion sÃ©curisÃ© ?\nPremiÃ¨rement je vais vÃ©rifier les potentiels SMS ici : /data/data/com.android.providers.telephony/databases/mmssms.db.\nNous n\u0026rsquo;y trouvons rien.\nNous pourrions aussi chercher ici mais non applicable sur ce challenge :\n/data/com.google.android.gms/databases/icing_mmssms.db (SMS/MMS) /data/com.google.android.gms/databases/ipa_mmssms.db (SMS/MMS) Nous devons donc trouver l\u0026rsquo;app de messagerie utilisÃ©. On peut voir toutes les apps installÃ©es dans la partie \u0026ldquo;Installed Programs\u0026rdquo; d\u0026rsquo;Autopsy :\nOn y trouve diffÃ©rente catÃ©gorie :\nInstalled Apps (GMS) Installed Apps (Library) Installed Apps (Vending) Installed Apps - GMS : Cette catÃ©gorie concerne les applications installÃ©es sur l\u0026rsquo;appareil, quel que soit leur mode d\u0026rsquo;installation. On peut retrouver ces donnÃ©es ici :Â /data/com.google.android.gms/databases/.\nInstalled Apps - Library : Cette catÃ©gorie se rÃ©fÃ¨re Ã  la bibliothÃ¨que d\u0026rsquo;applications pour l\u0026rsquo;utilisateur Google utilisant l\u0026rsquo;appareil. Il est important de noter que cette DB n\u0026rsquo;est pas liÃ©e aux applications installÃ©es sur l\u0026rsquo;appareil, elle peut contenir des applications installÃ©es par le mÃªme compte Google sur un autre appareil ou sur une prÃ©cÃ©dente installation de l\u0026rsquo;appareil analysÃ©. On peut retrouver ces donnÃ©es ici :Â /data/com.android.vending/databases/.\nInstalled Apps - Vending : Cette catÃ©gorie concerne spÃ©cifiquement les applications installÃ©es sur l\u0026rsquo;appareil via le Google Play Store, excluant celles installÃ©es par d\u0026rsquo;autres moyens. Ces donnÃ©es ne sont pas supprimÃ©es lorsque l\u0026rsquo;application est dÃ©sinstallÃ©e. Elles sont stockÃ©es dans une DB SQLite situÃ©e ici : /data/com.android.vending/databases/.\nPour plus de lisibilitÃ© retournons sur ALEAPP et concentrons-nous sur les apps de type \u0026ldquo;Vending\u0026rdquo; :\nL\u0026rsquo;app qui saute au yeux c\u0026rsquo;est mega.privacy.android.app. Et en effet, c\u0026rsquo;est une application de messagerie :\nJustement ALEAPP a parsÃ© les messages Ã©changÃ©s via MEGA :\nOn peut retrouver ces infomations ici : /data/data/mega.privacy.android.app/karere-TU1IaTh4TUJpdTQKAfO_2P0qU8NMP7zDRlgv.db.\nRÃ©ponse : REDAPPLEONACAR\nQuestion 5 # Le gestionnaire a partagÃ© un document avec l\u0026rsquo;agent en utilisant un service de stockage cloud. Quand ce fichier a-t-il Ã©tÃ© partagÃ© avec l\u0026rsquo;agent ?\nRien dans les messages. Le document a donc dÃ» Ãªtre transmis d\u0026rsquo;une autre maniÃ¨re. Nous savons qu\u0026rsquo;il n\u0026rsquo;y a pas d\u0026rsquo;autre app de messagerie et qu\u0026rsquo;il n\u0026rsquo;a pas pu lui communiquer via SMS/MMS.\nDans les app installÃ© nous avons vu com.google.android.apps.docs. Allons donc chercher ici : \\data\\data\\com.google.android.apps.docs.\nOn y trouve la DB /data/data/com.google.android.apps.docs/app_cello/olegpachinksy@gmail.com/cello.db contenant ces informations :\nOn peut d\u0026rsquo;ailleurs retrouver ce fichier ici : EVIDENCE-CASE-RAVENSKIAN-AGENT-002/storage/emulated/0/Download/Debrief-Velorian OP Expansion East.pdf :\nNÃ©anmoins attention, par dÃ©faut Autopsy interprÃ¨te les timestamps avec la time zone de votre ordinateur. Pensez bien Ã  modifier ce paramÃ¨tre dans Autopsy (Tools \u0026gt; Options \u0026gt; View \u0026gt; Time Zone).\nRÃ©ponse : 2024-04-01 09:36:41\nQuestion 6 # Quel est l\u0026rsquo;URI de tÃ©lÃ©chargement du fichier partagÃ© prÃ©cÃ©demment identifiÃ© ?\nNous savons que le fichier a Ã©tÃ© tÃ©lÃ©chargÃ© car nous l\u0026rsquo;avons retrouvÃ© dans /storage/emulated/0/Download/.\nNous pouvons donc chercher dans /data/data/com.android.providers.downloads/databases/downloads.db :\nRÃ©ponse : https://www.googleapis.com/drive/v2internal/files/1iQKKlBU2vuJD1Xet6IYPt7IODVtDHxv1?alt=media\u0026amp;source=downloadUrl\u0026amp;auditContext=fileAction\u0026amp;reason=909\u0026amp;syncType=1\u0026amp;featureLabel=android-sync-classic\u0026amp;openDrive=false\u0026amp;errorRecovery=false\u0026amp;originatorApp=102\nQuestion 7 # Afin d\u0026rsquo;obtenir davantage d\u0026rsquo;informations pour le contre-espionnage de Veloria, quel Ã©tait l\u0026rsquo;objectif principal de cette cyber-opÃ©ration menÃ©e par le gouvernement de Ravensk ?\nRevenons au document :\nRÃ©ponse : Infiltrate the Velorian secured network to gather intelligence on upcoming cyber-attacks, their techniques, and target countries.\nQuestion 8 # L\u0026rsquo;identification du gestionnaire est Ã©galement cruciale pour que les forces de l\u0026rsquo;ordre vÃ©loriennes puissent comprendre l\u0026rsquo;Ã©tendue de cette opÃ©ration. Quelle est l\u0026rsquo;adresse Ã©lectronique utilisÃ©e par le manipulateur ?\nNous l\u0026rsquo;avons dÃ©jÃ  vu dans les messages de l\u0026rsquo;app MEGA :\nRÃ©ponse : ivoryalex783@gmail.com\nQuestion 9 # Quel est le nom de l\u0026rsquo;endroit oÃ¹ l\u0026rsquo;agent et le gestionnaire se sont rencontrÃ©s ?\nRevenons aux messages :\nC\u0026rsquo;est la question qui m\u0026rsquo;a pris le plus de temps, j\u0026rsquo;ai dÃ» bloquer une bonne heure dessus.\nPremiÃ¨rement, j\u0026rsquo;ai cherchÃ© dans les endroits habituels :\n/data/com.google.android.apps.maps/databases/gmm_storage.db /data/com.google.android.apps.maps/databases/search_history.db /data/com.google.android.apps.maps/databases/da_destination_history /data/com.sec.android.daemonapp/db/weatherClock /data/com.google.android.apps.maps/app_tts-cache/ /data/com.google.android.apps.maps/cache/image_manager_disk_cache/ AprÃ¨s n\u0026rsquo;avoir rien trouvÃ©, je me suis dit qu\u0026rsquo;il Ã©tait sans doute possible que la rÃ©ponse soit dans les metadatas des images sur le tÃ©lÃ©phone. En effet, on retrouve 48 images dont plusieurs de bar :\nNÃ©anmoins, rien de probant.\nJe me suis donc posÃ© plusieurs questions :\nil y a-t-il d\u0026rsquo;autres applications de navigation / localisation sur le tÃ©lÃ©phone ? est-il sÃ»r que je dois chercher dans l\u0026rsquo;app Google Maps ? Non, seulement Google Maps. Non, il est peut-Ãªtre possible qu\u0026rsquo;il ait fait la recherche sur son navigateur et non sur l\u0026rsquo;app etc. Ayant dÃ©jÃ  vÃ©rifiÃ© les points habituels des artefacts de google maps j\u0026rsquo;ai prÃ©fÃ©rÃ© chercher dans le navigateur mais je n\u0026rsquo;ai rien trouvÃ©.\nJe suis donc retournÃ© fouiller dans les artefacts de google maps :\napp : RAS app_offline_downloads : RAS app_offline_hashes : RAS app_textures : RAS app_webview : RAS cache : RAS databases : trop de fichiers, j\u0026rsquo;y reviendrai plus tard files : \u0026ldquo;new_recent_history_cache_search.cs\u0026rdquo; Je me rends compte que j\u0026rsquo;aurais simplement pu chercher par mot-clÃ© \u0026ldquo;Pub\u0026rdquo; ğŸ¤¡\nRÃ©ponse : Levstik Pub\nQuestion 10 # D\u0026rsquo;aprÃ¨s le chat retrouvÃ© entre l\u0026rsquo;agent et le gestionnaire, il semble que ce dernier ait envoyÃ© Ã  l\u0026rsquo;agent arrÃªtÃ© une image relative Ã  l\u0026rsquo;infrastructure utilisÃ©e par le gouvernement ravenskien pour cette opÃ©ration de cyberespionnage. Quel est le cadre C2 utilisÃ© par le gouvernement ravenskien ?\nAyant dÃ©jÃ  vÃ©rifiÃ© toutes les images pour rÃ©pondre Ã  la question 9 j\u0026rsquo;ai dÃ©jÃ  la rÃ©ponse.\nRÃ©ponse : Empire\nQuestion 11 # La collecte d\u0026rsquo;informations sur l\u0026rsquo;infrastructure, telles que les adresses IP ou les noms d\u0026rsquo;hÃ´tes, est cruciale pour les autoritÃ©s vÃ©loriennes, qui prÃ©parent une opÃ©ration de contre-offensive. D\u0026rsquo;aprÃ¨s l\u0026rsquo;image rÃ©cupÃ©rÃ©e envoyÃ©e par le gestionnaire Ã  l\u0026rsquo;agent, quelle est l\u0026rsquo;adresse IP de l\u0026rsquo;un des serveurs C2 exploitÃ©s par les acteurs de la menace ravenskiens ?\nRÃ©ponse : 98.24.12.45\n","date":"19 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/opshieldwall-2/","section":"Posts","summary":"ScÃ©nario # Nous avons rÃ©ussi Ã  confirmer la localisation de l\u0026rsquo;acteur malveillant qui a compromis le rÃ©seau WiFi de notre gouvernement.","title":"OpShieldWall-2","type":"posts"},{"content":"","date":"7 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/easy/","section":"Tags","summary":"","title":"Easy","type":"tags"},{"content":"","date":"7 mai 2024","externalUrl":null,"permalink":"/blog-cyber/tags/network-forensic/","section":"Tags","summary":"","title":"Network Forensic","type":"tags"},{"content":" ScÃ©nario # Merci d\u0026rsquo;avoir rÃ©pondu Ã  notre appel. Le ministÃ¨re de la DÃ©fense de Velorian a dÃ©sespÃ©rÃ©ment besoin d\u0026rsquo;aide\u0026hellip;\nNous devons rester discrets, mais nous pensons que le Wi-Fi public des bureaux du ministÃ¨re de la DÃ©fense de Velorian a Ã©tÃ© compromis. L\u0026rsquo;impact semble faible, mais les diagrammes du rÃ©seau montrent qu\u0026rsquo;aucune segmentation rÃ©elle du rÃ©seau n\u0026rsquo;a Ã©tÃ© rÃ©alisÃ©e et que le trafic entre les appareils est autorisÃ©. Les ministres du gouvernement utilisent ce rÃ©seau avec des Ã©quipements BYoD et des hÃ´tes Velorian MoDNet. Veuillez analyser le pcap fourni et confirmer comment et quand cela s\u0026rsquo;est produit. N\u0026rsquo;oubliez pas que cette enquÃªte est de type TLP Amber.\nFichiers # opshieldwall1.zip contenant la capture rÃ©seau \u0026ldquo;VELORIA-NETWORK.pcap\u0026rdquo; Setup # Au vu de la simplicitÃ© de ce challenge, on peut simplement se limiter Ã  tshark / wireshark.\nQuestions # Question 1 # Veuillez confirmer le SSID de notre rÃ©seau WiFi.\nPremiÃ¨rement, familiarisez-nous avec la capture. Nous allons utiliser la commande suivante afin d\u0026rsquo;avoir des statistiques :\n$ tshark -r traffic.pcapng -qz -r permet de lire (read) un fichier -q permet d\u0026rsquo;Ãªtre plus \u0026ldquo;quiet\u0026rdquo; Ã  la sortie (utile pour les stats car cela permet d\u0026rsquo;afficher les statistiques globales, et non par paquet.) -z permet l\u0026rsquo;affichage de statistiques Il y a beaucoup de valeurs possible (tshark -z help pour les afficher) mais ici nous souhaitons avant tout savoir :\nle nombre de paquet la durÃ©e de la capture les IPv4 avec le plus de paquet les IPv4 endpoints Ã©changeant ensemble le plus les protocoles les plus utilisÃ©s Nombre de paquet et durÃ©e : 106 ; 31.6 sec\n$ tshark -r VELORIA-NETWORK.pcap -qz io,stat,0 =================================== | IO Statistics | | | | Duration: 31.6 secs | | Interval: 31.6 secs | | | | Col 1: Frames and bytes | |---------------------------------| | |1 | | | Interval | Frames | Bytes | | |-------------------------------| | | 0.0 \u0026lt;\u0026gt; 31.6 | 106 | 20759 | | =================================== IPv4 endpoints :\navec le plus de paquet : $ tshark -r VELORIA-NETWORK.pcap -qz endpoints,ip ================================================================================ IPv4 Endpoints Filter:\u0026lt;No Filter\u0026gt; | Packets | | Bytes | | Tx Packets | | Tx Bytes | | Rx Packets | | Rx Bytes | 0.0.0.0 3 1044 3 1044 0 0 255.255.255.255 3 1044 0 0 3 1044 10.0.3.1 3 1048 3 1048 0 0 10.0.3.52 3 1048 0 0 3 1048 ================================================================================ Ã©changeant le plus : tshark -r VELORIA-NETWORK.pcap -qz conv,ip ================================================================================ IPv4 Conversations Filter:\u0026lt;No Filter\u0026gt; | \u0026lt;- | | -\u0026gt; | | Total | Relative | Duration | | Frames Bytes | | Frames Bytes | | Frames Bytes | Start | | 0.0.0.0 \u0026lt;-\u0026gt; 255.255.255.255 0 0 bytes 3 1044 bytes 3 1044 bytes 23.256576000 8.3680 10.0.3.1 \u0026lt;-\u0026gt; 10.0.3.52 0 0 bytes 3 1048 bytes 3 1048 bytes 23.256959000 8.3693 ================================================================================ Protocoles les plus utilisÃ©s :\ntshark -r VELORIA-NETWORK.pcap -qz io,phs =================================================================== Protocol Hierarchy Statistics Filter: sll frames:106 bytes:20759 radiotap frames:92 bytes:17572 wlan_radio frames:92 bytes:17572 wlan frames:92 bytes:17572 wlan.mgt frames:92 bytes:17572 eapol frames:6 bytes:999 eap frames:6 bytes:999 ip frames:6 bytes:2092 udp frames:6 bytes:2092 dhcp frames:6 bytes:2092 arp frames:2 bytes:96 =================================================================== Pour rÃ©pondre Ã  la question, il suffit d\u0026rsquo;utiliser la commande :\n$ tshark -r VELORIA-NETWORK.pcap -T fields -e wlan.ssid | head -n 1 | xxd -r -p VELORIA-MoD-AP012 Explication : (https://www.wireshark.org/docs/dfref/w/wlan.html)\n-t affiche uniquement les champs spÃ©cifiÃ©s par l\u0026rsquo;utilisateur (nÃ©cessite donc forcÃ©ment l\u0026rsquo;utilisation de l\u0026rsquo;option -e pour spÃ©cifier les champs). -e wlan.ssid spÃ©cifie que le champ wlan.ssid (SSID des rÃ©seaux sans fil) doit Ãªtre extrait et affichÃ©. -xxd -r -p l\u0026rsquo;output Ã©tant une suite hexadÃ©cimale, cela permet de le convertir en texte lisible RÃ©ponse : VELORIA-MoD-AP012\nQuestion 2 # Veuillez confirmer l\u0026rsquo;adresse MAC du point d\u0026rsquo;accÃ¨s (AP).\ntshark -r VELORIA-NETWORK.pcap -T fields -e wlan.sa | head -n 1 02:00:00:00:01:00 RÃ©ponse : 02:00:00:00:01:00\nQuestion 3 # Veuillez confirmer l\u0026rsquo;Ã©tat/le mÃ©canisme d\u0026rsquo;authentification de l\u0026rsquo;AP et le vecteur d\u0026rsquo;attaque.\nPassons Ã  Wireshark.\nRÃ©ponse : WPS\nQuestion 4 # Quel est le numÃ©ro de paquet oÃ¹ l\u0026rsquo;attaque a-t-elle commencÃ© ?\nOn peut facilement en dÃ©duire que c\u0026rsquo;est Ã  la premiÃ¨re tentative de connexion (Ã©tant les seuls dans la capture).\nRÃ©ponse : 93\nQuestion 5 # Quel est le numÃ©ro de paquet oÃ¹ l\u0026rsquo;attaque s\u0026rsquo;est-elle terminÃ©e ?\nOn peut facilement en dÃ©duire que c\u0026rsquo;est lorsque l\u0026rsquo;authentifcation a Ã©chouÃ©.\nRÃ©ponse : 8\n","date":"7 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/opshieldwall-1/","section":"Posts","summary":"ScÃ©nario # Merci d\u0026rsquo;avoir rÃ©pondu Ã  notre appel.","title":"OpShieldWall-1","type":"posts"},{"content":" DiplÃ´mes # Les images sont des liens cliquables.\nEn cours (Promo 2026) MastÃ¨re (BAC+5) - Expert de la sÃ©curitÃ© des donnÃ©es, des rÃ©seaux et des systÃ¨mes\nUniquement en alternance\nJe m'occupe des entretiens de motivation et technique des nouveaux Ã©tudiants\n(NÂ° RNCP 38951) Bachelor (BAC+3) - CybersÃ©curitÃ© \u0026 Ethical Hacking\n3Ã¨me annÃ©e en alternance\nMention - TrÃ¨s bien Bachelor (BAC+3) - Concepteur de SystÃ¨mes d'Information Mention - TrÃ¨s bien Liste de tous les challenges, labs, box etc. que j\u0026rsquo;ai effectuÃ© mais aussi des cours, confÃ©rences et trainings auquels j\u0026rsquo;ai assistÃ© :\nHackTheBox # Iron = Insane Red = Hard Orange = Medium Green = Easy Purple = Very Easy Certaines images ne redirigent pas vers les pages de rÃ©sultat d\u0026rsquo;HTB car se sont des boxs / sherlocks uniquement disponibles sur la plateforme HackTheBox Entreprise (qui ne permet pas de faire des liens de partage).\nSherlock # DFIR / SOC # OpShieldWall-7 Streamer APTNightmare-2 Latus Heartbreaker Trent APTNightmare Nuts OpShieldWall-4 OpShieldWall-2 OpShieldWall-1 NeuroSync-D Pikaptcha Meerkat Bumblebee Jingle Bell Recollection Kuber Noted Tracer Log Jammer Rogue One Phantom-Check Smoke-Mirrors Origins SmartyPants Reaper Campfire-2 Campfire-1 Unit42 CrownJewel-2 CrownJewel-1 Brutus Noxious Malware Analysis # OpShieldWall-6 Loggy HB-Continuum Cloud # Nubilum-2 Threat Intelligence # DreamJob-1 ElectricBreeze-1 UFO-1 Box # Linux # OpShieldWall-5 OpShieldWall-3 Blurry Runner IClean Perfection BoardLight Headless Wifinetic MetaTwo Lame Nibbles Precious Windows # Jerry Netmon Blue HackTheBox Academy # Transcript.pdf\nRootMe # Cyberdefenders # Threat Hunting # Hard Network Forensics # Hard Medium Medium Medium Medium Medium Easy Easy Easy Easy Easy Easy Easy Easy Endpoint Forensics # Medium Easy Threat Intel # Medium Medium Easy Easy Easy Easy Cloud Forensics # Easy TryHackMe # 92 rooms complÃ©tÃ©s\nPath :\nPre Security Complete Beginner Web Fundamentals Comptia Pentest+ Cours \u0026amp; formations suivis # 2025 # SANS : FOR585: Smartphone Forensic Analysis In-Depth 13Cubed : Investigating Windows Endpoint 13Cubed : Investigating Windows Memory 13Cubed : Investigating Linux Devices 2024 # Evasive Malware : A Field Guide to Detecting, Analyzing, and Defeating Advanced Threats Roman Stuehler : Android App Hacking - Black Belt Edition Kaspersky : Advanced Malware Analysis Techniques Kaspersky : Hunting APTs like a Ninja with YARA OALABS : Reverse Engineering 101 (RE101) Pentherz : Intro to SDR Hacking 2023 # OSINT : IntelTechniques Christopher Negus : Linux Bible Opdisk : The Cyber Plumber\u0026rsquo;s Handbook Conf \u0026amp; meetups # 2025 # THCON - Toulous Hacking Convention 2024 # DEFCON Paris Meetup HackTheBox France 2023 # Hexacon DEFCON Paris LeHack Meetup HackTheBox France ","date":"6 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/portfolio/","section":"Posts","summary":"DiplÃ´mes # Les images sont des liens cliquables.","title":"Portfolio","type":"posts"},{"content":"Liste des projets que j\u0026rsquo;ai effecutÃ©.\nSelf-Hosted Infrastructure # Juin 2023 - maintenant\nProfessional Server (HP ProLiant DL380 Gen9 2U) sous Proxmox Firewall sous OPNsense Self-hosted services et tools: VPN, Security Onion, Wazuh, Cuckoo Sandbox, GitLab, VM pour CTF, labs en tout genre (red team / blue team\u0026hellip;) Un lab spÃ©cial de Malware Analysis \u0026amp; d\u0026rsquo;OSINT avec une emphase sur la sÃ©curitÃ©, la vie privÃ©e et l\u0026rsquo;OPSEC Architecture, network segmentation, intÃ©gration IPS/IDS, load balancing, SRE, VPN CTF Challenge Creator # Juin 2024 - Juin 2024\nCrÃ©ation de deux challenges de radio (misc easy and medium) pour le \u0026ldquo;PwnMe CTF 2024\u0026rdquo;.\nhttps://ctftime.org/ctf/807/\nhttps://www.phreaks2600.fr/\nSide Quest - Toolkit Network Forensic \u0026amp; Malware Analysis # FÃ©vr. 2024 - Juin 2024\nNotre side quest est un projet collaboratif d\u0026rsquo;Ã©tudiants pour fournir un toolkit puissant pour la forensique rÃ©seau et l\u0026rsquo;analyse de malware. Ce repository contient deux sous-projets qui se concentrent sur diffÃ©rents aspects de l\u0026rsquo;investigation :\nNetwork Forensic Analysis : Outils d\u0026rsquo;analyse du trafic rÃ©seau capturÃ© dans des fichiers PCAP. Analyse des malwares : Outils permettant de dissÃ©quer les fichiers binaires afin de dÃ©couvrir des informations cachÃ©es et de dÃ©tecter des caractÃ©ristiques malveillantes. https://github.com/jaybird1291/toolkit-network-forensic-malware-analysis-sidequest\n","date":"5 mai 2024","externalUrl":null,"permalink":"/blog-cyber/posts/projets/","section":"Posts","summary":"Liste des projets que j\u0026rsquo;ai effecutÃ©.","title":"Projets","type":"posts"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/blog-cyber/series/","section":"Series","summary":"","title":"Series","type":"series"}]